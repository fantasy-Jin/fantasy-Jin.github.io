{"meta":{"title":"FantasyのBlog","subtitle":"Fantasyの博客","description":"努力成为一名程序员","author":"Fantasy","url":"http://fantasy06.github.io","root":"/"},"pages":[{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"http://fantasy06.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"404.html","permalink":"http://fantasy06.github.io/404.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"archives/index.html","permalink":"http://fantasy06.github.io/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"census/index.html","permalink":"http://fantasy06.github.io/census/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"about/index.html","permalink":"http://fantasy06.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"categories/index.html","permalink":"http://fantasy06.github.io/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2022-08-05T06:26:30.000Z","updated":"2022-08-05T10:29:58.810Z","comments":true,"path":"404/index.html","permalink":"http://fantasy06.github.io/404/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"resource/index.html","permalink":"http://fantasy06.github.io/resource/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"friends/index.html","permalink":"http://fantasy06.github.io/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-08-06T03:50:23.678Z","comments":true,"path":"contact/index.html","permalink":"http://fantasy06.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Blogの友链信息 博客名称: FantasyのBlog 博客介绍: The harder you work, the luckier you will be"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"tags/index.html","permalink":"http://fantasy06.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-08-05T13:38:26.193Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/index.html","permalink":"http://fantasy06.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/music/index.html","permalink":"http://fantasy06.github.io/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"http://fantasy06.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/movies/index.html","permalink":"http://fantasy06.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-08-05T13:38:26.197Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://fantasy06.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-08-05T13:38:26.194Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://fantasy06.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-08-05T13:38:26.196Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://fantasy06.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-08-05T13:38:26.198Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://fantasy06.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-08-05T13:38:26.199Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://fantasy06.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-08-05T13:38:26.201Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://fantasy06.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-08-05T13:38:26.202Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://fantasy06.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-08-05T13:38:26.203Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://fantasy06.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-08-05T13:38:26.204Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://fantasy06.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-08-05T13:38:26.204Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://fantasy06.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-08-05T13:38:26.206Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://fantasy06.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-08-05T13:38:26.200Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://fantasy06.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""}],"posts":[{"title":"html and css","slug":"html-and-css","date":"2022-08-06T04:31:45.000Z","updated":"2022-08-06T04:38:18.587Z","comments":true,"path":"posts/28784acc.html","link":"","permalink":"http://fantasy06.github.io/posts/28784acc.html","excerpt":"","text":"HTML初级整体结构 &lt;html&gt; &lt;!--开始标签--&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;!--字符编码避免网页文字乱码--&gt; &lt;title&gt;网页的标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--网页的基本内容--&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--结束标签--&gt; 初级标签 标题标签 H1，H2，….，H6。（1–&gt;6）大标题–&gt;小标题，成对出现，开始标签 &lt;H1&gt; ，一个结束标签 &lt;/H1&gt; 。 段落标题 段落是通过 &lt;p&gt; 标签进行定义的，成对出现，开始标签 &lt;p&gt; ，一个结束标签 &lt;/p&gt; 。 文字标签 &lt;strong&gt;&lt;/strong&gt;，加粗文字标签；&lt;em&gt;&lt;/em&gt; 斜体文字标签，可嵌套 符号标签 &lt;del&gt;&lt;/del&gt;，在文字上添加删除线，如：文字 高级标签 块状标签 &lt;div&gt;&lt;/div&gt; ,每一个div占满一整行。 &lt;span&gt;&lt;/span&gt;，文本信息在一行展示 空格和换行，尖括号 &lt;br&gt; 换行标签，&amp;nbsp; 空格符号，&amp;lt 左尖括号，&amp;gt; 右尖括号 有序列表标签 &lt;ol&gt; &lt;!--网页显示--&gt; &lt;li&gt;第一条&lt;/li&gt; &lt;!--1.第一--&gt; &lt;li&gt;第二条&lt;/li&gt; &lt;!--2.第二--&gt; &lt;li&gt;第三条&lt;/li&gt; &lt;!--3.第三--&gt; &lt;/ol&gt; &lt;ol&gt; 可以增加属性，type，换排序符号； 如 &lt;ol type=\"A\"&gt; ，就从A，B顺序排列；符号可以换 A,a,1,i I ，不填默认数值1； 倒叙 &lt;ol reversed=\"reversed\"&gt; ； &lt;ol start=\"数值\"&gt;，更换开始符号的数值； 无序列表标签 &gt;&lt;ul&gt; &gt;&lt;li&gt;第一条&lt;/li&gt; &gt;&lt;li&gt;第二条&lt;/li&gt; &gt;&lt;li&gt;第三条&lt;/li&gt; &gt;&lt;/ul&gt; 默认每一段文本前面显示小圆点 属性：&lt;ul type=disc&gt; 默认值实心小圆点，circle 空心小圆点，square 小方块 图片插入 &lt;img src=\"图片路径\"&gt; 包括： 1，网上url； 2，本地的绝对路径(同一个文件夹下，直接写图片文件名)； 3，本地的相对路径(不同一个文件夹下，写完整图片路径)； 属性： 1，&lt;img src=\"图片路径\" alt=\"图片占位符\"&gt;，即图没有加载出来时显示 2，&lt;img src=\"图片路径\" title=”图片提示符“&gt;，即鼠标移到图时显示 链接标签a 超链接：&lt;a href=\"网址\"&gt;网站名&lt;/a&gt; 锚点：&lt;a href=\"#id\"&gt;文字&lt;/a&gt;；id指某个标签的id名字，运用于：页面目录，回到顶部 打电话或发邮件：&lt;a href=\"tel:电话号码\"&gt;文字&lt;/a&gt;；&lt;a href=\"mailto:邮箱地址\"&gt;文字&lt;/a&gt; 协议限定符：使用js 属性：target=_blank 点击链接在新页面弹出 表单 信息输入框 &lt;form method=\"get\" action=\"\" &gt; &lt;!--action：发送出去的地址--&gt; name: &lt;input type=\"text\" name=\"name\" /&gt; &lt;!--文本输入框，name：数值内容--&gt; password: &lt;input type=\"password\" name=\"password\" /&gt; &lt;!--密码输入框，name：数值内容--&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;!--提交按键，value：数据值--&gt; &lt;/form&gt; 单选框 &lt;form method=\"get\" action=\"\" &gt; &lt;!--action：发送出去的地址--&gt; &lt;p&gt; 选择其中一个 &lt;/p&gt; 1.第一个&lt;input type=\"radio\" name=\"name\" value:\"one\"&gt; &lt;!--name相同表示同个选择问题--&gt; 1.第二个&lt;input type=\"radio\" name=\"name\" value:\"two\"&gt; 1.第三个&lt;input type=\"radio\" name=\"name\" value:\"three\"&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;!--提交按键， value：数据值--&gt; &lt;/form&gt; 副选框 &lt;input type=\"checkobx\" name=\"题目\" value:\"提交的数值\"&gt; &lt;!--大致与上面相同--&gt; 选项下拉菜单 &lt;select name=\"\"&gt; &lt;option&gt;选项一&lt;/option&gt; &lt;option&gt;选项二&lt;/option&gt; &lt;/select&gt; 表单添加默认选项：标签后加入 checked=\"checked\" CSS初级引入CSS 行间样式 &gt;&lt;div style=\"css定义内容\"&gt; &gt;&lt;/div&gt; 页面级CSS 在头部标签 &lt;head&gt; 下加入 &gt;&lt;style type=\"text/css\"&gt; &lt;!--css定义内容--&gt; &gt;&lt;/style&gt; 外部CSS文件 新加一个文件后缀为.CSS 在头部标签 &lt;head&gt; 下加入 &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"CSS文件位置\"/&gt;\\ CSS选择器 id，在div标签加入id名 &gt;&lt;!--id创建--&gt; &gt;&lt;div id=\"填id名\"&gt;&lt;/div&gt; &gt;&lt;!--下面css定义,引入css页面填写--&gt; &gt;#id名{ \"css定义内容\" } class，在div标签加入class名 &gt;&lt;!--class创建--&gt; &gt;&lt;div class=\"填calss名\"&gt;&lt;/div&gt; &gt;&lt;!--下面css定义,引入css页面填写--&gt; &gt;#id名{ \"css定义内容\" } 标签选择 &gt;&lt;!--下面css定义,引入css页面填写--&gt; &gt;标签名{ \"css定义内容\" } 属性，如[id]，[class]，[id=”123”]… &gt;&lt;!--下面css定义,引入css页面填写--&gt; &gt;[属性]{ \"css定义内容\" } 通配符，对所以标签都生效 &gt;&lt;!--css定义,引入css页面填写--&gt; &gt;*{ \"css定义内容\" } 父子选择器/派生选择器 &gt;&lt;div&gt; &gt;&lt;span&gt;1&lt;/span&gt; &lt;!--对 1 进行css定义--&gt; &gt;&lt;/div&gt; &gt;&lt;!--下面css定义,引入css页面填写--&gt; &gt;div span{ \"css定义内容\" &gt;} 直接子元素选择器 &gt;&lt;div&gt; &gt;&lt;span&gt;1&lt;/span&gt; &lt;!--对 1 进行css定义--&gt; &gt;&lt;span&gt;2&lt;/span&gt; &gt;&lt;/div&gt; &gt;&lt;!--下面css定义,引入css页面填写--&gt; &gt;div &gt; span{ \"css定义内容\" &gt;} 并列选择器 &gt;&lt;div&gt; 1 &lt;/div&gt; &gt;&lt;div calss=\"demo\"&gt; 2 &lt;/div&gt; &lt;!--对 2 进行css定义--&gt; &gt;&lt;p calss=\"demo\"&gt; 3 &lt;/p&gt; &gt;&lt;!--下面css定义,引入css页面填写--&gt; &gt;div.demo{ \"css定义内容\" &gt;} 分组选择器 &gt;&lt;!--对 1,2,3 进行css定义--&gt; &gt;&lt;em&gt; 1 &lt;/em&gt; &gt;&lt;strong&gt; 2 &lt;/strong&gt; &gt;&lt;span&gt; 3 &lt;/span&gt; &gt;&lt;!--下面css定义,引入css页面填写--&gt; &gt;em,strong,span{ \"css定义内容\" &gt;} 伪类选择器 &gt;&lt;!--将鼠标悬浮在改标签时的变化，css定义--&gt; &gt;&lt;a href=\"链接地址\"&gt;链接文本&lt;/a&gt; &gt;&lt;!--下面css定义,引入css页面填写--&gt; &gt;a:hover{ \"css定义内容\" &gt;} CSS选择器的优先级 !import &gt; 行间样式 &gt; id &gt; class =属性 &gt; 标签选择 &gt; 通配符 !import 在CSS定义内容后可加上 优先级是根据各个选择器的权重大小比较的 选择器 权重 !import Infinity (无穷大) 行间样式 1000 id 100 class | 属性 | 伪类 10 标签 | 伪元素 1 通配符 0 注：权重之间是256进制 CSS语法 基本样式 选择器{ 属性名1：属性值1; 属性名2：属性值2; 属性名3：属性值3; } /*例如定义一个div*/ div{ width:100px; height:100px; background:red; } 文字定义 &gt;font-size:16px; /* 调整文字大小 */ &gt;font-weight:bold; /* 调整文字粗细 可选属性，默认是 \"normal\"，\"bold\" 是加粗，可直接写数值: \"100-900\" 之间。*/ &gt;font-style:normal; /* 属性值：\"italic\" 斜体的字体样式, \"oblique\" 倾斜的字体样式*/ &gt;font-family:字体名称; /* 可以修改显示的字体 */ &gt;/*字体颜色定义，三种方法*/ &gt;color:rgb(0,0,0); /* 红，绿，蓝 三个颜色的值 0-255*/ &gt;color:#000000; /* 可以分开00-00-00，代表红，绿，蓝的值，用16进制数表示 */ &gt;color:red; /*直接所以英文颜色名字*/ 段落文字定义 &gt;/* 段落文字水平居中 */ &gt;text-align:center; /* 可以选属性，靠左 \"left\"，靠右：\"right\" */ &gt;line-height:10px; /* 行高，行间距 */ &gt;text-indent:2em; /* 首行缩进两个字符大小；1 em= 1 font-size */ &gt;text-decoration:line-through; /* 删除线 */ &gt;text-decoration:underline; /* 下划线 */ &gt;text-decoration:overline; /* 上划线 */ 边框 borde(边框) /* 边框宽度 | 边框样式 | 边框颜色 */ border:1px dashed green; /* \"dashed\" 虚线；\"solid\" 实线 */ /*可以分开4个边角定义*/ /* 例如左边left,可选 tiop，right，bottom */ border-left:1px dashed green; margin(外边距) padding（填充） margin/padding:1px ，margin/padding:30%； 对应四个上，下，左，右位置大小的值 可拆开， margin/padding-top，依此类推 元素的类型每一个元素都有默认的 display 属性值； 行类元素 特点：内容决定元素所占位置，不可以通过css改变宽高 行内元素标签：span strong a em del CSS默认：display: inline; 凡是带有 inline 的元素，都有文字特征 块类元素 特点：独占一行，可以通过css改变宽高 块内元素标签：div p ul li ol form address CSS默认：disply: block; 行级块元素 特点：内容决定改变大小，可以通过css改变宽高 行级块元素标签：img CSS默认：disply: inline-block; 盒子模型 内容 CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin），边框（border），填充（padding），和实际内容（content）。 盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。 结构图 说明 Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像 宽度和高度的计算 总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距; 总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距 定位absolute 定位 脱离原来位置进行定位 位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;； absolute 定位使元素的位置与文档流无关，因此不占据空间 relative 定位 保留原来的位置进行定位 相对自己原来的位置进行定位 元素虽然偏移某个距离，但仍然占据原来的空间 fixed 定位 元素的位置相对于浏览器窗口是固定位置。 即使窗口是滚动的它也不会移动 CSS定位属性 top bottom left right 分别对应上，下，左，右位置的值，可用数值 与百分比 top:1px ，top:30%；","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://fantasy06.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"基础","permalink":"http://fantasy06.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"webAPI的基本学习","slug":"article-title","date":"2022-08-05T06:34:02.000Z","updated":"2022-08-06T01:28:35.884Z","comments":true,"path":"posts/6ec968d6.html","link":"","permalink":"http://fantasy06.github.io/posts/6ec968d6.html","excerpt":"","text":"webAPI的基本学习 作用：使用JS操作html和浏览器 分类：DOM（文档对象模型）、BOM（浏览器对象模型） DOM的内容 DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API 简单来说：DOM是浏览器提供的一套专门用来 操作网页内容 的功能 作用：开发网页内容特效和实现用户交互 DOM树 内容：将HTML以树状的内容直观显示出来，也称文档树 作用：直观体现出标签与标签的关系 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 文本 &lt;a href=\"\"&gt;链接&lt;/a&gt; &lt;h1 class=\"\" id=\"\"&gt;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; &lt;img src=\"https://picgo-fantasy06.oss-cn-guangzhou.aliyuncs.com/img/0d429a429c4b10f6ba024de35a73da88b39e4b6e76b0f7bd95697db1ceaab0b5.gif\" alt=\"0d429a429c4b10f6ba024de35a73da88b39e4b6e76b0f7bd95697db1ceaab0b5\" style=\"zoom:200%;\" /&gt; ### 获取DOM元素 - CSS选择器 匹配到第一个元素，返回一个HTMLElement对象 ```javascript //语法 document.querySelector('CSS选择器') 匹配多个选择器，返回NodeList对象集合，得到是一个伪数组 document.querySelectorAll('CSS选择器') 其他方法 document.getElementByid('id名') document.getElementByTagName('标签名') document.getElementByClassName('类名') 设置和修改DOM元素 修改标签文本内容 //语法： 元素.innerText='' //只能识别内容，不能解释标签 //可以解析标签 即： 元素.innerHTML='&lt;h3&gt;会对html标签进行解析&lt;/h3&gt;' 设置与修改DOM元素的属性 语法：对象.属性=值，最常见的属性比如： href、title、src 等 //例子 let pic =document.querySelector('img') pic.src='./images/pic2.jpg' 通过style修改CSS属性 let box =document.querySelector('div') box.style.width='300px' box.style.paddingLeft ='300px' //注：有链接-符号的需要转换为小驼峰命名法 //即：padding-left--&gt;paddingLeft 修改标签类名 元素.clssName='新类名' //注：直接使用 className 赋值会覆盖以前的类名 //保留可写 元素.clssName='旧类名 新类名' 通过clssList操作css类名 //增加一个类名 元素.classList.add('类名') //删除一个类 元素.classList.remove('类名') //切换一个类,存在就删除,不存在就增加 元素.classList.toggle('类名') 修改表单属性 作用：表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框 获取：DOM对象.属性名；设置：DOM对象.属性名=新值 表单.value='用户名' 表单.type='password' 表单属性中添加就有效果,移除就没有效果,一律使用布尔值表示 如果为true 代表添加了该属性 如果是false 代表移除了该属性比如： disabled、checked、selected 定时器-setInterval() 间歇函数 开启定时器 setInterval(函数，间隔时间) //时间也毫秒为单位，1秒==1000ms 关闭定时器 let timer =setInterval(函数，间隔时间) clearInterval(timer) 事件 事件是在编程时系统内发生的动作或者发生的事情，比如用户在网页上单击一个按钮 事件监听 让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为 注册事件 语法：元素.addEventListener('事件',要执行的函数) //获取元素 let btn=document.querySelector('button') //事件监听 btn.addEventListener('click',function(){ alert('被点击了') }) 事件监听三要素： 事件源：那个dom元素被事件触发了，要获取dom元素 事件：有什么方式触发，比如鼠标点击click 事件触发时调用的函数 版本 DOM L0 语法：事件源.on事件=function(){} btn.onclick=function(){ alert('点击') } DOM L2 ⭐ 语法：事件源.addEventlistener(事件，事件处理函数) btn.addEventListener('click',function(){ alert('点击') }) 事件类型 高阶函数 高阶函数可以被简单理解为函数的高级应用，JavaScript 中函数可以被当成【值】来对待，基于这个特性实现函数的高级应用 函数表达式let counter=function(x,y){ return x+y } //调用 let result=counter(1,2) 回调函数 如果将函数A当作参数传递给函数B时，我们称函数A为回调函数 回调函数本质还是函数，只不过把它当成参数使用 使用场景 定时器setInterval() 间歇函数 function fn(){ alert('我是回调函数') } //fn传递了给setInterval ，fn就是回调函数 setInterval(fn,1000) 事件监听 btn.addEventListener('click',function(){ alert('我是回调函数') }) 环境变量 环境对象指的是函数内部特殊的变量 this ，它代表着当前函数运行时所处的环境作用：弄清楚this的指向，可以让我们代码更简洁 函数的调用方式不同，this 指代的对象也不同 【谁调用， this 就是谁】 是判断 this 指向的粗略规则 直接调用函数，其实相当于是 window.函数，所以 this 指代 window 编程思想排他思想当前元素为A状态,其他元素为B状态 使用： 干掉所有人使用for循环 复活他自己通过this或者下标找到自己或者对应的元素 //给点击的li加上pink类 &lt;li class='pink'&gt;第一个&lt;/li&gt; &lt;li&gt;第二个&lt;/li&gt; &lt;li&gt;第三个&lt;/li&gt; let lis = document.querySelectorAll('li') for (let i = 0; i &lt; lis.length; i++) { lis[i].addEventListener('click', function () { // 干掉所有人 for (let j = 0; j &lt; btns.length; j++) { btns[j].classList.remove('pink') } //复活自己 this.classList.add('pink') //==================分割线=========================== //高级做法 // 我只需要找出那个唯一的 pink类，删除 document.querySelector('.pink').classList.remove('pink') // 我的 this.classList.add('pink') }) } DOM结点 DOM树里每一个内容都称之为节点 结点类型 元素结点 ⭐ 所有的标签：比如 body div，html是根节点 属性结点 所有的属性，比如 herf 文本结点 所有的文本 结点的查找结点的关系：父节点，子节点，兄弟节点 父节点的查找 使用parentNode属性，返回最近一级的父节点，找不到返回null 语法：子元素.parentNode 子结点的查找 childNodes - 获得所有的子节点，包括文本节点（空格、换行）、注释节点等 chilrden ⭐ -获得所有元素节点，返回的还是一个伪数组 兄弟结点的查找 nextElementSibling 查找下一个兄弟结点 previousElementSibling 查找上一个兄弟节点 结点的增加 一般情况下，我们新增节点，按照如下操作 1创建一个新的节点 2把创建的新的节点放入到指定的元素内部 创建结点 documnet.createElement('标签名') 追加结点 //插入父元素的最后 父元素.appendChild(要插入的元素) //插到某个子元素的前面 父元素.insertBefore(要插入的元素,在哪个元素的前面) 结点的克隆 cloneNode会克隆出一个跟原标签一样的元素，括号内传入布尔值若为true，则代表克隆时会包含后代节点一起克隆若为false，则代表克隆时不包含后代节点默认为false 语法：元素.cloneNode(布尔值) 结点的删除 删除节点和隐藏节点（display:none） 有区别的： 隐藏节点还是存在的，但是删除，则从html中删除节点在 JavaScript 原生DOM操作中，要删除元素必须通过父元素删除 语法：父元素.removeChild(要删除的元素) 重绘和回流浏览器进行界面渲染 解析（Parser）HTML，生成DOM树(DOM Tree) 同时解析（Parser） CSS，生成样式规则 (Style Rules) 根据DOM树和样式规则，生成渲染树(Render Tree) 进行布局 Layout(回流/重排):根据生成的渲染树，得到节点的几何信息（位置，大小） 进行绘制 Painting(重绘): 根据计算和获取的信息进行整个页面的绘制 Display: 展示在页面上 回流(重排) 当 Render Tree 中部分或者全部元素的尺寸、结构、布局等发生改变时，浏览器就会重新渲染部分或全部文档的过程称为回流，简单理解影响到布局了，就会有回流 会导致回流的操作 页面的首次刷新 浏览器的窗口大小发生改变 元素的大小或位置发生改变 改变字体的大小 内容的变化（如：input框的输入，图片的大小） 激活css伪类 （如：:hover） 脚本操作DOM（添加或者删除可见的DOM元素） 重绘 由于节点(元素)的样式的改变并不影响它在文档流中的位置和文档布局时(比如：color、background-color、outline等), 称为重绘 注：重绘不一定引起回流，而回流一定会引起重绘。 练习： let s = document.body.stlye s.padding = '2px' //重排 + 重绘 s.border = '1px solid red' // 重排 + 重绘 s.color = 'red'//重绘 s.backgroundColor = '#666' //重绘 s.fontSize= \"14px\" // 重排 + 重绘 事件高级事件对象 内容：事件对象是个对象，这个对象里有事件触发时的相关信息 例如：鼠标点击事件中，事件对象就存了鼠标点在哪个位置等信息 获取方法： 在事件绑定的回调函数的第一个参数就是事件对象 一般命名为 even 、ev 、e 元素.addEventListener('click',function(e){ //e就是事件对象 }) 常用事件对象的属性 type ：获取当前事件类型 clientX / clientY ：获得光标相对于浏览器可见窗口左上角的位置 offsetX / offsetY : 获取光标相对于当前DOM元素左上角的位置 key ：用户按下的键盘的值，现在不提倡用 keyCode 事件流 事件流指的是事件完整执行过程的流动路径，两个阶段：事件捕获和事件冒泡 说明：假设页面里有个div，当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段 简单来说：捕获阶段是 从父到子 冒泡阶段是从子到父 事件冒泡 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发 简单理解：当一个元素触发事件后，会依次向上调用所有父级元素的同名事件 事件冒泡是默认存在的 事件捕获 从DOM的根元素开始去执行对应的事件 (从外到里) 说明： addEventListener第三个参数传入true代表是捕获阶段触发（很少使用） 若传入false代表冒泡阶段触发，默认就是false 若是用 L0 事件监听，则只有冒泡阶段，没有捕获 阻止事件流动 因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素 若想把事件就限制在当前元素内，就需要阻止事件流动 阻止事件流动需要拿到事件对象 语法：事件对象.stopProagation() 此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效 鼠标经过事件： mouseover 和 mouseout 会有冒泡效果 mouseenter 和 mouseleave 没有冒泡效果(推荐) 两种注册事件的区别： 传统on注册（L0） 同一个对象,后面注册的事件会覆盖前面注册(同一个事件) 直接使用null覆盖偶就可以实现事件的解绑 都是冒泡阶段执行的 事件监听注册（L2） 语法: addEventListener(事件类型, 事件处理函数, 是否使用捕获) 后面注册的事件不会覆盖前面注册的事件(同一个事件) 可以通过第三个参数去确定是在冒泡或者捕获阶段执行 必须使用removeEventListener(事件类型, 事件处理函数, 获取捕获或者冒泡阶段) 匿名函数无法被解绑 事件委托 事件委托其实是利用事件冒泡的特点， 给父元素添加事件，子元素可以触发 优点：给父级元素加事件（可以提高性能） 实现：事件对象.target 可以获得真正触发事件的元素 滚动事件 作用：很多网页需要检测用户把页面滚动到某个区域后做一些处理， 比如固定导航栏，比如返回顶部 事件名 scroll //可以给window或document添加滚动事件来监听整个页面 window.addEventListener('scroll',function(){ //要执行的操作 }) 加载事件load 事件 加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件 为什么要学？ 有些时候需要等页面资源全部处理完了做一些事情 老代码喜欢把 script 写在 head 中，这时候直接找 dom 元素找不到 事件名：load 监听页面所有资源加载完毕： 给 window 添加 load 事件 window.addEventListener('load',function(){ //要执行的操作 }) 注意：不光可以监听整个页面资源加载完毕，也可以针对某个资源绑定load事件 DOMContentLoaded 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表全加载 事件名：DOMContentLoaded 监听页面DOM加载完毕： 给 document 添加 DOMContentLoaded 事件 document.addEventListener('DOMContentLoaded',function(){ //要执行的操作 }) 元素大小和位置三大家族 scroll家族 offest家族 client家族 scroll家族 作用：检测页面滚动的距离 获取宽高 获取元素的内容总宽高（不包含滚动条）返回值不带单位 scrollWidth 和 scrollHeight 获取位置（属性可修改） 获取元素内容往左、往上滚出去看不到的距离 scrollLeft和scrollTop div.addEventListener('scroll',function(){ console.log(this.scrollTop) }) 注：document.documentElement ：HTML 文档返回对象为HTML元素 offest家族 获取宽高 获取元素的自身宽高、包含元素自身设置的宽高、padding、border offsetWidth 和 offsetHeight 获取位置（只读，不可修改） 获取元素距离自己定位父级元素的左、上距离 client家族 获取宽高 获取元素的可见部分宽高（不包含边框，滚动条等） clientWidth和clientHeight 位置 clientLeft和clientTop 注意是只读属性 resize事件 改变窗口大小的时候触发的事件，类似css3媒体查询 Window对象BOM 浏览器对象模型 window 是浏览器内置的全局对象，我们所学习的 web apis 的知识内容都是基于 window 对象实现的 window 对象下包含了 navigator 、location 、doucment history 、 srceen 5个属性，即 BOM document 是实现 DOM 的基础，它其实是依附于 window 的属性 依附于 window 对象的所有属性和方法，使用时可以省略 window 定时器-延时函数 JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout 语法：setTimeout(回调函数,等待的毫秒数) setTimeout 仅执行一次，简单来说把一段代码延迟执行 清除延时函数语法 ：clearTimeout(延时函数的id) 结合函数的递归可以实现 setInterval 间歇函数 一样的功能 function myInterval(){ let d=new date(); //写入页面 clock.innertext=d.toLocaleString(); //调用自己 一直循环，倒计时效果 setTimeout(myInterval,1000); } myInterval(); JS执行机制 （面试）⭐ JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。。这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 同步和异步 为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步。 同步 前一个任务执行完才执行后一个任务，程序执行的顺序和代码排列顺序一样 异步 执行一个某个任务费很长时间，在做这个任务的同时，还可以去处理其他的任务 比如：做饭时，等水开的期间可以去其他事，比如切菜 他们的本质区别： 这条流水线上各个流程的执行顺序不同。 同步任务 同步任务都在主线程上执行，形成一个执行栈。 异步任务 JS 的异步是通过回调函数实现的 一般来说异步任务有以下三种类型 1、普通事件，如 click、resize 等2、资源加载，如 load、error 等3、定时器，包括 setInterval、setTimeout 等 异步任务相关会添加的任务队列（消息队列）中 执行机制 先执行执行栈里面的同步任务 异步任务放在消息队列中 一旦执行栈的执行任务完毕，系统会依次读取消息队列里的异步任务，被读取的异步任务结束等待状态，进入执行栈，开始执行 事件循环（event loop） 由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop） location对象 location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分 常用属性和方法： href 属性获取完整的 URL 地址，对其赋值时用于地址的跳转 search 属性获取地址中携带的参数，符号 ？后面部分 hash 属性获取地址中的啥希值，符号 # 后面部分 reload 方法用来刷新当前页面，传入参数 true 时表示强制刷新 语法：loaction.属性 loactiom.方法() navigator对象 navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息 常用属性和方法： 通过 userAgent 检测浏览器的版本及平台 // 检测 userAgent（浏览器信息） !(function () { const userAgent = navigator.userAgent // 验证是否为Android或iPhone const android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/) const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/) // 如果是Android或iPhone，则跳转至移动站点 if (android || iphone) { location.href = 'http://m.itcast.cn' } })() histroy对象 history 的数据类型是对象，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等 history对象和方法 作用 back() 可以后退功能 forward() 可以前进功能 go(参数) 前进，后退功能，参数决定，-1后退，1前进 本地存储 随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案 数据存储在用户浏览器中 设置、读取方便、甚至页面刷新不丢失数据 容量较大，sessionStorage和localStorage约 5M 左右 localStorage 生命周期永久生效，除非手动删除 否则关闭页面也会存在 可以多窗口（页面）共享（同一浏览器可以共享） 以键值对的形式存储使用 语法 存储数据：localStorage.setItem(key, value) 获取数据：localStorage.getItem(key) 删除数据：localStorage.removeItem(key) 存储复杂数据类型存储： 本地只能存储字符串,无法存储复杂数据类型.需要将复杂数据类型转换成JSON字符串,在存储到本地 JSON.stringify(复杂数据类型) ： 将复杂数据转换成JSON字符串 存储 本地存储中 JSON.parse(JSON字符串)： 将JSON字符串转换成对象 取出 时候使用 sessionStorage（了解） 1. 生命周期为关闭浏览器窗口 2. 在同一个窗口(页面)下数据可以共享 3. 以键值对的形式存储使用 4. 用法跟localStorage 基本相同 自定义属性固有属性： 标签天生自带的属性 比如class id title等, 可以直接使用点语法操作 自定义属性: 由程序员自己添加的属性,在DOM对象中找不到, 无法使用点语法操作,必须使用专门的API 获取自定义属性 ：getAttribute('属性名') 设置自定义属性：setAttribute('属性名', '属性值') 删除自定义属性：removeAttribute('属性名') data-自定义属性： 传统的自定义属性没有专门的定义规则,开发者随意定值,不够规范,所以在html5中推出来了专门的data-自定义属性 在标签上一律以data-开头 在DOM对象上一律以dataset对象方式获取 正则表达式 正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象 正则表达式在 JavaScript中的使用场景： 例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配) 比如用户名: /^[a-z0-9_-]{3,16}$/ 过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。 语法使用： 定义规则 查找 语法：let 变量名=/表达式/ / / 是正则表达式字面量，比如 ：let reg=/abc/ 判断： test() 方法 用来查看正则表达式与指定的字符串是否匹配 ，返回 false 或 true let str = 'hello ,world' let reg = /hello/ console.log(reg.test(str)) //true exec() 方法 在一个指定字符串中执行一个搜索匹配 如果匹配成功，exec() 方法返回一个数组，否则返回null 元字符 是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。 比如，规定用户只能输入英文26个英文字母，普通字符的话 abcdefghijklm….. 但是换成元字符写法： [a-z] 方便记忆和学习，众多的元字符进行了分类： 边界符（表示位置，开头和结尾，必须用什么开头，用什么结尾） 正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符 注意：如果 ^ 和 $在一起，表示必须是精确匹配。 量词 （表示重复次数） 量词用来 设定某个模式出现的次数 注意： 逗号左右两侧千万不要出现空格 字符类 （比如 \\d 表示 0~9） - 连字符 使用连字符 - 表示一个范围 比如： [a-z] 表示 a 到 z 26个英文字母都可以 [a-zA-Z] 表示大小写都可以 [0-9] 表示 0~9 的数字都可以 [ ] 里面加上 ^ 取反符号比如：[^a-z] 匹配除了小写字母以外的字符 注意要写到中括号里面 . 匹配除换行符之外的任何单个字符 预定义：指的是某些常见模式的简写方式 修饰符 修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等 语法： /表达式/修饰符 i 是单词 ignore 的缩写，正则匹配时字母不区分大小写g 是单词 global 的缩写，匹配所有满足正则表达式的结果 console.log(/a/i.test('a')) //true console.log(/a/i.test('A')) //true 替换 replace 替换：（过滤敏感词） 字符串.replace(/正则表达式/，'替换的文本') ​","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://fantasy06.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://fantasy06.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://fantasy06.github.io/tags/Github/"},{"name":"博客","slug":"博客","permalink":"http://fantasy06.github.io/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"Fantasy"},{"title":"javascript 进阶","slug":"Javscipt ","date":"2020-07-26T08:42:00.000Z","updated":"2022-08-06T05:33:05.873Z","comments":true,"path":"posts/d15997ef.html","link":"","permalink":"http://fantasy06.github.io/posts/d15997ef.html","excerpt":"","text":"作用域 作用域规定了变量能够被访问的范围，离开这个范围变量就不能被访问 作用域分为： 局部作用域局部作用域分为函数作用域和块作用域。 函数作用域： 在函数内部声明的变量只能在函数内部被访问，外部无法访问 总结： 函数内部声明的变量，在函数外部无法被访问 函数的参数也是函数内部的局部的变量 不同函数内部声明的变量无法相互访问 函数执行完毕后，函数的变量实际被清空了 块作用域： 在JavaScript中使用 {} 包裹的代码块内部声明的变量外部将有可能无法被访问 for(let i=0;i&lt;10;i++){ // i 只能的该代码块中被访问 console.log(i) } // 超出了t的作用域 ，报错 console.log(i) 总结： let 声明的变量，const 声明的常量，都会产生块级作用域 var 声明的变量不会产生块级作用域 不同代码块之间的变量无法相互访问 推荐使用 let 和 const 全局作用域 在 &lt;script&gt; 标签 和 .js 文件的最外层就是全局作用域，在此声明的变量在函数内部也可以访问，全局作用域下声明的变量，任何其他作用域都可以被访问 //全局作用域，下声明变量num const num=10 function fn(){ //函数内部可以使用 console.log(num) } 注意： 为 window 对象动态添加的属性默认也是全局的，不推荐 函数未使用任何关键字声明的变量为全局变量，不推荐 尽可能少的声明全局变量，防止全局变量被污染 作用域链 作用域链本质是底层的变量查找机制 函数在被执行时，会优先找当前函数作用域中查找变量 如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域 //全局作用域 let a = 1 let b = 2 //局部作用域 function f() { let a = 1 function g() { a = 2 console.log(a) // 2 } g() } f() 总结： 嵌套更新的作用域串联起来形成了作用域链 相同作用域链中按着从小到大的规则查找变量 子作用域能够访问父级作用域，父级作用域无法访问子级作用域 JS 的垃圾回收机制 垃圾回收机制 (Garbage Collection) 简称 GC JS 中的内存的分配和回收都是自动完成的，，内存在不使用的时候会被垃圾回收器自动回收。 但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况 不再用到的内存，没有及时释放，就叫做内存泄漏 内存的生命周期 ： 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用：即读写内存，也就是使用变量、函数等 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 全局变量一般不会回收(关闭页面回收)； 一般情况下局部变量的值, 不用了, 会被自动回收掉 垃圾回收算法说明 所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉下面介绍两种常见的浏览器垃圾回收算法: 引用计数法 和 标记清除法 引用计数IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。算法： 跟踪记录每个值被引用的次数。 如果这个值的被引用了一次，那么就记录次数1 多次引用会累加。 如果减少一个引用就减1。 如果引用次数是0 ，则释放内存。 引用计数算法是个简单有效的算法。但它却存在一个致命的问题：嵌套引用。如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。 标记清除法现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。核心： 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进 行回收。 闭包 概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域简单理解：闭包 = 内层函数 + 外层函数的变量 function outer() { const a = 1 function f(){ console.log(a) } f() } outer // 内层函数调用外层函数的变量，就是闭包 作用： 封闭数据，提供操作，外部也可以访问函数内部的变量 基本格式： 闭包应用：实现数据的私有比如，我们要做个统计函数调用次数，函数调用一次，就++ 普通写法 let count = 1 function fn() { count++ console.log(count) } fn() //2 fn() //3 这个count 是个全局变量，很容易被修改 闭包写法： function fn() { let count = 1 return function fun() { count++ console.log(count) } } const result =fn() result() //2 result() //3 实现了数据私有，无法直接修改count 闭包可能引起的问题：内存泄漏 变量提升 变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问（仅存在于var声明变量） console.log(str) //不报错 控制台显示undefined var str = 'hello' 注意： 变量在未声明即被访问时会报语法错误 变量在var声明之前即被访问，变量的值为 undefined let / const 声明的变量不存在变量提升 变量提升出现在相同作用域当中 实际开发中推荐先声明再访问变量 函数进阶函数提升函数提升与变量提升比较类似，是指函数在声明之前即可被调用。 函数参数 动态参数 arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参 //求和函数 不管用户传入几个实参，都要把和求出来 function sum() { let s = 0 for(let i = 0;i &lt; arguments.length;i++){ s += arguments[i] } return s } sum(5,10) //15 sum(1,2,3) //6 剩余参数 剩余参数允许我们将一个不定数量的参数表示为一个数组 ... 是语法符号，置于最末函数形参之前，用于获取多余的实参 借助 ... 获取的剩余实参，是个真数组 function sum(...other) { let s = 0 for(let i = 0;i &lt; other.length;i++){ s += other[i] } return s } sum(5,10) //15 sum(1,2,3) //6 区别： … 是语法符号，置于最末函数形参之前，用于获取多余的实参 借助 … 获取的剩余实参，是个真数组 展开运算符：... 展开运算符 (…)， 将一个数组进行展开，不会修改原数组 const arr=[1,2,3,4,5] console.log(...arr) //1 2 3 4 5 典型运用场景： 求数组最大值(最小值)、合并数组等 const arr=[1,2,3,6,4,5] const arr2=[7,8,9] //最大值 const max=Math.max(...arr) //合拼 const arr3=[...arr,...arr2] 展开运算符 or 剩余参数剩余参数：函数参数使用，得到真数组展开运算符：数组中使用，数组展开 箭头函数语法： //普通函数 const fn = function (){ ... } fn() //1.箭头 无参数 const fn = () =&gt;{ ... } //2.只有一个参数 const fn = x=&gt; { return x } //3.函数体只有一行代码，可以写一行上，无需写 return 直接返回值 const fn = (x,y) =&gt; x + y //返回 x + y 的值 //加括号的函数体返回对象字面量表达式 const fn1 = uname =&gt;({uname : uname}) console.log(fn1('叶湘伦')) //控制台：{uname:\"叶湘伦\"} 箭头函数属于表达式函数，因此不存在函数提升 箭头函数只有一个参数时可以省略圆括号 () 箭头函数函数体只有一行代码时可以省略花括号 {}，并自动做为返回值被返回 加括号的函数体返回对象字面量表达式 箭头函数参数： 普通函数有 arguments 动态参数 箭头函数没有 arguments 动态参数，但是有 剩余参数 ..args 箭头函数 this：在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值箭头函数不会创建自己的 this ,它只会从自己的作用域链的上一层沿用 this 。 在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此，DOM事件回调函数为了简便，还是不太推荐使用箭头函数 数组解构 数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法。 // 普通的数组 let arr = [1, 2, 3]; // 批量声明变量 a b c // 同时将数组单元值 1 2 3 依次赋值给变量 a b c let [a, b, c] = arr; console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 基本语法： 赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量 变量的顺序对应数组单元值的位置依次进行赋值操作 变量的数量大于单元值数量时，多余的变量将被赋值为 undefined 变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位 允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效 对象解构 // 普通对象 const user = { name: '小明', age: 18 }; // 批量声明变量 name age // 同时将数组单元值 小明 18 依次赋值给变量 name age const {name, age} = user console.log(name) // 小明 console.log(age) // 18 总结： 赋值运算符 = 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量 对象属性的值将被赋值给与属性名相同的变量 对象中找不到与变量名一致的属性时变量值为 undefined 允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效 遍历数组 forEach 方法 forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数 遍历数组.forEach(function (当前数组元素,索引号){ //函数体 }) 注意： forEach 主要是遍历数组 参数当前数组元素是必须要写的， 索引号可选。 筛选数组 filter 方法 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素 主要使用场景： 筛选数组符合条件的元素，并返回筛选之后元素的新数组 遍历数组.filter(function (当前数组元素,索引号){ return 筛选条件 }) //筛选数组大于30的元素 const arr=[10,26,62,61,56,12,36] const re = arr.filter(function(item){ return item &gt; 30 }) console.log(re) //[62,61,56,36] 返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组参数：currentValue 必须写， index 可选因为返回新数组，所以不会影响原数组 对象创建方法 利用字面量创建 const obj = { name:'叶湘伦', age:18 } 利用 new Object 创建对象 const obj = new Object({ name:'叶湘伦', age:18 }) 利用构造函数创建 // 构造函数 function Obj(name,age){ this.name = name this.age = age } //创建一个对象 const Stu = new Obj('叶湘伦'，18) 注意： 语法：大写字母开头的函数 约定：它们的命名以大写字母开头。只能由 “new” 操作符来执行。 说明： 使用 new 关键字调用函数的行为被称为实例化 实例化构造函数时没有参数可以省略（） 构造函数内部不用写 return ，返回值即为新建的对象 new Object（） new Date（） 也是实例化构造函数 实列化执行过程： 创建一个新空对象 构造函数 this 指向新对象 执行构造函数代码，修改 this ，添加新的属性 返回新的对象 实例对象 通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员 // 构造函数 function Obj(name,age){ //构造函数内部的 this 就是实例对象 //实例对象中动态添加属性 this.name = name this.age = age //实例对象中动态添加方法 this.sayHi = function () { console.log('hi') } } //实例化 ，Stu 是实列对象 // Stu 实际就是构造函数内部的 this const Stu = new Obj('叶湘伦'，18) //访问实例属性 console.log(Stu.name) //调用实列方法 Stu.sayHi() 说明： 实例对象的属性和方法即为实例成员 为构造函数传入参数，动态创建结构相同但值不同的对象 构造函数创建的实例对象彼此独立互不影响。 静态成员： 在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。 // 构造函数 function Obj(name,age){ //实例成员 } //静态属性 Obj.eyes = 2 Obj.arms = 2 //静态方法 Obj.walk = funtion () { console.log('走路中') //this 指向 person console.log(this.eyes) } 总结： 静态成员指的是添加到构造函数本身的属性和方法 一般公共特征的属性或方法静态成员设置为静态成员 静态成员方法中的 this 指向构造函数本身 内置构造函数 在 JavaScript 中最主要的数据类型有 6 种，分别是字符串、数值、布尔、undefined、null 和 对象，常见的对象类型数据包括数组和普通对象。其中字符串、数值、布尔、undefined、null 也被称为简单类型或基础类型，对象也被称为引用类型。 在 JavaScript 内置了一些构造函数，绝大部的数据处理都是基于这些构造函数实现的，JavaScript 基础阶段学习的 Date 就是内置的构造函数。 引用类型： Object : 三个常用静态方法（静态方法就是只有构造函数Object可以调用的） Object.keys 静态方法获取对象中所有属性（键） Object.values 静态方法获取对象中所有属性值 Object.assign 静态方法常用于对象拷贝 //Object.keys const obj = {name:'叶湘伦',age:18} const arr = Object.key(obj) console.log(arr) // ['name','age'] 返回是一个数组 //Object.values const arr2 =Object.values(obj) console.log(arr2) // ['叶湘伦',18] 返回是一个数组 //Object.assign const obj2 = {} Object.assign(obj2,obj) console.log(obj2) // {name:'叶湘伦',age:18} //使用：经常使用的场景给对象添加属性 Object.assign(obj,{sex:'男'}) console.log(arr) // {name:'叶湘伦',age:18,sex:'男'} Array : 数组常见实例方法-核心方法 方法 作用 说明 forEach 遍历数组 不返回值，用于不改变值，经常用于查找打印输出值 filter 过滤数组 筛选数组元素，并生成新数组 map 迭代数组 返回新数组，新数组里面的元素是处理之后的值，经常用于处理数据 reduce 累积器 返回函数累计处理的结果，经常用于求和等 总结： 推荐使用字面量方式声明数组，而不是 Array 构造函数 实例方法 forEach 用于遍历数组，替代 for 循环 (重点) 实例方法 filter 过滤数组单元值，生成新数组(重点) 实例方法 map 迭代原数组，生成新数组(重点) 实例方法 join 数组元素拼接为字符串，返回字符串(重点) 实例方法 find 查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点) 实例方法every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回 true，否则返回 false(重点) 实例方法some 检测数组中的元素是否满足指定条件 如果数组中有元素满足条件返回 true，否则返回 false 实例方法 concat 合并两个数组，返回生成新数组 实例方法 sort 对原数组单元值排序 实例方法 splice 删除或替换原数组单元 实例方法 reverse 反转数组 实例方法 findIndex 查找元素的索引值 String： 总结： 实例属性 length 用来获取字符串的度长(重点) 实例方法 split('分隔符') 用来将字符串拆分成数组(重点) 实例方法 substring（需要截取的第一个字符的索引[,结束的索引号]） 用于字符串截取(重点) 实例方法 startsWith(检测字符串[, 检测位置索引号]) 检测是否以某字符开头(重点) 实例方法 includes(搜索的字符串[, 检测位置索引号]) 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点) 实例方法 toUpperCase 用于将字母转换成大写 实例方法 toLowerCase 用于将就转换成小写 实例方法 indexOf 检测是否包含某字符 实例方法 endsWith 检测是否以某字符结尾 实例方法 replace 用于替换字符串，支持正则匹配 实例方法 match 用于查找字符串，支持正则匹配 注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。 原型 JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象 作用： 共享方法 可以把那些不变的方法，直接定义在 prototype 对象上 constructor 属性： 指向该原型对象的构造函数 对象原型：对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在 总结： prototype是什么？哪里来的？ 原型（原型对象） 构造函数都自动有原型 constructor属性在哪里？作用干啥的？ prototype原型和对象原型__proto__里面都有 都指向创建实例对象/原型的构造函数 __proto__属性在哪里？指向谁？ 在实例对象里面 指向原型 prototype 原型继承 继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。 封装-抽取公共部分 把男人和女人公共的部分抽取出来放到人类里面 继承-让男人和女人都能继承人类的一些属性和方法 把男人女人公共的属性和方法抽取出来 People 然后赋值给Man的原型对象，可以共享这些属性和方法 注意让constructor指回Man这个构造函数 //人类 const People = { head:1, eyes:2, leys:2, say:function () {} } //男人 function Man(){ } //公共属性和方法给原型 Man.prototype = People //如果我们给男人添加了一个吸烟的方法，发现女人自动也添加这个方法 //男人和女人都同时使用了同一个对象，根据引用类型的特点，他们指向同一个对象，修改一个就会都影响 Man.prototype.smoking = function () {} //女人 function Woamn() { //独有方法 this.body =function () {} } // 继承写法完善 ,解决上面问题 //男人和女人不要使用同一个对象，但是不同对象里面包含相同的属性和方法 //答案：构造函数 //new 每次都会创建一个新的对象 function People() = { head:1, eyes:2, leys:2, say:function () {} } //男人 function Man(){ } //公共属性和方法 Man.prototype =new People() 原型链： 基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为原型链 原型链-查找规则： 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象） 如果还没有就查找原型对象的原型（Object 的原型对象） 依此类推一直找到 Object 为止（null） __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线 深浅拷贝浅拷贝拷贝的是地址常见方法： 拷贝对象：Object.assgin() 展开运算符 {...obj} 拷贝对象 拷贝数组：Array.prototype.concat() 或者 [...arr] 总结： 直接赋值和浅拷贝有什么区别？ 直接赋值的方法，只要是对象，都会相互影响，因为是直接拷贝对象栈里面的地址 浅拷贝如果是一层对象，不相互影响，如果出现多层对象拷贝还会相互影响 浅拷贝怎么理解？ 拷贝对象之后，里面的属性值是简单数据类型直接拷贝值 如果属性值是引用数据类型则拷贝的是地址 深拷贝拷贝的是对象，不是地址 常见方法： 通过递归实现深拷贝 lodash/cloneDeep 通过JSON.stringify()实现 异常处理throw 抛异常总结： throw 抛出异常信息，程序也会终止执行 throw 后面跟的是错误提示信息 Error 对象配合 throw 使用，能够设置更详细的错误信息 try/catch总结： try...catch 用于捕获错误信息 将预估可能发生错误的代码写在 try 代码段中 如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息 finally 不管是否有错误，都会执行 debugger ：类似浏览器调试打断点 处理thisthis指向-普通函数 普通函数的调用方式决定了 this 的值，即【谁调用 this 的值指向谁】 普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined this指向-箭头函数箭头函数中的 this 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 this ！ 箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的 箭头函数中的this引用的就是最近作用域中的this 向外层作用域中，一层一层查找this，直到有this的定义 改变thiscall() 方法调用函数，同时指定被调用函数中 this 的值 fn.call(thisArg,arg1,arg2,...) 说明： thisArg：在 fn 函数运行时指定的 this 值 arg1，arg2：传递的其他参数 返回值就是函数的返回值，因为它就是调用函数 apply() 调用函数，同时指定被调用函数中 this 的值 fn.apply(thisArg,[argArray]) 说明： thisArg：在fn函数运行时指定的 this 值 argsArray：传递的值，必须包含在数组里面 返回值就是函数的返回值，因为它就是调用函数 因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值 bind() 不会调用函数。但是能改变函数内部this 指向 fn.bind(thisArg,arg1,arg2,...) 说明： thisArg：在 fn 函数运行时指定的 this 值 arg1，arg2：传递的其他参数 返回由指定的 this 值和初始化参数改造的 原函数拷贝 （新函数） 因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind，比如改变定时器内部的 this 指向. 总结： 区别 call 和 apply 会调用函数, 并且改变函数内部 this 指向 call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2.. 形式 apply 必须数组形式[arg] bind 不会调用函数, 可以改变函数内部 this 指向 主要应用场景 call 调用函数并且可以传递参数 apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值 bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向. 节流和防抖 节流： 就是指连续触发事件但是在 n 秒中只执行一次函数，比如可以利用节流实现 1s之内 只能触发一次鼠标移动事件 防抖： 指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间 使用场景 节流： 鼠标移动，页面尺寸发生变化，滚动条滚动等开销比较大的情况下 防抖： 搜索框输入，设定每次输入完毕n秒后发送请求，如果期间还有输入，则从新计算时间","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://fantasy06.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"基础","permalink":"http://fantasy06.github.io/tags/%E5%9F%BA%E7%A1%80/"}],"author":"Fantasy"},{"title":"Hexo之渲染绕过","slug":"Hexo-xr","date":"2020-04-27T16:00:00.000Z","updated":"2022-08-06T05:33:43.180Z","comments":true,"path":"posts/17fd92ae.html","link":"","permalink":"http://fantasy06.github.io/posts/17fd92ae.html","excerpt":"","text":"0x001 Hexo 渲染 在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README.md时，却不希望被Hexo渲染。因此对某个文件或者目录进行排除渲染是非常必要的。 0x002 方法一：font matterHexo新建网站页面，然后将你的代码直接写入 index.md 中 在 Front matter 中添加 layout: false，此方法适用于单一的纯HTMLCSS 页面。 --- title: tools date: 2020-04-28 00:00:00 type: \"tools\" layout: false --- 0x003 方法二：skip render在博客根目录下的 _config.yml，找到 skip_render，大概在32行左右，写入你想要的跳过渲染的路径，注意缩进和空格。 # 指定目录跳过hexo渲染 skip_render: - 'tools/*' - 'tools/**' 注释：tools/* 表示在目录 source/fireworks 下的文件全部跳过渲染，tools/** 表示在博客根目录 source/tools/ 文件夹下的文件全部跳过渲染（例如页面的 js、css 在另一个文件夹中）。 0x004 案例：webstack 导航webstack是一个纯静态的网址导航网站，内容均由viggo收集并整理。项目基于bootstrap前端框架开发。 Github：https://github.com/WebStackPage/WebStackPage.github.io 在博客根目录 source/下新建tools，然后新建index.html,将webstack网页源码全选复制粘贴到里面。 本站的webstack源码：view-source:http://luckyzmj.cn/tools/ 注意：将源码里的部分信息以及跳转链接按照你真实个人博客的环境进行修改。 然后打开博客根目录下配置文件_config.yml，找到skip_render，做如下修改： skip_render: - 'tools/*' - 'tools/**' 最后执行hexo clean和hexo s -g 本地预览，检查无误后hexo g -d部署到服务器上即可。 参考文章 https://xiabor.com/2020/04/21/hexo3/#%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87hexo%E7%9A%84%E6%B8%B2%E6%9F%93","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://fantasy06.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://fantasy06.github.io/tags/Hexo/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"http://fantasy06.github.io/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"}],"author":"Luckey"},{"title":"文字背景粒子特效","slug":"jQuery+CSS3","date":"2020-03-26T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"posts/4b3510a4.html","link":"","permalink":"http://fantasy06.github.io/posts/4b3510a4.html","excerpt":"","text":"前言一款jQuery+CSS3的文字背景粒子动画特效，一共6种粒子效果，每种文字背景的粒子效果都不同，有漂浮的有坠落的等等。 0x001 特效演示 This is fires This is lines This is hearts This is bubbles This is confetti This is sunbeams .particletext { } .fire > .particle { position: absolute; background-color: rgba(255, 193, 7, 0.5); border-radius: 40px; border-top-right-radius: 0px; -webkit-animation: fires 0.8s linear infinite; animation: fires 0.8s linear infinite; -webkit-transform: rotate(-45deg); transform: rotate(-45deg); opacity: 0; } /*css keyframes 动画*/ @-webkit-keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } @keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } function fire() { $.each($(\".particletext.fire\"), function(){ var firecount = ($(this).width()/50)*20; for(var i = 0; i .particle { position: absolute; background-color: rgba(244, 67, 54, 0.5); -webkit-animation: lines 3s linear infinite; animation: lines 3s linear infinite; } @-webkit-keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } @keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } function lines() { $.each($(\".particletext.lines\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: #cc2a5d; -webkit-animation: hearts 3s ease-in infinite; animation: hearts 3s ease-in infinite; } .hearts > .particle:before,.hearts > .particle:after { position: absolute; content: ''; border-radius: 100px; top: 0px; left: 0px; width: 100%; height: 100%; background-color: #cc2a5d; } .hearts > .particle:before { -webkit-transform: translateX(-50%); transform: translateX(-50%); } .hearts > .particle:after { -webkit-transform: translateY(-50%); transform: translateY(-50%); } @-webkit-keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } @keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } function hearts() { $.each($(\".particletext.hearts\"), function(){ var heartcount = ($(this).width()/50)*5; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: rgba(33, 150, 243, 0.5); -webkit-animation: bubbles 3s ease-in infinite; animation: bubbles 3s ease-in infinite; border-radius: 100%; } @-webkit-keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } @keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } function bubbles() { $.each($(\".particletext.bubbles\"), function(){ var bubblecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; -webkit-animation: confetti 3s ease-in infinite; animation: confetti 3s ease-in infinite; } .confetti > .particle.c1 { background-color: rgba(76, 175, 80, 0.5); } .confetti > .particle.c2 { background-color: rgba(156, 39, 176, 0.5); } @-webkit-keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } @keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } function confetti() { $.each($(\".particletext.confetti\"), function(){ var confetticount = ($(this).width()/50)*10; for(var i = 0; i .particle { position: absolute; background-color: rgba(253, 216, 53, 0.5); -webkit-animation: sunbeams 3s linear infinite; animation: sunbeams 3s linear infinite; } @-webkit-keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } @keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } function sunbeams() { $.each($(\".particletext.sunbeams\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i","categories":[{"name":"前端篇","slug":"前端篇","permalink":"http://fantasy06.github.io/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"jQuery+CSS3","slug":"jQuery-CSS3","permalink":"http://fantasy06.github.io/tags/jQuery-CSS3/"},{"name":"粒子特效","slug":"粒子特效","permalink":"http://fantasy06.github.io/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/"}],"author":"Luckey"}],"categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://fantasy06.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"前端篇","slug":"前端篇","permalink":"http://fantasy06.github.io/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://fantasy06.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"基础","permalink":"http://fantasy06.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Hexo","slug":"Hexo","permalink":"http://fantasy06.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://fantasy06.github.io/tags/Github/"},{"name":"博客","slug":"博客","permalink":"http://fantasy06.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"http://fantasy06.github.io/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"},{"name":"jQuery+CSS3","slug":"jQuery-CSS3","permalink":"http://fantasy06.github.io/tags/jQuery-CSS3/"},{"name":"粒子特效","slug":"粒子特效","permalink":"http://fantasy06.github.io/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/"}]}