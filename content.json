{"meta":{"title":"LuckJinのBlog","subtitle":"Fantasyの博客","description":"记录努力学习编程的笔记","author":"Fantasy","url":"https://blog.luckjin.cool","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"404.html","permalink":"https://blog.luckjin.cool/404.html","excerpt":"","text":""},{"title":"404","date":"2022-08-05T06:26:30.000Z","updated":"2022-08-05T10:29:58.810Z","comments":true,"path":"404/index.html","permalink":"https://blog.luckjin.cool/404/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-08-07T03:31:43.299Z","comments":false,"path":"about/index.html","permalink":"https://blog.luckjin.cool/about/index.html","excerpt":"","text":""},{"title":"日常生活记录","date":"2022-08-08T10:07:59.000Z","updated":"2022-08-22T14:26:29.096Z","comments":true,"path":"bber/index.html","permalink":"https://blog.luckjin.cool/bber/index.html","excerpt":"","text":"window.TWIKOO_MAGIC_PATH=\"自言自语\" 说说内容来自 @Fantasy 的日常分享。🤪🤪 bbtalk.init({ appId: \"T8EN31jisjfUg0FH1GN4DX2Q-gzGzoHsz\", appKey: \"EJpMssw7sfVdzaLqueHAS921\", serverURLs: 'https://t8en31ji.lc-cn-n1-shared.com' })"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"https://blog.luckjin.cool/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"文章分类","date":"2019-10-24T16:00:00.000Z","updated":"2022-08-23T04:27:27.336Z","comments":false,"path":"categories/index.html","permalink":"https://blog.luckjin.cool/categories/index.html","excerpt":"","text":""},{"title":"朋友圈","date":"2022-08-22T02:55:17.000Z","updated":"2022-09-04T02:30:25.018Z","comments":false,"path":"fcircle/index.html","permalink":"https://blog.luckjin.cool/fcircle/index.html","excerpt":"","text":"与主机通讯中…… var fdataUser = { apiurl: 'https://friends.luckjin.cool/' }"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-08-18T09:44:16.168Z","comments":false,"path":"archives/index.html","permalink":"https://blog.luckjin.cool/archives/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-08-06T03:50:23.678Z","comments":true,"path":"contact/index.html","permalink":"https://blog.luckjin.cool/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Blogの友链信息 博客名称: FantasyのBlog 博客介绍: The harder you work, the luckier you will be"},{"title":"Friends","date":"2022-08-08T08:26:56.000Z","updated":"2022-08-13T10:26:30.047Z","comments":true,"path":"friends/index.html","permalink":"https://blog.luckjin.cool/friends/index.html","excerpt":"","text":"欢迎留言添加友链 ✌️✌️ - name: LuckJin's Blog link: https://blog.luckjin.cool/ avatar: https://picgo-fantasy06.oss-cn-guangzhou.aliyuncs.com/img/fantasy.jpg descr: 记录努力成为 前端er 学习之路"},{"title":"相册","date":"2022-08-07T07:44:20.000Z","updated":"2022-08-08T08:38:36.754Z","comments":false,"path":"galleryGroup/index.html","permalink":"https://blog.luckjin.cool/galleryGroup/index.html","excerpt":"","text":"Jay 我们的青春 动漫人物 关于的动漫人物图片 城市风光 城市一些美景 二次元风 关于的二次元风图片 花店 关于的清新花卉图片 动漫插画 关于的动漫插画图片 动漫风景 关于的动漫风景图片 呆萌猫咪 关于的呆萌猫咪图片 乖巧小狗 关于的乖巧小狗图片"},{"title":"gallery/pic1","date":"2022-08-07T07:45:42.000Z","updated":"2022-08-07T08:34:28.895Z","comments":false,"path":"gallery/index.html","permalink":"https://blog.luckjin.cool/gallery/index.html","excerpt":"","text":""},{"title":"空调房","date":"2022-08-08T09:24:44.000Z","updated":"2022-08-08T09:47:18.990Z","comments":false,"path":"kongt/index.html","permalink":"https://blog.luckjin.cool/kongt/index.html","excerpt":"","text":"客官，进来凉快会儿吧～document.documentElement.setAttribute(\"data-theme\", \"dark\"); 记得要节约用电哦"},{"title":"留言板","date":"2022-08-07T03:02:30.000Z","updated":"2022-08-10T06:31:51.415Z","comments":true,"path":"messageboard/index.html","permalink":"https://blog.luckjin.cool/messageboard/index.html","excerpt":"","text":"畅所欲言 🤗🤗在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"标签","date":"2019-07-19T08:40:27.000Z","updated":"2022-08-07T05:19:56.611Z","comments":false,"path":"tags/index.html","permalink":"https://blog.luckjin.cool/tags/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-08-07T04:20:54.260Z","comments":false,"path":"List/movies/index.html","permalink":"https://blog.luckjin.cool/List/movies/index.html","excerpt":"","text":"@media only screen and (max-width: 601px) { .movies-w { width: 90%; margin: 0 auto; } .movies-h { height: 90%; padding-top: 5%; padding-bottom: 5%; } } /*中等屏幕下(平板类)的样式*/ @media only screen and (min-width: 600px) and (max-width: 992px) { .movies-w { width: 95%; margin: 0 auto; } .movies-h { height: 95%; padding-top: 5%; padding-bottom: 5%; } } @media only screen and (min-width: 993px) { .movies-w { width: 80%; margin: 0 auto; } .movies-h { height: 80%; padding-top: 5%; padding-bottom: 5%; } } 📺 励 志 短 片"},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"https://blog.luckjin.cool/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-08-07T08:34:45.095Z","updated":"2022-08-07T08:34:45.095Z","comments":false,"path":"gallery/乖巧小狗/index.html","permalink":"https://blog.luckjin.cool/gallery/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-08-09T14:08:29.413Z","comments":true,"path":"List/music/index.html","permalink":"https://blog.luckjin.cool/List/music/index.html","excerpt":"","text":"欢迎，一起欣赏美妙的音乐吧！ /* don't remove. */ .container { height: 70vh; } 周董现场大合集Taylor Swift纯音乐“时代的狂，音乐的王，万物臣服在我乐章！”"},{"title":"二次元风","date":"2022-08-07T08:34:49.225Z","updated":"2022-08-07T08:34:49.225Z","comments":false,"path":"gallery/二次元风/index.html","permalink":"https://blog.luckjin.cool/gallery/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"Jay Chou 青春的模样","date":"2022-08-08T09:22:20.678Z","updated":"2022-08-08T09:22:20.678Z","comments":false,"path":"gallery/Jay/index.html","permalink":"https://blog.luckjin.cool/gallery/Jay/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-08-07T08:34:54.418Z","updated":"2022-08-07T08:34:54.418Z","comments":false,"path":"gallery/动漫人物/index.html","permalink":"https://blog.luckjin.cool/gallery/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-08-07T08:35:03.565Z","updated":"2022-08-07T08:35:03.565Z","comments":false,"path":"gallery/动漫插画/index.html","permalink":"https://blog.luckjin.cool/gallery/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-08-07T08:35:08.111Z","updated":"2022-08-07T08:35:08.111Z","comments":false,"path":"gallery/呆萌猫咪/index.html","permalink":"https://blog.luckjin.cool/gallery/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-08-07T08:35:12.798Z","updated":"2022-08-07T08:35:12.798Z","comments":false,"path":"gallery/城市风光/index.html","permalink":"https://blog.luckjin.cool/gallery/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-08-07T08:43:50.819Z","updated":"2022-08-07T08:43:50.819Z","comments":false,"path":"gallery/动漫风景/index.html","permalink":"https://blog.luckjin.cool/gallery/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-08-07T08:34:39.584Z","updated":"2022-08-07T08:34:39.584Z","comments":false,"path":"gallery/清新花卉/index.html","permalink":"https://blog.luckjin.cool/gallery/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-08-07T08:34:35.820Z","updated":"2022-08-07T08:34:35.820Z","comments":false,"path":"gallery/自然风景/index.html","permalink":"https://blog.luckjin.cool/gallery/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"vue3&composition Api","slug":"vue3-composition-Api","date":"2022-11-02T02:40:53.000Z","updated":"2022-11-03T14:55:06.362Z","comments":true,"path":"posts/c62574f6.html","link":"","permalink":"https://blog.luckjin.cool/posts/c62574f6.html","excerpt":"","text":"setup setup 是 Vue3 中一个新的配置项，值为函数 组件中使用的数据、方法等都要配置在 setup 中 setup 函数返回值：对象，函数等数据，可在模板中直接使用 setup 函数参数：props，context props ：自定义属性，组件外部传进来，且组件内部声明接收的属性（父传子） context ：上下文对象，也称之为是一个SetupContext，它里面包含三个属性 attrs： 所有非 prop 的 attribute，组件外部传进来，且组件内部没有声明接收的属性，相当于 this.$attrs slot：父组件传递过来的插槽，相当于 this.$slots emit：触发自定义事件，相当于 this.$emit export default { name: 'App', props: ['title'], // 声明自定义事件，虽然不声明也能运行 emits: ['changeCount'], setup(props, context) { let name = 'Vue3' function sayHello() {} function test() { // 创建自定义事件 context.emit('changeCount', 888) } // 在 setup 函数 定义的值，函数 // return 出去可以在模板上使用 return { name, sayHello, test, } }, } 注意： setup 在 beforeCreate 钩子之前执行，this 为 undefined setup 不要和 Vue2 配置混用。Vue2 的配置可以访问到 setup 的属性方法，反过来不行；如有重名，setup 优先 setup 不能是 async 函数，因为 async 函数返回的是 promise 不是对象，会导致模板无法访问属性方法 若要返回 promise 实例，需要 Suspense 和异步组件的配合 定义响应式数据ref 函数 语法：const msg = ref('hello world') 返回： ref 会返回一个可变的响应式对象，该对象作为一个 响应式的引用 维护着它内部的值 ref 函数可以接收基本数据类型和引用数据类型 原理： 基本类型数据的响应式还是靠 Object.defineProperty() 完成 对象类型数据使用 ES6 的 Proxy 实现响应式，Vue3 把相关操作封装在 reactive 函数中 按照之前的办法，对于对象数据，应该遍历每一层的属性添加 getter 、setter，但 Vue3 使用 Proxy 把内部数据一口气监测了 注意： 但是在 setup 函数内部，它依然是一个 ref引用， 所以对其进行操作时，我们依然需要使用 ref.value的方式 在模板中引入 ref 的值时，Vue会自动帮助我们进行解包操作，所以我们并不需要在模板中通过 ref.value 的方式来使用 reactive函数使用和 ref 大致一样 reactive API对传入的类型是有限制的，它要求我们必须传入的是一个对象或者数组类型 ref 和reactive 定义数据： ref 用于定义基本类型数据 reactive 用于定义对象或数组类型数据 ref 也可定义对象或数组类型数据，内部通过 reactive 转为代理对象 一般使用 reactive 函数，可以把所有数据封装为一个对象 原理： ref 通过 Object.defineProperty() 实现响应式 reactive 通过 Proxy 实现响应式，Reflect 操作源对象数据 使用角度： ref 定义数据，访问数据需要 .value，模板中不需要 reactive 定义的数据，都不需要 开发中选择 reactive/ref ： 通过服务器的建议使用 ref 本地的数据使用 reactive readonly的使用单项数据流概念：所有的 props 都遵循着单向绑定原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解 简单理解：父组件传到子组件中的原始数据，不可以在子组件修改，为了避免混乱不清楚哪一个组件修改数据的，统一返回父组件修改 readonly readonly: 让一个响应式数据变为只读的（深只读） shallowReadonly：让一个响应式数据变为只读的（浅只读） 应用场景: 不希望数据被修改时，如你用了别人的响应式数据，但是别人不希望你修改时 setup() { let sum = ref(0) let person = reactive({...}) sum = readonly(sum) person = shallowReadonly(person) return { sum, person } } 判断 Reactive 的 API isProxy检查对象是否是由 reactive 或 readonly创建的 proxy。 isReactive检查对象是否是由 reactive创建的响应式代理： 如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true； isReadonly 检查对象是否是由 readonly 创建的只读代理。 toRaw返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）。 shallowReactive 创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)。 shallowReadonly创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）。 toRefs使用ES6的解构语法，对 reactive 返回的对象进行解构获取值，那么之后无论是修改结构后的变量，还是修 reactive返回的state对象，数据都不再是响应式的 使用 toRef 可以将reactive返回的对象中的属性都转成 ref 如果我们只希望转换一个reactive对象中的属性为 ref , 那么可以使用 toRef的方法 const state = reactive({ name: 'jay', age: 18 }) // 使用 toRefs/toRef 数据成响应式 // toRefs const {name, age} = toRefs(state) // toRef const name = toRef(state,'name') setup中不能使用this this 并没有指向当前组件实例； 并且在 setup 被调用之前，data、computed、methods 等都没有被解析； 所以无法在 setup 中获取 this； computed计算属性 （简写）接收一个getter函数，并为 getter 函数返回的值，返回一个不变的 ref 对象 （完整）接收一个具有 get 和 set 的对象，返回一个可变的（可读写）ref 对象 import { reactive, computed } from 'vue' export default { setup() { let person = reactive({ firtName: 'jay', lastName: 'FT' }) // 简写模式 const fullName = computed(()=&gt;{ return firtName.value + '' + lastName.value }) // 完整写法 const fullname = computed({ get: ()=&gt; { return firtName.value + ' ' + lastName.value }, set: newValue =&gt; { const names = newValue.split(' ') firtName.value = names[0] lastName.value = names[1] } }) function setFullname() { fullname.value = \"jay FT\" } } } 生命周期注册函数在 setup 里，可以使用直接导入的 onX 函数注册生命周期钩子 import { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted } from 'vue' setup(){ console.log('---setup---') let sum = ref(0) //通过组合式API的形式去使用生命周期钩子 onBeforeMount(()=&gt;{ console.log('---onBeforeMount---') }) onMounted(()=&gt;{ console.log('---onMounted---') }) onBeforeUpdate(()=&gt;{ console.log('---onBeforeUpdate---') }) onUpdated(()=&gt;{ console.log('---onUpdated---') }) onBeforeUnmount(()=&gt;{ console.log('---onBeforeUnmount---') }) onUnmounted(()=&gt;{ console.log('---onUnmounted---') }) return {sum} }, 选项式 API Hook inside setup beforeCreate setup() create setup() beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeUnmount onBeforeUnmount unmounted onUnmounted activted OnActivted deactivated Ondeactivated setup 函数是 围绕 beforeCreate 和 create 生命周期钩子运行的，所有不需要显式的定义它们。在这些钩子的代码直接在 setup 函数编写 provide/inject 实现祖先组件与后代组件之间通信 // 祖先组件传递数据 import { provide, reactive, ref } from 'vue' setup() { let car = reactive({...}) let sum = ref(0) provide('sum', sum) provide('car', car) } // ====================== // 后代组件接收数据 import { inject } from 'vue' setup() { const car = inject('car') const sum = inject('sum') return { car, sum } } 2.5. watch/watchEffectwatch// 数据 let sum = ref(0) let msg = ref('hello') let infoRef = ref({ name: 'Jay', age: 18, song: { fantasy: { year: 2002 } } }) // reactive响应数据 let info = reactive({ name: 'Jay', age: 18, song: { fantasy: { year: 2002 } } }) // 侦听 ref 定义响应式数据 watch(sum, (newVal, oldVal) =&gt; { console.log(newVal, oldVal) }) // 侦听多个 ref 数据、 watch([sum, msg], (newVal, oldVal) =&gt; { // newVal，oldVal 也是数组 console.log(newVal, oldVal) }) // 侦听对象数据 需要开启深度监听 // 此时监听的是 RefImpl 实例 // Ref 实例的 value 是 Proxy 对象，存的是地址 // 因此无法监听 person 内部属性的变化 watch(infoRef, (newVal, oldVal) =&gt; {}, { deep: true }) // 侦听 reactive 定义的响应式数据某个属性 // 强制开启了深度侦听，deep 配置不生效！ // 如果监视的属性还是对象，则需要开启深度监听 // 侦听多个属性也是使用数组形式 watch( () =&gt; info.song, (newVal, oldVal) =&gt; { console.log(newVal, oldVal) }, { deep: true } ) 可选项 immediate: true 页面加载触发一次 deep: true 深度侦听 watchEffect 函数 watchEffect 不需要指明监听哪个属性，回调里用到哪个属性，就自动监听哪个属性 computed 注重计算的值，即回调函数的返回值，因此必须有返回值 watchEffect 更注重过程，即回调函数的函数体，因此可没有返回值 watchEffect 没有开启深度监听，也不能开启深度监听！ watchEffect 内部自行修改数据，不会重新调用回调，因此不会出现递归调用 // 回调中用到的数据只要发生变化，则直接重新执行回调 watchEffect(() =&gt; { let total = sum.value let p = person console.log('watchEffect...') }) watch/watchEffect区别: 1.watch必须制定数据源, watchEffect自动收集依赖 2.watch监听到改变, 可以拿到改变前后value 3.watchEffect默认直接执行一次, watch在不设置immediate第一次是不执行 script setup语法糖 &lt;script setup&gt; 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖，当同时使用 SFC 与组合式 API 时则推荐该语法。 &lt;script setup&gt; 里面的代码会被编译成组件 setup() 函数的内容： 这意味着与普通的 &lt;script&gt; 只在组件被首次引入的时候执行一次不同 &lt;script setup&gt; 中的代码会在每次组件实例被创建的时候执行。 顶层的绑定会被暴露给模板：任何在 &lt;script setup&gt; 声明的顶层的绑定 (包括变量，函数声明，以及 import 引入的内容都能在模板中直接使用 导入组件直接使用： &lt;script setup&gt; 范围里的值也能被直接作为自定义组件的标签名使用 defineProps &amp;&amp; defineEmits 为了在声明 props 和 emits 选项时获得完整的类型推断支持，我们可以使用 defineProps 和 defineEmits API，它们将自动地在 &lt;script setup&gt; 中可用 &lt;script setup&gt; const props = defineProps({ name: { type: String, default: 'Jay' }, age: { type: Number, default: 1 } }) const emit = defineEmits(['changeAge']) function changeAge() { emit('changeAge', 200) } &lt;/script&gt; defineExpose 通过模板 ref 或者 $parent 链获取到的组件的公开实例，不会暴露任何在 &lt;script setup&gt; 中声明的绑定 通过 defineExpose 编译器宏来显式指定在 &lt;script setup&gt; 组件中要暴露出去的 property function foo() { console.log('foo执行') } defineExpose({ foo }) Compositon API 的优势Options API 存在的问题 使用传统 Options API 中，新增或者修改一个需求，就需要分别在 data，methods，computed 等地方修改 composition API 的优势 可以更加优雅地组织代码、函数，让相关功能的代码更加有序的组织在一起。说白了就是让同一个功能的代码整合到一起，日后修改代码直接找对应的功能模块。","categories":[{"name":"vue","slug":"vue","permalink":"https://blog.luckjin.cool/categories/vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"vue","slug":"vue","permalink":"https://blog.luckjin.cool/tags/vue/"}]},{"title":"Ajax 及其 Axios 的使用归纳","slug":"Ajax-及其-Axios-的使用归纳","date":"2022-08-24T03:47:17.000Z","updated":"2022-08-24T10:54:23.732Z","comments":true,"path":"posts/471bc9cf.html","link":"","permalink":"https://blog.luckjin.cool/posts/471bc9cf.html","excerpt":"","text":"推荐使用 Axios Axios 是专注于网络数据请求的库。 相比于原生的 XMLHttpRequest 对象，axios 简单易用。 相比于 jQuery，axios 更加轻量化，只专注于网络数据请求。 传统的Ajax (XHR)基本使用步骤 创建 xhr 对象 调用 xhr.open() 函数 （POST 请求）设置 Content-Type 属性（固定写法） 调用 xhr.send() 函数 监听 xhr.onreadystatechange 事件 GET请求POST请求// 创建 xhr 对象 const xhr = new XMLHttpRequest() // 调用 open 指定请求方式和 url 地址 // 带有参数可以使用查询字符串格式 // 请求地址URL用 ？ 拼接 // 例如 id=1&amp;&amp;page=2 xhr.open('GET','https://www.baidu.com/api？id=1&amp;&amp;page=2') // 调用 send 发起 Ajax 请求 xhr.send() // 监听发起请求后的事件，onreadystatechange xhr.onreadystatechange = function() { // 监听 // 请求对象的请求状态 readyState // 服务器响应状态 status if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){ // responeseText响应回来的数据 console.log(xhr.responeseText) } } // // 创建 xhr 对象 const xhr = new XMLHttpRequest() // 调用 open 指定请求方式和 url 地址 xhr.open('POST','https://www.baidu.com/api') // 设置 Content-Type 属性（固定写法） xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') // 调用 send()，同时将数据以查询字符串的形式，提交给服务器 xhr.send('id=1&amp;author=fantasy&amp;page=2) // 监听发起请求后的事件，onreadystatechange xhr.onreadystatechange = function() { // 监听 // 请求对象的请求状态 readyState // 服务器响应状态 status if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){ // responeseText响应回来的数据 console.log(xhr.responeseText) } } XMLHttpRequest 对象的 readyState 属性，用来表示当前 Ajax 请求所处的状态。每个 Ajax 请求必然处于以下状态中的一个： 值 状态 描述 0 UNSENT XMLHttpRequest 对象已被创建，但尚未调用 open方法。 1 OPENED open() 方法已经被调用。 2 HEADERS_RECEIVED send() 方法已经被调用，响应头也已经被接收。 3 LOADING 数据接收中，此时 response 属性中已经包含部分数据。 4 DONE Ajax 请求完成，这意味着数据传输已经彻底完成或失败。 设置 HTTP 请求时限xhr.timeout = 3000 xhr.ontimeout = function(event){ alert('请求超时！') } 设置 http 请求时限，3000毫秒，超时执行 ontimeout 的回调函数 FormDate 对象管理表单数据基本使用 // 新建 FormData 对象 const fd = new FormDate() // 添加数据 加入表单项 fd.append('id','12') fd.append('name','fantasy') // post 请求直接发送 FormData对象 // ...Ajax请求代码 xhr.send(fd) 获取网页 dom 表单的值 // 获取 dom 表单 const form = document.querySelector('#form') // 监听表单提交 form.addEventListener('submit', function(e) { // 阻止表单默认行为 e.preventDefault() //根据 form 表单创建 FormData 对象，会自动将表单数据填充到 FormData 对象中 const fd = new FormData(form) // post 请求直接发送 FormData对象 // ...Ajax请求代码 xhr.send(fd) } 上传文件 // 1. 创建 FormData 对象 var fd = new FormData() // 2. 向 FormData 中追加文件 fd.append('avatar', files[0]) // post 请求直接发送 FormData对象 // ...Ajax请求代码 xhr.send(fd) 监听 xhr.upload.onprogress 文件的上传进度 xhr.upload.onprogress = function(e) { // e.lengthComputable 是一个布尔值，表示当前上传的资源是否具有可计算的长度 if (e.lengthComputable) { // e.loaded 已传输的字节 // e.total 需传输的总字节 const percentComplete = Math.ceil((e.loaded / e.total) * 100) } } 监听 xhr.upload.onload 文件上传完成 xhr.upload.onload = function() { $('#percent') // 移除上传中的类样式 .removeClass() // 添加上传完成的类样式 .addClass('progress-bar progress-bar-success') } jQuery-Ajax浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数，极大地降低了 Ajax 的使用难度。 常用方式$.get()$.post()$.ajax()$.get(url,[data],[callback]) 参数名 参数类型 是否必选 说明 url string 是 请求的地址 data object 否 请求传递的参数 callback function 否 请求成功的回调函数 // 例子 $.get('http://www.badui/api',{id:1,name:'fantasy'}, function(res) { // 这里的 res 是服务器返回的数据 console.log(res) })$.post(url,[data],[callback]) 参数名 参数类型 是否必选 说明 url string 是 请求的地址 data object 否 请求传递的参数 callback function 否 请求成功的回调函数 // 例子 $.post('http://www.badui/api',{id:1,name:'fantasy'}, function(res) { // 这里的 res 是服务器返回的数据 console.log(res) })$.ajax({ type: '', // 请求的方式，例如 GET 或 POST url: '', // 请求的 URL 地址 data: { },// 这次请求要携带的数据 success: function(res) { } // 请求成功之后的回调函数 }) // 例子 $.ajax({ type: 'get', // 请求的方式，例如 GET 或 POST url: 'http://www.badui/api', // 请求的 URL 地址 data: {id:1,name:'fantasy' },// 这次请求要携带的数据 success: function(res) { } // 请求成功之后的回调函数 }) FormDate 对象管理表单数据也适合 jQuery-Ajax因为 FormDate 是 HTML5 新增的一个 对象，可以模拟表单操作用法大致相同 拼接请求的根路径建议新建 baseAPI.js // 注意：每次调用 $.get() 或 $.post() 或 $.ajax() 的时候， // 会先调用 ajaxPrefilter 这个函数 // 在这个函数中，可以拿到我们给Ajax提供的配置对象 $.ajaxPrefilter(function(options) { // 在发起真正的 Ajax 请求之前，统一拼接请求的根路径 options.url = 'http://ajax.frontend.itheima.net' + options.url }) 统一为有权限的接口设置headers请求头// 统一为有权限的接口，设置 headers 请求头 if (options.url.indexOf('/my/') !== -1) { options.headers = { Authorization: localStorage.getItem('token') || '' } } // 全局统一挂载 complete 回调函数 // 不论请求成功还是失败，最终都会调用 complete 回调函数 options.complete = function(res) { // 在 complete 回调函数中，可以使用 res.responseJSON 拿到服务器响应回来的数据 if (res.responseJSON.status === 1 &amp;&amp; res.responseJSON.message === '身份认证失败！') { // 1. 强制清空 token localStorage.removeItem('token') // 2. 强制跳转到登录页面 location.href = '/login.html' } } }) Axiosaxios.getaxios.postaxios// 语法 axios.get('url',{params:{ 参数 } } ).then(callback) // 例子 axios.get('url', { params :{ id: 1, name:'fantasy' } //res.data 是服务器返回的数据 }).then(res =&gt; { consloe.log(res.data) }) 参数名 参数类型 是否必选 说明 url string 是 请求的地址 params object 否 请求传递的参数 callback function 否 请求成功的回调函数 // 语法 axios.post('url',{ 参数 } ).then(callback) // 例子 axios.post('url', { id:1, name:'fantasy' }).then(res =&gt; { consloe.log(res.data) }) //res.data 是服务器返回的数据// 语法 axios({ // 使用 method 或 type 其中一种声明类型即可 method/type:'请求类型', url:'请求地址', data:{ post 数据 }, params:{ get 参数} }).then(callback) // 例子 axios({ method:'get', url:'url', params:{id:1,name:'fantasy'} }).then(res =&gt; { consloe.log(res.data) }) 配合 async / await 使用axios返回的数据是一个Promise实例对象，用 .then()取到正确的数据 async 关键字用于函数上（async函数的返回值是Promise实例对象） await 关键字用于 async 函数当中（await可以得到异步的结果） // post 请求例子 document.querySelector('#btnPost').addEventListener('click', async function () { // 如果调用某个方法的返回值是 Promise 实例，则前面可以添加 await！ // await 只能用在被 async “修饰”的方法中 // 解构赋值 把 axios 返回部分 解构出 data 重命名为 res const { data: res } = await axios({ method: 'POST', url: '/api/post', data: { name: 'fantasy', id: 1 } }) console.log(res) }) vue 2.x 全局配置 axios优点：每个组件可以通过 this.$http.get 直接发起请求，无需再导入 axios ；若根路径发生改变，只需修改 axios.defaults.baseURL ，有利于代码维护。 // main.js // 配置请求根路径 axios.defaults.baseURL = 'http://api.com' // 把 axios 挂载到 Vue 原型上 Vue.prototype.$http = aixos 缺点：无法实现 API 的复用。即多个组件需要对同一个接口发起请求，那么每个组件都需要重复书写 this.$http.get('/users') 类似的代码，造成冗余 改进：对于每一个根路径，独立封装一个 request.js 模块，组件导入所需根路径对应的 axios 进行使用 import axios from 'axios' // 调用 axios.craete() 函数，request 接收 axios 实例对象 const request = axios.create({ baseURL: 'http://api.com' }) export default request","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Ajax","slug":"Ajax","permalink":"https://blog.luckjin.cool/tags/Ajax/"}]},{"title":"vue-router","slug":"vue-router","date":"2022-08-22T14:22:56.000Z","updated":"2022-08-23T11:37:13.298Z","comments":true,"path":"posts/6098be36.html","link":"","permalink":"https://blog.luckjin.cool/posts/6098be36.html","excerpt":"","text":"前端路由前端路由，指的是 Hash 地址与组件之间的对应关系 工作方式： 用户点击了页面的路由链接 导致了 URL 地址栏的 Hash 值方式变化 前端路由监听到 Hash 地址的变化 前端路由把当前 Hash 值地址对应的组件渲染到浏览器页面 简单路由的实现&lt;!-- a 链接添加对应的 hash 值 --&gt; &lt;a href=\"#/home\"&gt;Home&lt;/a&gt; &lt;a href=\"#/movie\"&gt;Movie&lt;/a&gt; &lt;a href=\"#/about\"&gt;About&lt;/a&gt; &lt;!-- 动态渲染结点 --&gt; &lt;!-- 通过 is 属性 指定要展示的组件 --&gt; &lt;comnponent :is=\"comName\"&gt;&lt;/comnponent&gt; &lt;script&gt; export default{ name:'App', data(){ return{ comName:'Home' } }, // 在 created 生命周期函数中，监听浏览器地址栏中hash 地址的变化 //动态切换要展示的组件的名称 created(){ window.onhashchange=()=&gt;{ switch(location.hash){ case: '#/home': this.comName = 'Home' break case: '#/movie': this.comName = 'Movie' break case: '#/about': this.comName = 'About' break } } } } &lt;/script&gt; vue-routervue-router 是 vue.js 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目中组件的切换vue-router 的官方文档地址：https://router.vuejs.org/zh/ 基本用法1.安装：在 vue2 的项目中，安装 vue-router@3.5.2 npm i vue-router@3.5.2 -S 2.在项目 src 目录下 新建 router/index.js 路由模块 // 导入 vue 和 vue-router import Vue from 'vue' import VueRouter from 'vue-router' // 调用 Vue.app() 安装 VueRouter Vue.app(VueRouter) // 创建路由实例对象 const router = new VueRouter() // 导出共享 export default router 3.导入挂载，在 src/main.js 入口文件导入挂载路由模块 import Vue from 'vue' import App from './App.vue' // 1.导入 import router from './router/index.js' new Vue({ // 2.挂载 router, render: (h) =&gt; h(App), }).$mount('#app') 4.声明路由链接和占位符 在 App.vue 里使用 vue-router 提供的 &lt;router-link&gt; 和 router-view 声明路由链接和占位符 &lt;template&gt; &lt;div&gt; &lt;h1&gt; App组件 &lt;/h1&gt; &lt;!-- 定义路由链接 --&gt; &lt;router-link to=\"/home\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/movie\"&gt;电影&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;关于&lt;/router-link&gt; &lt;!-- 定义路由占位符 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; 5.声明路由规则，在路由模块 src/router/index.js，通过 routers 数组声明匹配规则 // 导入 需要使用路由切换的组件 import Vue from 'vue' import VueRouter from 'vue-router' import Home from '@/component/Home.vue' import About from '@/component/About.vue' import Movie from '@/component/Movie.vue' // 创建路由实例对象 const router = new VueRouter({ // 路由匹配规则 const routes = [ // pash 表示匹配的 hash 地址 // component 表示要展示的组件 { path: '/home', component: Home }, { path: '/about', component: About }, { path: '/movie', component: Movie }, ] }) 路由重定向路由重定向指定的是，用户在访问 A 地址，强制用户跳转到 B 地址 const router = new VueRouter({ // 路由匹配规则 const routes = [ // 通过 redirect 属性，设置重定向 // 当用户访问 / 时 跳转到 /home 对应的路由规则 {path:'/',redirect:'/home'}, { path: '/home', component: Home }, { path: '/about', component: About }, { path: '/movie', component: Movie }, ] }) 嵌套路由通过路由实现组件的嵌套展示，叫做嵌套路由。 图例 在 About.vue 组件中，声明 tab1 和 tab2 的子路由链接以及子路由占位符 &lt;template&gt; &lt;div class=\"about-container\"&gt; &lt;!-- 要把父路由写上 --&gt; &lt;router-link to=\"/about/tab1\"&gt;tab1&lt;/router-link&gt; &lt;router-link to=\"/about/tab2\"&gt;tab2&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; 在 src/router/index.js 路由模块中，导入需要的组件，并使用 children 属性声明子路由规则 const routes = [ { path: '/about', component: 'About', children: [ // 注意不要写成 /tab1 { path: 'tab1', component: Tab1 }, { path: 'tab2', component: Tab2 }, ], }, ] 动态路由匹配动态路由指的是：把 Hash 地址中可变的部分定义为参数项，从而提高路由规则的复用性。在 vue-router 中使用英文的冒号（:）来定义路由的参数项。 // 动态参数以 : 进行声明。冒号后面的是动态参数名称 { path: '/movie/:id', component: Moive }, // 动态路由将下面的规则合成一个提高复用性 { path: '/movie/1', component: Moive }, { path: '/movie/2', component: Moive }, { path: '/movie/3', component: Moive }, 参数动态路由渲染出来的组件中，可以使用 this.$route.params 对象访问到动态匹配的参数值。 &lt;template&gt; &lt;div class=\"about-container\"&gt; &lt;!-- this.$route 是参数对象 --&gt; &lt;h3&gt;Movie 组件：接收的参数是{{ this.$route.params }}&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; 为了简化路由参数的获取形式，vue-router 允许在路由规则中开启props 传参 // 定义路由规则时 声明 props:true 选项 { path: '/movie/:id', component: Moive ,props:true}, &lt;template&gt; &lt;div class=\"about-container\"&gt; &lt;!-- 使用 props 中接收的参数 --&gt; &lt;h3&gt;Movie 组件：接收的参数是{{ id}}&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default{ // 接收路由规则中匹配的参数项 id props:['id'] } &lt;/script&gt; 编程式导航声明式导航： 通过点击链接实现导航 如普通网页点击 a 链接，vue 点击 &lt;router-link&gt; 编程式导航： 通过调用 API 实现导航 普通网页通过 location.href 的方式跳转页面也是编程式导航 vue-router 中实现编程式导航的 API ： this.$router.push('hash地址') ：跳转到指定页面，并增加一条历史记录 this.$router.replace('hash地址') ：跳转页面，但不会新增历史记录，而是替换当前的历史记录 this.$router.go(数值) ：历史记录前进或后退，相当于点击浏览器前进后退箭头 this.$router.forward() ：前进一步 this.$router.back() ：后退一步 导航守卫 全局前置守卫每次发生路由的导航跳转时，都会触发全局前置守卫。因此，在全局前置守卫中，程序员可以对每个路由进行访问权限的控制 // index.js路由模块文件 // 全局前置守卫 router.before({to,from,next}=&gt;{ // to 将要访问的路由 // from 将要离开的路由 // next 是一个函数表示放行 }) next 函数的 3 种调用方式 当前用户拥有后台主页的访问权限，直接放行：next()当前用户没有后台主页的访问权限，强制其跳转到登录页面：next(‘/login’)当前用户没有后台主页的访问权限，不允许跳转到后台主页：next(false) 随机","categories":[{"name":"vue","slug":"vue","permalink":"https://blog.luckjin.cool/categories/vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"vue","slug":"vue","permalink":"https://blog.luckjin.cool/tags/vue/"}]},{"title":"vscode配置","slug":"vscode配置","date":"2022-08-21T04:36:01.000Z","updated":"2022-08-22T14:58:17.230Z","comments":true,"path":"posts/789169fd.html","link":"","permalink":"https://blog.luckjin.cool/posts/789169fd.html","excerpt":"","text":"path Autocomplete@ 路径导入 // 配置 @ 的路径提示 \"path-autocomplete.pathMappings\": { \"@\": \"${folder}/src\" }, // 导入文件是否携带文件扩展名 \"path-autocomplete.extensionOnImport\": true, ESLint 和 Prettier在 C:\\Users\\你的用户名 路径下创建 .prettierrc 文件，里面写上 {\"semi\": false, \"singleQuote\": true, \"printWidth\": 300} 接着在 settings.json 文件配置： \"editor.codeActionsOnSave\": { \"source.fixAll\": true, }, \"eslint.alwaysShowStatus\": true, // 配置prettier \"prettier.configPath\": \"C:\\\\Users\\\\???\\\\.prettierrc\", // 对象或数组最后一个元素后面是否逗号 \"prettier.trailingComma\": \"none\", // 句尾是否分号 \"prettier.semi\": false, // 每行文字个数超出此限制将会被迫换行 \"prettier.printWidth\": 300, // 使用单引号替换双引号 \"prettier.singleQuote\": true, // (x) =&gt; {} 箭头函数参数只有一个时是否要有小括号。avoid：省略括号 \"prettier.arrowParens\": \"avoid\", // 设置 .vue 文件中，HTML代码的格式化插件 \"vetur.format.defaultFormatter.html\": \"js-beautify-html\", \"vetur.ignoreProjectWarning\": true, \"vetur.format.defaultFormatterOptions\": { \"js-beautify-html\": { \"wrap_attributes\": false }, \"prettyhtml\": { \"printWidth\": 300, \"trailingComma\": \"none\", \"singleQuote\": true, \"semi\": false, \"arrowParens\": \"avoid\" } }","categories":[{"name":"vscode","slug":"vscode","permalink":"https://blog.luckjin.cool/categories/vscode/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"vscode","slug":"vscode","permalink":"https://blog.luckjin.cool/tags/vscode/"},{"name":"工具","slug":"工具","permalink":"https://blog.luckjin.cool/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"vue 开发组件化","slug":"vue-开发组件化","date":"2022-08-18T07:53:48.000Z","updated":"2022-08-24T02:33:58.520Z","comments":true,"path":"posts/5f847e4b.html","link":"","permalink":"https://blog.luckjin.cool/posts/5f847e4b.html","excerpt":"","text":"vue-cli什么是 vue- clivue-cli 是 Vue.js 开发的标准工具。它简化了程序员基于 webpack 创建工程化的 Vue 项目的过程。 安装与使用安装 npm -g @vue/cli 使用 快速初始化 vue create 项目名字 运行流程vue 通过 main.js 把 app.vue 渲染到 index.html 指定区域 app.vue 用来编写待渲染的模板结构 index.html 中需要预留 el 区域 vue 组件的三个组成部分template（组件的模板结构）&lt;template&gt; &lt;div&gt; &lt;!-- 定义当前组件的 DOM 结构 --&gt; &lt;/div&gt; &lt;/template&gt; 每个组件的模板结构 ，需要调用到 template template 的 vue 提供的容器标签 ，只有包裹性作用，不会渲染为真正的DOM元素 template 只能包含唯一的根节点 简单理解里面写 HTML即可 script（组件的 JavaScript 行为）&lt;script&gt; export default { // 封装组件的 JS 业务逻辑 } &lt;/script&gt; style （组件的样式）&lt;style&gt; /* css代码 */ &lt;/style&gt; 添加less 语法支持 &lt;style leng=\"less\"&gt; /* less代码 */ &lt;/style&gt; 每个组件中必须包含 template 模板结构，而 script 行为和 style 样式是可选的组成部分 组件关系封装好 App.vue Left.vue Right.vue 之后，彼此间相互独立不存在关系 使用组件&lt;template&gt; &lt;div&gt; &lt;!-- 步骤三：以标签形式使用组件 --&gt; &lt;Left&gt;&lt;/Left&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 步骤一：使用 import 导入需要的组件 import Left from \"@/components/Left.vue\" export default{ // 步骤二：使用 components 结点注册组件 components:{ Left, } } &lt;/script&gt; 全局组件通过 components 注册的是私有子组件 在组件 A 的 components 节点下，注册了组件 F。 则组件 F 只能用在组件 A 中；不能被用在组件C 中。 注册全局组件 在 vue 项目的 main.js 入口文件，通过 Vue.component() 注册全局组件 // 导入需要注册的全局组件 import Count from \"@/components/Count.vue\" props （自定义属性）props 是组件的自定义属性，在封装通用组件的时候，合理地使用props 可以极大的提高组件的复用性！ 导入组件后以标签形式使用组件 在标签即可使用 自定义属性 &lt;!-- 绑定自定义属性 --&gt; &lt;!-- 自定义属性有小驼峰命名 改成连字符-命名 --&gt; &lt;count :init=\"1\" :cmt-count=\"2\"&gt;&lt;/count&gt; // count.vue export default { // 组件的自定义属性 // 格式一 // props: [\"自定义属性1\",\"自定义属性2\",\"自定义属性3\"], // props: [\"init\"], // 格式二：props:{ // 自定义属性1:{...} // 自定义属性2:{...} // 自定义属性3:{...} // } props: { // 自定义属性名 init: { // 默认值，如果用户不传递默认的值 default: 0, // 类型 ，传递过来的值必须是规定类型的值 type: Number, // 必选项，开启后必须传递值 ，这个组件才可以使用 require: true, // props 自定义属性为只读值，不能用户修改 }, // 如果自定义属性名为小驼峰命名 // 建议绑定属性时可改成连字符-命名 cmtCount:{ default: 0, type: Number, } }, data() { return { // props 的值转存到 data count: this.init, }; }, }; vue 规定：组件中封装的自定义属性是只读的，程序员不能直接修改 props 的值 要想修改 props 的值，可以把 props 的值转存到 data 中，因为 data 中的数据都是可读可写的！ 组件冲突问题默认情况下，写在 .vue 组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。 导致组件之间样式冲突的根本原因是： 单页面应用程序中，所有组件的 DOM 结构，都是基于唯一的 index.html 页面进行呈现的 每个组件中的样式，都会影响整个 index.html 页面中的 DOM 元素 style 节点的 scoped 属性为了提高开发效率和开发体验，vue 为 style 节点提供了 scoped 属性，从而防止组件之间的样式冲突问题 &lt;style leng=\"less\" scoped &gt; /* less代码 */ &lt;/style&gt; 原理：为当前组件所有 DOM 元素分配唯一的自定义属性，写样式时使用属性选择器防止样式冲突问题 scoped 只给子组件最外层的 div 添加了自定义属性 [data-v-xxx] ，子组件内部的标签并没有添加。因此父组件只能修改子组件最外层的 div 样式，修改子组件内层元素的样式是不可行的 若想让某些样式对子组件生效，需使用 /deep/ 深度选择器 (常用于修改 第三方 ui 组件库 ) /* 细细品味 */ &lt;style lang=\"less\" scoped&gt; .title { /* 不加 /deep/，选择器格式为 .title[data-v-052242de] */ color: blue; } /deep/ .title { /* 加 /deep/，选择器格式为 [data-v-052242de] .title */ color: blue; } &lt;/style&gt; 组件数据共享父子间的共享父向子共享：父组件向子组件共享数据需要使用自定义属性 父组件 &lt;son :msg=\"message\" :user=\"userinfo\"&gt;&lt;/son&gt; &lt;script&gt; export default{ data(){ return { // 定义要传递的值 message:'hello vue.js' userinfo:{name:'张三',age:18} } } } &lt;/script&gt; 子组件 &lt;p&gt;父组件传递过来的 msg 是 ：{{msg}}&lt;/p&gt; &lt;p&gt;父组件传递过来的 user 是 ：{{user}}&lt;/p&gt; &lt;script&gt; export default{ // 定义自定义属性 props:['msg','user'] } &lt;/script&gt; 子向父共享：子组件向父组件共享数据使用自定义事件。 子组件 export default{ data(){ return { // 定义要传递的值 count: 0 } }, methods:{ add(){ this.count++ // 修改数据时 ，通过 $emit() 触发自定义事件 // 参数1：自定义事件的名字， // 参数2：要传递的值 this.$emit(\"numChange\",this.count) } } } 父组件 &lt;son @numChange=\"getCount\"&gt;&lt;/son&gt; &lt;script&gt; export default{ data(){ return { // 定义储存传递过来的值 countFromSon: 0 } }, methods:{ // 定义触发自定义事件 numChange 的函数 // val 接收 son 自定义事件发送过来的值 getCount(val){ // 转存到countFromSon this.countFromSon=val } } } &lt;/script&gt; 兄弟间共享在 vue2.x 中，兄弟组件之间数据共享的方案是EventBus。 EventBus 的使用步骤： 创建 eventBus.js 模块，并向外共享一个 Vue 的实例对象 在数据发送方，调用 bus.$emit('事件名称', 要发送的数据) 方法触发自定义事件 在数据接收方，调用 bus.$on('事件名称', 事件处理函数) 方法注册一个自定义事件 兄弟组件 A（数据发送方） &lt;!--定义一个按钮 触发 --&gt; &lt;button @click=\"sendMsg\"&gt;发送数据给 兄弟组件 C&lt;/button&gt; &lt;script&gt; // 导入 EventBus 模块 import bus from \"./eventBus.js\"; export default { data() { return { // 共享的数据 msg: \"hello vue.js\", }; }, methods: { sendMsg() { // 自定义事件 // 参数：事件名称, 要发送的数据 bus.$emit(\"share\", this.msg); }, }, }; &lt;/script&gt; eventBus.js import Vue from 'vue' // 向外共享 Vue 的实例对象 export default new Vue() 兄弟组件 C（数据接收方） &lt;p&gt;兄弟组件 A 共享的数据 ：{{ msgFromLeft }}&lt;/p&gt; &lt;script&gt; // 导入 EventBus 模块 import bus from \"./eventBus.js\"; export default { data() { return { // 定义用来转存 发送过来的值 的变量 msgFromLeft: \"\", }; }, // 在 created 钩子中注册函数 created() { // 使用箭头函数，则 this 指向该组件而非 bus // 参数：事件名称, 事件处理函数 // 触发兄弟组件 A 自定义事件 share // 函数处理 把传递过来的值转存到 msgFromLeft bus.$on(\"share\", (val) =&gt; { this.msgFromLeft = val; }); }, }; &lt;/script&gt; 生命周期概念：每个组件从创建 -&gt; 运行 -&gt; 销毁的一个过程，强调的是一个时间段！ 生命周期阶段 官方生命周期图示 vue 官方文档给出的生命周期图示https://v2.cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA ref 引用每个 vue 的组件实例上，都包含一个$refs 对象，里面存储着对应的DOM 元素或组件的引用。默认情况下，组件的 $refs 指向一个空对象。 引用 dom 元素&lt;!-- 使用 ref 属性，为对应的 dom 元素添加引用的名称 --&gt; &lt;h3 ref=\"myH3Ref\"&gt; myRef 组件&lt;/h3&gt; &lt;!-- 点击调用getRef --&gt; &lt;button @click='getRef'&gt;获取 $refs 引用&lt;/button&gt; &lt;script&gt; export default { methods:{ getRef(){ // 通过 this.$refs.引用名称 // 可以得到 dom 元素引用 console.log(this.$refs.myH3Ref) // 操作 dom 元素，把文本颜色改为红色 this.$refs.myH3Ref.style.color='red' } } } &lt;/script&gt; 引用组件实例&lt;!-- 使用 ref 属性，为对应的组件添加引用的名称 --&gt; &lt;my-counter ref=\"counterRef\"&gt;&lt;/my-counter&gt; &lt;button @click='getRef'&gt;获取 $refs 引用&lt;/button&gt; &lt;script&gt; export default { methods:{ getRef(){ // 通过 this.$refs.引用名称 // 可以得到组件实例引用 console.log(this.$refs.counterRef) // 可以访问获取后的组件数据和方法 this.$refs.counterRef.count = 1 this.$refs.counterRef.add() } } } &lt;/script&gt; this.$nextTick(cb) 方法组件的 $nextTick(cb) 方法，会把 cb 回调推迟到下一个 DOM 更新周期之后执行，即在 DOM 更新完成后再执行回调，从而保证 cb 回调可以获取最新的 DOM 元素 methods: { showInput() { this.inputVisible = true // 对输入框的操作推迟到 DOM 更新完成之后 this.$nextTick(() =&gt; { this.$refs.input.focus() }) } } 动态插件vue 提供了一个内置的 &lt;component&gt; 组件，专门用来实现动态组件的渲染 &lt;script&gt; data(){ return { // 定义要渲染组件的名称 comName:'Left' } } &lt;/script&gt; &lt;!-- 通过 js 动态绑定指定的渲染组件 --&gt; &lt;component is:\"conName\" &gt;&lt;component&gt; &lt;!-- 点击 动态切换组件 --&gt; &lt;button @click=\"comName = 'Left'\"&gt;展示Left组件&lt;/button&gt; &lt;button @click=\"comName = 'Right'\"&gt;展示Right组件&lt;/button&gt; keep-alive在默认情况下，切换组件会将不需要的组件销毁，导致组件的数据清空，切换回来时数据不能还原到切换前 为了保持组件的状态可以使用 vue 内置的 &lt;keep-alive&gt; 组件 &lt;keep-alive&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt; &lt;/keep-alive&gt; 使用 &lt;keep-alive&gt; 组件后，动态切换组件时不需要的组件就会被缓存，切换回来时重新被激活 keep-alive 对应的生命周期函数 组件被激活时，触发组件的 deactived 生命周期函数 组件被销毁时，触发组件的 activated 生命周期函数 export default { activated(){ console.log('组件被激活了') } deactived(){ console.log('组件被销毁了') } } keep-alive 的 include 属性 include 属性用来指定，只有匹配名称的组件才会被缓存，其他销毁 &lt;keep-alive include=\"Left\"&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt; &lt;/keep-alive&gt; keep-alive 的 exclude 属性 功能与 include 相反，排除不缓存的组件 如果同时使用 include, exclude, 那么 exclude 优先于 includeinclude 和 exclude 避免混乱只用一个就好 插槽插槽（slot）是封装组件时，把不确定的，希望由用户指定部分定义为插槽 简单来讲，组件封装期间，为用户预留的内容的占位符。 基础用法封装组件时，用 &lt;slot&gt; 元素定义插槽，预留占位符 &lt;!-- my-com.vue --&gt; &lt;template&gt; &lt;p&gt; 这是 MyCom 组件的第一个 p标签 &lt;/p&gt; &lt;!-- 通过 slot 占位符，为用户预留位置 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;p&gt; 这是 MyCom 组件的最后的 p标签 &lt;/p&gt; &lt;/template&gt; 使用 &lt;my-com&gt; &lt;!-- 使用 my-com 组件时，为插槽指定具体内容 --&gt; &lt;p&gt; 这是用户自定义的 p标签 ~~~ &lt;/p&gt; &lt;my-com&gt; 如果在封装组件时没有预留 slot 任何插槽，用户自定义的内容不生效，会被丢弃 后备内容在封装组件时，可以为预留的 &lt;slot&gt; 插槽的提供后备内容（默认内容） &lt;slot&gt; &lt;p&gt; 这是后备内容的 p标签 ~~~ &lt;/p&gt; &lt;/slot&gt; 如果组件使用者没有为插槽提供任何的内容，后备内容就会生效用户提供内容后，后备内容就会被覆盖掉 具名插槽如果在封装组件时需要预留多个插槽节点，则需要为每个 &lt;slot&gt; 插槽指定具体的 name 名称。这种带有具体名称的插槽叫做“具名插槽”。 &lt;!-- my-com.vue --&gt; &lt;div class=\"container\"&gt; &lt;header&gt; &lt;!-- 希望页头放这里 --&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;!-- 希望主要内容放这里 --&gt; &lt;slot name=\"main\"&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;!-- 希望主要页脚放这里 --&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; 为具名插槽提供内容，在一个 &lt;template&gt; 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称 &lt;my-com&gt; &lt;!-- v-slot 的属性 要和希望放到 slot 插槽name属性名一致 --&gt; &lt;template v-solt:header&gt; &lt;h1&gt;头部 &lt;/h1&gt; &lt;/template&gt; &lt;template v-solt:main&gt; &lt;p&gt; 主要内容 &lt;/p&gt; &lt;/template&gt; &lt;template v-solt:footer&gt; &lt;p&gt; 页脚 &lt;/p&gt; &lt;/template&gt; &lt;/my-com&gt; 注意：没有指定 name 名称的插槽，会有隐含的名称叫做 “default”。 具名插槽的简写形式： (v-slot:) 替换为字符 #，例如 v-slot:header可以被简写为 #header 作用域插槽在封装组件过程中，为预留的 solt 插槽绑定 props 数据，叫做作用域插槽 数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定 &lt;template&gt; &lt;slot v-for=\"item in list\" :user='item'&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { list: [ { id: 1, name: 'Lily', state: true, }, { id: 2, name: 'Ben', state: false, }, { id: 3, name: 'Water', state: true, }, ], } }, } &lt;/script&gt; 可以使用 v-slot: 的形式，接收作用域插槽对外提供的数据 &lt;my-com&gt; &lt;template v-slot:default=\"scope\"&gt; &lt;p&gt;作用域插槽提供的数据： {{scope}}&lt;/p&gt; &lt;/template&gt; &lt;/my-com&gt; 接收到的数据 scope 是一个对象。 // scope 的内容 { 'user': { 'id': 1, 'name': 'Lily', 'state': true } } 在接收作用域插槽提供的数据时可以使用解构赋值。 &lt;my-com&gt; &lt;template #default=\"{user}\"&gt; &lt;p&gt;id：{{ user.id }}&lt;/p&gt; &lt;p&gt;name：{{ user.name }}&lt;/p&gt; &lt;p&gt;state：{{ user.state }}&lt;/p&gt; &lt;/template&gt; &lt;/my-com&gt; 自定义指令私有自定义指令在每个 vue 组件中，可以在 directives 节点下声明私有自定义指令 directives: { color:{ // 为绑定的元素设置红色字体 bind(el){ // el 是绑定此指令的 dom 对象 el.style.color='red' } } } 使用：需要加上 v- 前缀 &lt;!-- 上面声明的自定义指令名为 color --&gt; &lt;!-- 使用自定义指令名 color，需要加上 v- 前缀 --&gt; &lt;h1 v-color&gt;app组件&lt;/h1&gt; 动态绑值data:{ return{ color:'red' } } &lt;h1 v-color=\"color\"&gt;app组件&lt;/h1&gt; 通过 binding 获取指令的参数值directives: { color:{ bind(el,binding){ // el 是绑定此指令的 dom 对象 // 通过 binding 对象.value 属性获取动态的参数值 el.style.color=bing.value } } } update 函数bind 函数只调用 1 次：当指令第一次绑定到元素时调用，当 DOM 更新时 bind 函数不会被触发。 update 函数会在每次 DOM 更新时被调用 directives: { color:{ // 指令第一次绑定元素时调用 bind(el,binding){ // el 是绑定此指令的 dom 对象 // 通过 binding 对象.value 属性获取动态的参数值 el.style.color=bing.value } // 每次 dom 更新都调用 update(el,binding){ el.style.color=bing.value } } } 简写 insert 和update 函数中的逻辑完全相同，则对象格式的自定义指令可以简写成函数格式 directives: { color(el,binding){ el.style.color=bing.value } } 全局自定义指令全局共享的自定义指令需要通过 Vue.directive()进行声明 // 全局写法 Vue.directive('color', (el, binding) =&gt; { el.style.color = binding.value })) 注意事项 自定义指令使用时需要添加 v- 前缀 指令名如果是多个单词，要使用 camel-case 短横线命名方式，不要用 camelCase 驼峰命名 自定义指令三个函数里的 this 指向 window &lt;span v-big-number=\"n\"&gt;&lt;/span&gt; data() { return { n: 1 } }, directives: { // 添加引号才是对象键名完整写法 // 平时不加引号都是简写形式 // 遇到短横线的键名就必须添加引号 'big-number': { bind(el, binding) { console.log(this) // Window el.innerText = binding.value * 10 } } }","categories":[{"name":"vue","slug":"vue","permalink":"https://blog.luckjin.cool/categories/vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"vue","slug":"vue","permalink":"https://blog.luckjin.cool/tags/vue/"}]},{"title":"Git 代理问题","slug":"Git-代理问题","date":"2022-08-16T14:36:10.000Z","updated":"2022-08-23T04:41:00.629Z","comments":true,"path":"posts/9f85662a.html","link":"","permalink":"https://blog.luckjin.cool/posts/9f85662a.html","excerpt":"","text":"开 vpn 后 浏览器可以访问 github ，但是终端 git 却无法拉取代码解决方法：window10 打开设置–网络–代理，查看目前的端口: 给 git 设置代理 ,如vpn端口号为7890，则git设置代理为： git config --global http.proxy '127.0.0.1:7890' git config --global https.proxy '127.0.0.1:7890' 查看代理信息 git config --global --get http.proxy git config --global --get https.proxy 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy 获取网站的Favicon图标并显示在你的网页上owen0o0","categories":[{"name":"使用技巧","slug":"使用技巧","permalink":"https://blog.luckjin.cool/categories/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"git","slug":"git","permalink":"https://blog.luckjin.cool/tags/git/"},{"name":"小技巧","slug":"小技巧","permalink":"https://blog.luckjin.cool/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"vue 核心基础","slug":"vue的基础学习","date":"2022-08-15T14:38:54.000Z","updated":"2022-08-18T08:05:56.620Z","comments":true,"path":"posts/eb3fbbca.html","link":"","permalink":"https://blog.luckjin.cool/posts/eb3fbbca.html","excerpt":"","text":"vue 简介官方给出的概念：Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的前端框架 vue 的特性vue 框架的特性，主要体现在如下两方面： 数据驱动视图 在使用了 vue 的页面中，vue 会监听数据的变化，从而自动重新渲染页面的结构当页面数据发生变化时，页面会自动重新渲染 双向数据绑定 在填写表单时，双向数据绑定可以辅助开发者在不操作 DOM 的前提下，自动把用户填写的内容同步到数据源中 开发者不再需要手动操作 DOM 元素，来获取表单元素最新的值 MVVM 的工作原理ViewModel 作为 MVVM 的核心，是它把当前页面的数据源（Model）和页面的结构（View）连接在了一起。 当数据源发生变化时，会被 ViewModel 监听到，VM 会根据最新的数据源自动更新页面的结构 当表单元素的值发生变化时，也会被 VM 监听到，VM 会把变化过后最新的值自动同步到Model 数据源中 vue 的使用基本使用步骤 &lt;!-- 2. 声明一个被 vue dom 的容器 --&gt; &lt;div id=\"app\"&gt;{{name}}&lt;/div&gt; &lt;!-- 1. 导入 vue --&gt; &lt;script src=\"./lib/vue-2.6.12.js\"&gt;&lt;/script&gt; &lt;script&gt; // 3.创建 vue 实列对象 const vm = new Vue({ // 3.1指定 vm 要控制的容器区域 el: '#app', // 3.2指定 Model 数据源 data: { name: '张山 } }) &lt;/script&gt; vue 指令指令是 vue 开发中最基础、最常用、最简单的知识点。 内容渲染指令指令是 vue 开发中最基础、最常用、最简单的知识点。 v-text：v-text 指令会覆盖元素内默认的值。 {{ }} ：vue 提供的 {{ }} 语法，专门用来解决 v-text 会覆盖默认文本内容的问题。这种 {{ }} 语法的专业名称是插值表达式（英文名为：Mustache） v-html：v-text 指令和{{}}插值表达式只能渲染纯文本内容。v-html可以渲染包含 HTML 标签的字符串渲染到页面上 &lt;div id=\"app\"&gt; // 页面显示 张三 v-text 会覆盖原有的值 &lt;p v-text=\"name\"&gt;名字&lt;/p&gt; // 显示 年龄：18 &lt;p&gt;年龄：{{age}}&lt;/p&gt; // h4标题红色字体的 hello world // t-html会渲染标签 &lt;p v-html=\"info\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"./lib/vue-2.6.12.js\"&gt;&lt;/script&gt; &lt;script&gt; const vm = new Vue({ el: '#app', data: { age: 18, name: '张三', info: '&lt;h4 style=\"color:red;\"&gt;hello world&lt;/h4&gt;' } }) &lt;/script&gt; 在 vue 提供的模板渲染语法{{}}中，除了支持绑定简单的数据值之外，还支持Javascript 表达式的运算 // 简单运算 {{num + 1}} // 三元判断 {{ok ? 'yes' : 'no'}} // 字符串的方法 {{str.splist('').reversr().join('')}} // 字符串的拼接 &lt;div v-bind:id=\"'list' + id\"&gt;&lt;/div&gt; 属性绑定指令 v-bind：为元素的属性动态绑定属性值，简写形式（简写为英文的 : ） &lt;!-- 为图片动态绑定图片路径--&gt; &lt;div id=\"app\"&gt; &lt;img v-bing:src=\"imgUrl\" /&gt; &lt;!-- 简写 --&gt; &lt;img :src=\"imgUrl\" /&gt; &lt;/div&gt; &lt;script src=\"./lib/vue-2.6.12.js\"&gt;&lt;/script&gt; &lt;script&gt; const vm = new Vue({ el: '#app', data: { imgUrl:'./img/1.png' } }) &lt;/script&gt; 事件绑定指令 v-on 事件绑定指令，用来辅助程序员为 DOM 元素绑定事件监听，简写形式（简写为英文的 @ ）。通过 v-on 绑定的事件处理函数，需要在 methods 节点中进行声明： &lt;div id=\"app\"&gt; &lt;button v-on:click=\"add\"&gt;按钮1&lt;/button&gt; &lt;!-- 简写 --&gt; &lt;button @click=\"add\"&gt;按钮2&lt;/button&gt; &lt;/div&gt; &lt;script src=\"./lib/vue-2.6.12.js\"&gt;&lt;/script&gt; &lt;script&gt; const vm = new Vue({ el: '#app', methods:{ add(){ // 函数处理 } } }) &lt;/script&gt; 原生 DOM 对象有 onclick、oninput、onkeyup 等原生事件，替换为 vue 的事件绑定形式后，分别为：v-on:click、v-on:input、v-on:keyup $ event 是 vue 提供的特殊变量，用来表示原生的事件参数对象 event。$event 可以解决事件参数对象event被覆盖的问题 事件修饰符 事件修饰符 说明 .prevent 阻止默认行为，如 a 链接跳转、表单提交 .stop 阻止事件冒泡 .once 绑定的事件只触发 1 次 .capture 以捕获模式触发事件处理函数 .self 只有在 event.target 是当前元素自身时触发事件处理函数 .passive 事件的默认行为立即执行，无需等待事件回调执行完毕 &lt;a href=\"www.baidu.com\" @click.prevent=\"fn\"&gt;阻止链接跳转&lt;/a&gt; 按键修饰符在监听键盘事件时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符 &lt;!-- 按下回车 触发 submit() 函数 --&gt; &lt;input type=\"text\" @keyup.enter=\"submit\" /&gt; &lt;!-- 按下esc 触发 back() 函数 --&gt; &lt;input type=\"text\" @keyup.esc=\"back\" /&gt; 双向绑定指令 v-model 双向数据绑定指令，用来辅助开发者在不操作 DOM 的前提下，快速获取表单的数据。 经常用于表单元素如 input，textarea，select 。 &lt;p&gt;{{ username }}&lt;/p&gt; &lt;input type=\"text\" v-model:value=\"username\" /&gt; &lt;input type=\"text\" v-model=\"username\" /&gt; &lt;p&gt;{{ province }}&lt;/p&gt; &lt;select v-model=\"province\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"1\"&gt;北京&lt;/option&gt; &lt;option value=\"2\"&gt;上海&lt;/option&gt; &lt;option value=\"3\"&gt;广州&lt;/option&gt; &lt;/select&gt; v-model 指令修饰符 修饰符 作用 示例 .number 将用户输入转为数值类型 &lt;input v-model.number=\"age\" /&gt; .trim 删除输入的首尾空白字符 &lt;input v-model.trim=\"msg\"&gt; .lazy 当失去焦点时，才更新数据，类似防抖 &lt;input v-model.lazy=\"msg\"&gt; 条件渲染指令v-if，v-show：条件渲染指令用来辅助开发者按需控制 DOM 的显示与隐藏 v-show 的原理是：动态为元素添加或移除 display: none 样式，来实现元素的显示和隐藏 如果要频繁的切换元素的显示状态，用 v-show 性能会更好 v-if 的原理是：每次动态创建或移除元素，实现元素的显示和隐藏 如果刚进入页面的时候，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时 v-if 性能更好 在实际开发中，绝大多数情况，不用考虑性能问题，直接使用 v-if 就好了！！！ v-if 指令在使用的时候，有两种方式： 直接给定一个布尔值 true 或 false &lt;p v-if=\"true\"&gt;被 v-if 控制的元素&lt;/p&gt; 给 v-if 提供一个判断条件，根据判断的结果是 true 或 false，来控制元素的显示和隐藏 &lt;p v-if=\"type === 'A'\"&gt;良好&lt;/p&gt; 列表渲染指令v-for： 列表渲染指令，用来辅助开发者基于一个数组来循环渲染一个列表结构。v-for 指令需要使用 item in datas 形式的特殊语法，其中： datas是待循环的数组 item 是被循环的每一项 v-for 指令还支持一个可选的第二个参数，即当前项的索引。语法格式为 (item, index) in items 使用 key 维护列表的状态 当列表的数据变化时，默认情况下，vue 会尽可能的复用已存在的DOM 元素，从而提升渲染的性能。但这种默认的性能优化策略，会导致有状态的列表无法被正确更新。 为了给 vue 一个提示，以便它能跟踪每个节点的身份，从而在保证有状态的列表被正确更新的前提下，提升渲染的性能。此时，需要为每项提供一个唯一的 key 属性 key 是虚拟 DOM 对象的标识，可提高页面更新渲染的效率。当数据变化时，Vue 会根据新数据生成新的虚拟 DOM，随后进行新旧虚拟 DOM 的差异比较 key 的注意事项： key 的值只能是字符串或数字类型 key 的值必须具有唯一性（即：key 的值不能重复） 建议把数据项 id 属性的值作为 key 的值（因为 id 属性的值具有唯一性） 使用 index 的值当作 key 的值没有意义（因为 index 的值不具有唯一性） 建议使用 v-for 指令时一定要指定 key 的值（既提升性能、又防止列表状态紊乱 过滤器过滤器（Filters）是 vue 为开发者提供的功能，常用于文本的格式化。过滤器可以用在两个地方：插值表达式和 v-bind 属性绑定。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道符”进行调用 注：vue3 剔除了过滤器相关的功能 &lt;!-- 在插值表达式通过管道符 | 调用 capitalize 过滤器 对 message 格式化 --&gt; &lt;p&gt;{{message | capitalize }}&lt;/p&gt; &lt;!-- 在 v-bind 通过管道符 | 调用 formatId 过滤器 对 rawId 格式化 --&gt; &lt;div :id=\"rawId | formatId\"&gt;&lt;/div&gt; // 定义私有过滤器 // new vue() 实例所控制的 el 区域内使用 filters: { capitalize(str) { return str.charAt(0).toUpperCase() + str.slice(1) } } // 定义全局过滤器 Vue.filter(\"capitalize\",(str)=&gt;{ return str.charAt(0).toUpperCase() + str.slice(1) }) 如果私有过滤器和全局过滤器冲突，按照就近原则调用私有过滤器。 连续调用多个过滤器 过滤器从左往右调用，将前一个的结果交给下一个过滤器继续处理 &lt;p&gt;{{ message | capitalize | capitalize }}&lt;/p&gt; 传递参数 &lt;p&gt;{{ message | capitalize(arg1,arg2) }}&lt;/p&gt; &lt;script&gt; // 第一个参数永远都是管道符的值 Vue.filter('capitalize',(val,arg1,arg2)=&gt;{ ... }) &lt;/script&gt; watch 侦听器watch 侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作。 const vm = new Vue({ el: '#app', data: { name: '张三', }, watch:{ // 监听 name 的表化 // newVal 的变化后的值， // oldVal 的变化之前的值 name(newVal,oldVal){ ... } } }) 默认情况下，组件在初次加载完毕后不会调用 watch 侦听器。如果想让 watch 侦听器立即被调用，则需要使用 immediate 选项 watch:{ // 监听 name 的表化 // newVal 的变化后的值， // oldVal 的变化之前的值 name(newVal,oldVal){ ... }, immediate:true } 如果 watch 侦听的是一个对象，如果对象中的属性值发生了变化，则无法被监听到。此时需要使用 deep 选项 const vm = new Vue({ el: '#app', data: { info:{ name: '张三' } }, watch:{ info:{ handler(newVal,oldVal){ ... } }, deep:true } } }) 计算属性计算属性指的是通过一系列计算之后，最终得到一个属性值，可以被模板结构和 methods 方法使用 &lt;div id=\"app\"&gt; &lt;div class=\"box\" :style=\"{ backgroundColor: rgb }\"&gt; {{ rgb }} &lt;/div&gt; &lt;/div&gt; const vm = new Vue({ el: '#app', data: { r: 0, g: 0, b: 0 }, computed:{ rgb(){return `rgb( ${this.r}, ${this.g}, ${this.b} )` } } }) 特点： 定义的时候，要被定义为“方法” 在使用计算属性的时候，当普通的属性使用即可 好处： 实现了代码的复用 只要计算属性中依赖的数据源变化了，则计算属性会自动重新求值！","categories":[{"name":"vue","slug":"vue","permalink":"https://blog.luckjin.cool/categories/vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vue","slug":"vue","permalink":"https://blog.luckjin.cool/tags/vue/"}]},{"title":"webpack基础","slug":"webpack基础","date":"2022-08-14T13:33:49.000Z","updated":"2022-08-24T02:34:38.028Z","comments":true,"path":"posts/8b27fb24.html","link":"","permalink":"https://blog.luckjin.cool/posts/8b27fb24.html","excerpt":"","text":"前端工程化前端开发 模块化（js 的模块化、css 的模块化、资源的模块化） 组件化（复用现有的 UI 结构、样式、行为） 规范化（目录结构的划分、编码规范化、接口规范化、文档规范化、 Git 分支管理） 自动化（自动化构建、自动部署、自动化测试） 前端工程化指的是：在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。 前端工程化的解决方案 早期： grunt https://www.gruntjs.net/ gulp https://www.gulpjs.com.cn/ 目前主流 webapck https://www.webpackjs.com/ parcel https://zh.parceljs.org/ webpack的基本使用主要功能：它提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端JavaScript 的兼容性、性能优化等强大的功能 好处：让程序员把工作的重心放到具体功能的实现上，提高了前端开发效率和项目的可维护性。注意：目前 Vue，React 等前端项目，基本上都是基于 webpack 进行工程化开发的。 安装 webpack项目终端安装 npm install webpack@5.42.1 webpack-cli@4.7.2 -D -D 是 --save-dev 的缩写，表示开发时依赖，只在项目开发阶段用到。 -S 是 --save 的缩写，表示运行时依赖，即项目打包发布运行时要用到。 配置 webpack 在项目根目录中，创建 webpack.config.js 的 webpack 配置文件，并初始化的基本配置： module.exports = { // mode 用于指定构建模式，可选值有 development 和 production mode: 'development', } 在 package.json 文件的 scripts 节点下，新增 dev 脚本： \"scripts\" :{ // 配置好后就能通过 npm run dev 命令执行打包过程 \"dev\": \"webpack\" } 在终端中运行 npm run dev 命令，即可启动 webpack 进行项目的打包构建 mode 的可选值webpack.config.js 中mode 节点的可选值有两个 development 开发环境 不会对打包生成的文件进行代码压缩和性能优化 打包速度快，适合在开发阶段使用 production 生产环境 会对打包生成的文件进行代码压缩和性能优化 打包速度很慢，仅适合在项目发布阶段使用 webpack.config.js 文件的作用webpack.config.js 是 webpack 的配置文件。webpack 在真正开始打包构建之前，会先读取这个配置文件，从而基于给定的配置，对项目进行打包 webpack 中的默认约定在 webpack 4.x 和 5.x 版本中，默认约定： 默认打包入口文件为 src/index.js 默认输出文件路径为 dist/main.js 自定义打包的入口与出口在 webpack.config.js 配置文件中，通过 entry 节点指定打包的入口。通过 output 节点指定打包的出口。 const path = require('path') module.exports = { // 打包文件的入口文件路径 entry: path.join(__dirname, './src/index.js'), output: { // 输出文件的存放路径 path: path.join(__dirname, './dist'), // 输出文件的名称 filename: 'bundle.js', }, } webpack 插件webpack-dev-serverwebpack-dev-server 让 webpack 能监听项目源码的变化，从而自动打包构建。 安装 npm install webpack-dev-server@3.11.2 -D 配置： 修改 package.json -&gt; scripts 的 dev 命令： \"scripts\": { \"dev\": \"webpack serve\" } 运行 npm run dev 命令，重新打包项目 浏览器访问 http://localhost:8080 地址，查看打包效果 打包生成的文件存放 配置了 webpack-dev-server 之后，打包生成的文件存放到了内存中 不再根据 output 节点指定的路径，存放到实际的物理磁盘上 提高了实时打包输出的性能，因为内存比物理磁盘速度快很多 生成到内存中的文件的访问 webpack-dev-server 生成的文件默认放在项目根目录中，是虚拟不可见的。 在 / 后跟上要访问的文件名称，即可访问内存中的文件 如 127.0.0.1/bundle.js 表示访问 webpack-dev-server 生成到内存中的 bundle.js 文件 html-webpack-pluginhtml-webpack-plugin 是 webpack 中的 HTML 插件，可以通过此插件自定制 index.html 页面的内容。 安装 npm install html-webpack-plugin@5.3.2 -D **配置 ** 在 webpack.config.js 进行配置： const HtmlPlugin = require('html-webpack-plugin') const htmlPlugin = new HtmlPlugin({ template: './src/index.html', // 指定原文件的路径 filename: './index.html' // 指定生成文件的路径 }) module.exports =&gt; { mode: 'development', plugins: [htmlPlugin] } html-webpack-plugin 生成的文件 通过 html-webpack-plugin 复制到项目根目录中的 index.html 页面，也被放到内存中 生成的 index.html 页面，自动注入打包的 bundle.js 文件 devServer 节点在 webpack.config.js 配置文件中，可以通过 devServer 节点对 webpack-dev-server 插件进行更多的配置 devServer: { open: true, // 初次打包完成后，自动打开浏览器 host: '127.0.0.1', // 访问地址 port: 80 // 访问端口号 } webpack 中的 loader (加载器)在实际开发过程中，webpack 默认只能打包处理以 .js 后缀名结尾的模块。其他非 .js 后缀名结尾的模块，webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错 loader 加载器的作用：协助 webpack 打包处理特定的文件模块。比如： css-loader 可以打包处理 .css 相关的文件 less-loader 可以打包处理 .less 相关的文件 babel-loader 可以打包 处理 webpack 无法处理的高级 JS 语法 loader 的调用过程 打包 css 文件 运行 npm i style-loader@3.0.0 css-loader@5.2.6 -D 命令，安装 loader 在 webpack.config.js 文件的 module-&gt;rules 数组添加规则： module: { rules: [{ test: /\\.css$/, use: ['style-loader', 'css-loader'] }] } test 表示匹配的文件类型，use 表示对应调用的 loader use 数组的 loader 顺序是固定的 loader 调用顺序是从后往前 打包 less 文件 运行 npm i less-loader@10.0.1 less@4.1.1 -D 命令 在 webpack.config.js 文件的 module-&gt;rules 数组添加规则 module: { rules: [{ test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] }] } limit 用于指定图片大小，单位是 byte 只有 &lt;= limit 大小的图片才会被转为 base64 格式 (opens new window)的图片 打包 js 文件的高级语法 运行 npm i babel-loader@8.2.2 @babel/core@7.14.6 @babel/plugin-proposal-decorators@7.14.5 -D 安装 babel 在 webpack.config.js 文件的 module-&gt;rules 数组添加规则： module: { rules: [{ test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ }] } 配置 babel：在项目根目录下，创建名为 babel.config.js 的配置文件，定义 Babel 的配置项： module.exports = { // 声明 babel 可用的插件 plugins: [['@babel/plugin-proposal-decorators', { legacy: true }]], } 打包发布项目开发完成之后，需要使用webpack 对项目进行打包发布 开发环境下，打包生成的文件存放于内存中，无法获取到最终打包生成的文件 开发环境下，打包生成的文件不会进行代码压缩和性能优化 为了让项目能够在生产环境中高性能的运行，因此需要对项目进行打包发布。 配置 webpack 的打包发布在 package.json 文件的 scripts 节点，新增 build 命令： \"scripts\": { \"dev\": \"webpack serve\", \"build\": \"webpack --mode production\" } --model 指定 webpack 的运行模式，会覆盖 webpack.config.js 中的 model 选项 把 js 文件统一生成到文件夹在 webpack.config.js 配置文件的 output 节点中，进行配置 ouput: { path: path.join(__dirname, 'dist'), // 将 bundle.js 文件存放到 dist 目录的 js 子目录中 filename: 'js/bundle.js', } 把图片统一生成到 image 目录修改 webpack.config.js 中的 url-loader 配置项，新增 outputPath 选项指定图片文件的输出路径： { test: /\\.jpg|png|gif$/, use: { loader: 'url-loader', options: { limit: 23333, // 指明生成的图片存到 dist 目录下的 image 子目录中 outputPath: 'image' } } } 自动清理 dist 目录下的旧文件 安装 clean-webpack-plugin 插件 npm install clean-webpack-plugin@3.0.0 -D 在 webpack.config.js 文件中进行配置： const { CleanWebpackPlugin } = require('clean-webpack-plugin') // plugins 节点挂载 CleanWebpackPlugin 实例对象 plugins: [htmlPlugin, new CleanWebpackPlugin()] 企业级项目打包发布 企业级项目打包发布的流程更复杂： 生成打包报告，根据报告分析具体的优化方案 Tree-Shaking 为第三方库启用 CDN 加载 配置组件的按需加载 开启路由懒加载 自定制首页内容 打包后双击 index.html 查看效果项目 npm run build 打包之后，默认情况下在本地双击 dist/index.html 是无法看到项目效果的，如果想要看到效果需要进行配置。 vue.config.js文件将 publicPath 改为 './' 即可，默认为 '/' 。 module.exports = { publicPath: './', } Source MapSource Map 就是一个信息文件，里面储存着位置信息，它存储着压缩混淆后的代码，所对应的转换前的位置。当我们运行打包生成的代码出错时，就能通过报错信息定位到源码的出错位置 webpack.config.js 中添加如下的配置 // webpack.config.js 文件 module.exports = { mode: 'development', // 开发环境 eval-source-map // 生产环境 nosources-source-map devtool: 'eval-source-map', } 开发环境下： devtool 设置为 eval-source-map 显示源码报错的行数 可以精准定位到具体的错误行 生产环境下： 关闭 Source Map 或把 devtool 设置为 nosources-source-map 只会显示源码中报错的行数，不会暴露源码 防止源码泄露，提高网站安全性","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://blog.luckjin.cool/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"ES6模块化和异步编程的学习","slug":"ES6模块化和异步编程的学习","date":"2022-08-12T14:34:52.000Z","updated":"2022-08-16T14:09:21.957Z","comments":true,"path":"posts/b08fe5f9.html","link":"","permalink":"https://blog.luckjin.cool/posts/b08fe5f9.html","excerpt":"","text":"ES6 模块化ES6 模块化规范是浏览器端与服务器端通用的模块化开发规范。它的出现极大的降低了前端开发者的模块化学习成本，开发者不需再额外学习 AMD、CMD 或 CommonJS 等模块化规范。 ES6 模块化规范中定义： 每个 js 文件都是一个独立的模块 导入其它模块成员使用 import 关键字 向外共享模块成员使用 export 关键字 ES6 的模块化3种用法默认导出与默认导入按需导入与导出直接导入默认导出的语法： export default 默认导出的成员 //01_test.js // 定义成员和方法 let n1 = 10 let n2 = 20 function show(){} // 默认导出 export default{ n1, n2, show } 默认导入的语法：import 接收名称 from '模块标志符' 默认导入时的接收名称可以任意名称，只要是合法的成员名称即可 // 从 01_test.js 模块导入共享的成员 import test from './01_test.js' // 输出 { n1:10,n2:20,show:[funtion:show] } console.log(test) 每个模块中，只允许使用唯一的一次 export default，否则会报错！ 按需导出的语法： export 按需导出的成员 // 02_test.js // 向外按需导出变量 s1 export let s1 = 'abc' // 向外按需导出变量 s2 export let s1 = 123 // 向外按需导出方法 say export function say() {} 按需导入的语法： import { s1 } from '模块标识符' // 导入 02_test.js 模块成员 import {s1,s2,say} from './02test.js' // 输出 abc console.log(s1) // 输出 123 console.log(s2) // 输出 [funtion:say] console.log(say) 按需导出与按需导入的注意事项 每个模块中可以使用多次按需导出 按需导入的成员名称必须和按需导出的名称保持一致 按需导入时，可以使用 as 关键字进行重命名 按需导入可以和默认导入一起使用 如果只想单纯地执行某个模块中的代码，并不需要得到模块中向外共享的成员。此时，可以直接导入并执行模块代码 // 03_test.js // 执行一个循环 for(let i = 0;i&lt;3;i++){ console.log(i) } // 导入 import './03_test.js' // 直接运行此文件 // 输出 0，1，2，3，....10 Promise回调地狱多层回调函数的相互嵌套，就形成了回调地狱 setTimeout(() =&gt; { console.log(\"延迟1秒\"); setTimeout(() =&gt; { console.log(\"延迟2秒\"); setTimeout(() =&gt; { console.log(\"延迟2秒\"); }, 3000); }, 2000); }, 1000); 回调地狱的缺点： 代码耦合性太强，牵一发而动全身，难以维护 大量冗余的代码相互嵌套，代码的可读性变差 为了解决回调地狱的问题，ES6（ECMAScript 2015）中新增了 Promise 的概念。 Promise 的基本概念 Promise 是一个构造函数 我们可以创建 Promise的实例 const p = ne w Promise() new 出来的 Promise 实例对象，代表一个异步操作 Promise.prototype 上包含一个 .then() 方法 每一次 new Promise() 构造函数得到的实例对象， 都可以通过原型链的方式访问到 .then() 方法，例如 p.then() .then() 方法用来预先指定成功和失败的回调函数 p.then(成功的回调函数，失败的回调函数) p.then(result =&gt; { }, error =&gt; { }) 调用 .then() 方法时，成功的回调函数是必选的、失败的回调函数是可选的 基于回调函数按顺序读取文件内容基于 then-fs 读取文件内容import fs from \"fs\"; // 读文件 1.txt fs.readFile(\"./files/1.txt\", \"utf8\", (err, r1) =&gt; { if (err) return console.log(err.message); console.log(r1); // 读文件 2.txt fs.readFile(\"./files/2.txt\", \"utf8\", (err, r2) =&gt; { if (err) return console.log(err.message); console.log(r2); // 读文件 3.txt fs.readFile(\"./files/3.txt\", \"utf8\", (err, r3) =&gt; { if (err) return console.log(err.message); console.log(r3); }); }); }); 调用 then-fs 提供的 readFile() 方法，可以异步地读取文件的内容，它的返回值是 Promise 的实例对象。因此可以调用 .then() 方法为每个 Promise 异步操作指定成功和失败之后的回调函数 Promise 支持链式调用，从而来解决回调地狱的问题 import thenFs from 'then-fs' // Promise 支持链式调用，从而来解决回调地狱的问题 thenFs // 返回值是 promise 的实列对象 .readFile(\"./files/1.txt\", \"utf8\") // 通过 .then 为第一个 promise 实例对象指定成功后的回调函数 .then((r1) =&gt; { console.log(r1); // 在第一个 .then 中返回一个新的 promise 对象 return thenFs.readFile(\"./files/2.txt\", \"utf8\"); }) // 继续调用 .then ，为上一个 .then 的返回值 (新的实例对象) // 指定成功后的回调函数 .then((r2) =&gt; { console.log(r2); return thenFs.readFile(\"./files/3.txt\", \"utf8\"); }) // 同理 继续调用 .then ，为上一个 .then 的返回值 (新的实例对象) .then((r3) =&gt; { console.log(r3); }) // 通过 .catch 捕获错误 // 前面的错误导致后续的 .then 无法正常执行 // 可以将.catch 的调用提前 .catch((err) =&gt; { console.log(err.message); }); Promise.all() 与 Promise.race() 方法Promise.all() 方法Promise.race() 方法Promise.all() 方法会发起并行的 Promise 异步操作，等所有的异步操作全部结束后才会执行下一步的 .then操作（等待机制） import thenFs from \"then-fs\"; // 定义一个数组 存放异步读文件操作 const promiseArr = [ thenFs.readFile(\"./files/1.txt\", \"utf8\"), thenFs.readFile(\"./files/2.txt\", \"utf8\"), thenFs.readFile(\"./files/3.txt\", \"utf8\"), ]; // 将数组 作为 promise.all() 参数 Promise.all(promiseArr) .then(([r1, r2, r3]) =&gt; { // 所有文件读取成功 （等待机制） // 输出 r1 ，r2 ，r3 文件的内容 console.log(r1, r2, r3); }) .catch((err) =&gt; { console.log(err.message); }); // 数组中 Promise 实例的顺序， // 就是最终结果的顺序！ Promise.race() 方法会发起并行的 Promise 异步操作，只要任何一个异步操作完成，就立即执行下一步的.then 操作（赛跑机制） import thenFs from \"then-fs\"; // 定义一个数组 存放异步读文件操作 const promiseArr = [ thenFs.readFile(\"./files/1.txt\", \"utf8\"), thenFs.readFile(\"./files/2.txt\", \"utf8\"), thenFs.readFile(\"./files/3.txt\", \"utf8\"), ]; // 将数组 作为 promise.race() 参数 Promise.race(promiseArr) .then((results) =&gt; { // 只要任何一个异步操作完成 就执行回调函数（赛跑机制） // 例如：文件2.txt 先读取完 // 就输出 2.txt 的文件内容 结束 console.log(results); }) .catch((err) =&gt; { console.log(err.message); }); async/awaitasync/await 是 ES8（ECMAScript 2017）引入的新语法，用来简化 Promise 异步操作 .then 链式调用的优点：解决了回调地狱的问题 .then 链式调用的缺点：代码冗余、阅读性差、不易理解 async/await 简化 Promise 异步操作的使用 import thenFs from \"then-fs\"; // 按顺序读取文件 1，2，3 的内容 async function getAllFile() { const r1 = await thenFs.readFile(\"./files/1.txt\", \"utf8\"); console.log(r1); const r2 = await thenFs.readFile(\"./files/2.txt\", \"utf8\"); console.log(r2); const r3 = await thenFs.readFile(\"./files/3.txt\", \"utf8\"); console.log(r3); } getAllFile(); async/await 的使用注意事项 如果在 function 中使用了 await，则 function 必须被 async 修饰 在 async 方法中，第一个 await 之前的代码会同步执行，await 之后的代码会异步执行 EventLoop（事件循环）JavaScript 主线程从“任务队列”中读取异步任务的回调函数，放到执行栈中依次执行。这个过程是循环不断的，所以整个的这种运行机制又称为 EventLoop（事件循环）。 Eventloop 例子 结合 EventLoop 分析输出的顺序import thenFs from \"then-fs\"; console.log('A'); thenFs.readFile(\"./files/3.txt\", \"utf8\").then(dataStr=&gt;{ console.log('B'); }) setTimeout(()=&gt;{ console.log('C'); },0) console.log('D');正确的输出结果：查看答案 ADCBA 和 D 属于同步任务。会根据代码的先后顺序依次被执行C 和 B 属于异步任务。它们的回调函数会被加入到任务队列中，等待主线程空闲时再执行 宏任务和微任务JavaScript 把异步任务又做了进一步的划分，异步任务又分为两类，分别是： 宏任务（macrotask） 异步 Ajax 请求、 setTimeout、setInterval、 文件操作 其它宏任务 微任务（microtask） Promise.then、.catch 和 .finally process.nextTick 其它微任务 宏任务和微任务的执行顺序 每一个宏任务执行完之后，都会检查是否存在待执行的微任务，如果有，则执行完所有微任务之后，再继续执行下一个宏任务。 宏任务和微任务日常例子 去银行办业务的场景小云和小腾去银行办业务。首先，需要取号之后进行排队宏任务队列假设当前银行网点只有一个柜员，小云在办理存款业务时，小腾只能等待单线程，宏任务按次序执行小云办完存款业务后，柜员询问他是否还想办理其它业务？当前宏任务执行完，检查是否有微任务小云告诉柜员：想要买理财产品、再办个信用卡、最后再兑换点马年纪念币？执行微任务，后续宏任务被推迟小云离开柜台后，柜员开始为小腾办理业务所有微任务执行完毕，开始执行下一个宏任务 宏任务和微任务练习例子 setTimeout(function () { console.log(1); }); new Promise(function (resolve) { console.log(2); resolve(); }).then(function () { console.log(3); }); console.log(4);查看答案 2431分析：先执行所有的同步任务第 6 行 ，第 12 行注：promise 是同步 ，promise.then 回调才是异步在执行所有的微任务第9行再执行下一个宏任务第2行","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.luckjin.cool/categories/JavaScript/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"MySql+Node.js","slug":"MySql-Node-js","date":"2022-08-11T13:23:50.000Z","updated":"2022-08-16T14:09:36.406Z","comments":true,"path":"posts/43bbf857.html","link":"","permalink":"https://blog.luckjin.cool/posts/43bbf857.html","excerpt":"","text":"数据库的数据组织结构数据的组织结构分为数据库(database)、数据表(table)、数据行(row)、字段(field)这 4 大部分组成。 实际开发中库、表、行、字段的关系 在实际项目开发中，一般情况下，每个项目都对应独立的数据库。 不同的数据，要存储到数据库的不同表中，例如：用户数据存储到 users 表中，图书数据存储到 books 表中。 每个表中具体存储哪些信息，由字段来决定，例如：我们可以为 users 表设计 id、username、password 这 3 个字段。 表中的行，代表每一条具体的数据 使用 SQL 管理数据库SQL（英文全称：Structured Query Language）是结构化查询语言，专门用来访问和处理数据库的编程语言。能够让我们以编程的形式，操作数据库里面的数据。 SQL 是一门数据库编程语言 使用 SQL 语言编写出来的代码，叫做 SQL 语句 SQL 语言只能在关系型数据库中使用（例如 MySQL、Oracle、SQL Server）。非关系型数据库（例如 Mongodb）不支持 SQL 语言 SQL 能做什么 从数据库中查询数据向数据库中插入新的数据更新数据库中的数据从数据库删除数据可以创建新数据库可在数据库中创建新表可在数据库中创建存储过程、视图etc 重点掌握使用 SQL 查询数据（select） 、插入数据（insert into） 、更新数据（update） 、删除数据（delete） 查询数据（select）插入数据（insert into）更新数据（update）删除数据（delete）SELECT 语句用于从表中查询数据。执行的结果被存储在一个结果表中（称为结果集 注意：SQL 语句中的关键字对大小写不敏感。SELECT 等效于 select，FROM 等效于 from -- 这是注释 -- 从 from 指定的 表中 ，查询所有的数据 * 表示所有列 select * from 表名称 -- 从 from 指定的表中，查询出指定 列名称（字段）的数据 select 列名称 from 表名称INSERT INTO 语句用于向数据表中插入新的数据行 -- 语法解读：向指定的表，插入如下几列的数据，列的值通过 values 指定 -- 列和值要一一对应，多个之间用逗号隔开 insert into table_name (列1，列2，...) values (值1，值2，...)Update 语句用于修改表中的数据 -- update 指定表 -- set 指定列对应的新值 -- where 指定更新的条件 update 表名称 set 列名称 = 新值 where 列名称 = 某值-- 从指定的表，根据 where 条件 ，删除对应数据行 delete from 表名称 where 列名称 = 值 SQL 的 WHERE 子句WHERE 子句用于限定选择的标准。在 SELECT、UPDATE、DELETE 语句中，皆可使用 WHERE 子句来限定选择的标准。 SQL 的 AND 和 OR 运算符 AND 表示必须同时满足多个条件，相当于 JavaScript 中的 &amp;&amp; 运算符，例如 if (a !== 10 &amp;&amp; a !== 20) OR 表示只要满足任意一个条件即可，相当于 JavaScript 中的 || 运算符，例如 if(a !== 10 || a !== 20) SQL 的 ORDER BY 子句 ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 -- 对 users 表中的数据，按照 id 字段进行降序排序 select * from users order id desc -- 多重排序 -- 对 users 表中的数据，先按照 status 字段进行降序排序 -- 再按照 username 的字母顺序，进行升序排序 asc 表示升序 select * from users order by status desc, username asc SQL 的 COUNT(*) 函数COUNT(*) 函数用于返回查询结果的总数据条数 select count(*) from 表名称 -- 查询 users 表中 status 为 0 的总数据条数： select count(*) from where status=0 -- 使用 AS 为列设置别名 select count(*) AS total from where status=0 Node 操作 mysql配置 mysql 模块安装 mysql 模块 npm i mysql // 导入 const mysql =require('mysql') // 建立链接 const db =mysql.createPool({ // 数据库的 ip 地址 host:'127.0.0.1', // 用户名 user:'root', // 密码 password:'root', // 指定要操作的数据库 database:'tess', }) // 检测 mysql 模块是否正常工作 // 调用 db.query() 函数，指定要执行的 SQL 语句， // 通过回调函数拿到执行的结果 db.query('select 1', (err, results) =&gt; { if (err) return console.log(err.message) console.log(results) }) // 操作数据库 // 查询 db.query('select * from users', (err, results) =&gt; { ... }) // 插入 // ? 表示占位符 const sql = 'insert into users values(?, ?)' // 使用数组的形式为占位符指定具体的值 db.query(sql, [username, password], (err, results) =&gt; { if (err) return console.log(err.message) if (results.affectedRows === 1) console.log('插入成功') }) // 更新 const sql = 'update users set username=?, password=? where id=?' db.query(sql, [username, password, id], (err, results) =&gt; { ... }) // 快捷语法 const user = {id:7,username:'Bruce',password:'55520'} const sql = 'update users set ? where id=?' db.query(sql, [user, user.id], (err, results) =&gt; { ... }) // 删除 const sql = 'delete from users where id=?' db.query(sql, id, (err, results) =&gt; { ... }) //使用 delete 语句会真正删除数据， //保险起见，使用标记删除的形式，模拟删除的动作。 //即在表中设置状态字段，标记当前的数据是否被删除。 db.query('update users set status=1 where id=?', 7, (err, results) =&gt; { ... }) web开发模式服务端渲染 服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接动态生成的。因此客户端不需要使用 Ajax 额外请求页面的数据。 app.get('/index.html', (req, res) =&gt; { const user = { name: 'Bruce', age: 29 } const html = `&lt;h1&gt;username:${user.name}, age:${user.age}&lt;/h1&gt;` res.send(html) }) 优点： 前端耗时短。浏览器只需直接渲染页面，无需额外请求数据。 有利于 SEO。服务器响应的是完整的 HTML 页面内容，有利于爬虫爬取信息。 缺点： 占用服务器资源。服务器需要完成页面内容的拼接，若请求比较多，会对服务器造成一定访问压力。 不利于前后端分离，开发效率低。 前后端分离 前后端分离的开发模式，依赖于 Ajax 技术的广泛应用。后端只负责提供 API 接口，前端使用 Ajax 调用接口。 优点： 开发体验好。前端专业页面开发，后端专注接口开发。 用户体验好。页面局部刷新，无需重新请求页面。 减轻服务器的渲染压力。页面最终在浏览器里生成。 缺点： 不利于 SEO。完整的 HTML 页面在浏览器拼接完成，因此爬虫无法爬取页面的有效信息。Vue、React 等框架的 SSR（server side render）技术能解决 SEO 问题。 如何选择 企业级网站，主要功能是展示，没有复杂交互，且需要良好的 SEO，可考虑服务端渲染 后台管理项目，交互性强，无需考虑 SEO，可使用前后端分离 为同时兼顾首页渲染速度和前后端分离开发效率，可采用首屏服务器端渲染+其他页面前后端分离的开发模式 身份认证Session 认证机制服务端渲染推荐使用 Session 认证机制 Session 工作原理 Express 中使用 Session 认证 安装 npm install express-session 配置中间件 const session = require('express-session') app.use( session({ secret: 'fantsy06', // secret 的值为任意字符串 resave: false, saveUninitalized: true, }) ) 向 session 中存数据 // 中间件配置成功后，可通过 req.session 访问 session 对象，存储用户信息 app.post('/api/login', (req, res) =&gt; { req.session.user = req.body req.session.isLogin = true res.send({ status: 0, msg: 'login done' }) }) 从 session 取数据 app.get('/api/username', (req, res) =&gt; { if (!req.session.isLogin) { return res.send({ status: 1, msg: 'fail' }) } res.send({ status: 0, msg: 'success', username: req.session.user.username }) }) 清空 session app.post('/api/logout', (req, res) =&gt; { // 清空当前客户端的session信息 req.session.destroy() res.send({ status: 0, msg: 'logout done' }) }) JWT 认证机制前后端分离推荐使用 JWT（JSON Web Token）认证机制，是目前最流行的跨域认证解决方案 JWT 工作原理Session 认证的局限性： Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。 当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制 JWT 工作原理图： 用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。 JWT 组成部分： Header、Payload、Signature Payload 是真正的用户信息，加密后的字符串 Header 和 Signature 是安全性相关部分，保证 Token 安全性 三者使用 . 分隔 Header.Payload.Signature eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTcsInVzZXJuYW1lIjoiQnJ1Y2UiLCJwYXNzd29yZCI6IiIsIm5pY2tuYW1lIjoiaGVsbG8iLCJlbWFpbCI6InNjdXRAcXEuY29tIiwidXNlcl9waWMiOiIiLCJpYXQiOjE2NDE4NjU3MzEsImV4cCI6MTY0MTkwMTczMX0.bmqzAkNSZgD8IZxRGGyVlVwGl7EGMtWitvjGD-a5U5c JWT 使用方式： 客户端会把 JWT 存储在 localStorage 或 sessionStorage 中 此后客户端与服务端通信需要携带 JWT 进行身份认证，将 JWT 存在 HTTP 请求头 Authorization 字段中 加上 Bearer 前缀 Authorization: Bearer &lt;token&gt; Express 使用 JWT 安装 jsonwebtoken 用于生成 JWT 字符串 express-jwt 用于将 JWT 字符串解析还原成 JSON 对象 npm install jsonwebtoken express-jwt 定义 secret 密钥 为保证 JWT 字符串的安全性，防止其在网络传输过程中被破解，需定义用于加密和解密的 secret 密钥 生成 JWT 字符串时，使用密钥加密信息，得到加密好的 JWT 字符串 把 JWT 字符串解析还原成 JSON 对象时，使用密钥解密 const jwt = require('jsonwebtoken') const expressJWT = require('express-jwt') // 密钥为任意字符串 const secretKey = 'fantasy' 生成 JWT 字符串 app.post('/api/login', (req, res) =&gt; { ... res.send({ status: 200, message: '登录成功', // jwt.sign() 生成 JWT 字符串 // 参数：用户信息对象、加密密钥、配置对象-token有效期 // 尽量不保存敏感信息，因此只有用户名，没有密码 token: jwt.sign({username: userInfo.username}, secretKey, {expiresIn: '10h'}) }) }) JWT 字符串还原为 JSON 对象 客户端访问有权限的接口时，需通过请求头的 Authorization 字段，将 Token 字符串发送到服务器进行身份认证 服务器可以通过 express-jwt 中间件将客户端发送过来的 Token 解析还原成 JSON 对象 // unless({ path: [/^\\/api\\//] }) 指定哪些接口无需访问权限 app.use(expressJWT({ secret: secretKey }).unless({ path: [/^\\/api\\//] })) 获取用户信息 当 express-jwt 中间件配置成功后，即可在那些有权限的接口中，使用 req.user 对象，来访问从 JWT 字符串中解析出来的用户信息 app.get('/admin/getinfo', (req, res) =&gt; { console.log(req.user) res.send({ status: 200, message: '获取信息成功', data: req.user, }) }) 捕获解析 JWT 失败后产生的错误 当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行 通过 Express 的错误中间件，捕获这个错误并进行相关的处理 app.use((err, req, res, next) =&gt; { if (err.name === 'UnauthorizedError') { return res.send({ status: 401, message: 'Invalid token' }) } res.send({ status: 500, message: 'Unknown error' }) })","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://blog.luckjin.cool/categories/Node-js/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"node.js","slug":"node-js","permalink":"https://blog.luckjin.cool/tags/node-js/"}]},{"title":"Express+Node.js的学习","slug":"Express-Node-js的学习","date":"2022-08-11T08:29:04.000Z","updated":"2022-08-23T04:44:23.096Z","comments":true,"path":"posts/9c8c3744.html","link":"","permalink":"https://blog.luckjin.cool/posts/9c8c3744.html","excerpt":"","text":"Express 认识官网链接 ：https://www.expressjs.com.cn/ Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。 安装 Express nmp i express 创建基本服务器const express = require('express') // 创建 web 服务器 const app = express() // 监听客户端的 GET 和 POST 请求 // 并向客户端响应具体内容 //通过 app.get(’请求url‘，function(req,res)) 方法， //可以监听客户端的 GET 请求 app.get('/user',(req,res)=&gt;{ res.send({ name:'湘伦', age:'18' }) }) // post 请求 语法和 get 的差别不大 app.post('/user',(req,res)=&gt;{ res.send('ok') }) // 通过 req.query 可以获取到客户端发送过来的查询参数 app.get('/user',(req,res)=&gt;{ // req.query 默认是空对象 // 客户端使用 ?name=zs&amp;age20 查询字符串的形式，发送到服务器 // 可以通过req.query 对象访问 // 例如 输出 zs console.log(req.query.name) }) // 通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数 // 这里的 :id 是一个动态的参数 app.get('/user/:ids/:username', (req, res) =&gt; { // req.params 是动态匹配到的 URL 参数，默认是一个空对象 console.log(req.params) res.send(req.params) }) // 启动服务器 app.listen(80, () =&gt; { console.log('express server running at http://127.0.0.1') }) 托管静态资源 通过 express.static() 方法可创建静态资源服务器，向外开放访问静态资源。 Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，存放静态文件的目录名不会出现在 URL 中 访问静态资源时，会根据托管顺序查找文件 可为静态资源访问路径添加前缀 app.use(express.static('public')) app.use(express.static('files')) app.use('/bruce', express.static('bruce')) /* 可直接访问 public, files 目录下的静态资源 http://localhost:3000/images/bg.jpg http://localhost:3000/css/style.css http://localhost:3000/js/login.js 通过带有 /bruce 前缀的地址访问 bruce 目录下的文件 http://localhost:8080/bruce/images/logo.png */ Express 路由在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系 简单用法在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上 const express = require('express') // 创建 web 服务器，命名为 app const app = express() // 挂载路由 app.get('/',(req,res)=&gt;{ res.send('hello world') }) app.post('/',(req,res)=&gt;{ res.send('hello world') }) // 启动服务器 app.listen(80,()=&gt;{ console.log('express server running at http://127.0.0.1') }) 模块化路由为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。 将路由抽离为单独模块的步骤如下： 创建路由模块对应的 .js 文件 调用 express.Router() 函数创建路由对象 向路由对象上挂载具体的路由 使用 module.exports 向外共享路由对象 使用 app.use() 函数注册路由模块 创建路由模块// user.js const express = require('express') // 创建路由对象 const router = express.Router() // 挂载获取用户列表的路由 router.get('/user/list',(req,res)=&gt;{ res.send('Get user list') }) // 挂载添加用户列表的路由 router.post('/user/add',(req,res)=&gt;{ res.send('add new user ') }) // 向外共享 module.exports = router 注册使用路由模块// app.js const express = require('express') // 创建 web 服务器，命名为 app const app = express() // 导入路由模块 const userRouter = require('./router/user.js') // 使用 app.use() 注册路由模块，添加统一访问的前缀 api app.use('/api',userRouter) Express 中间件概念注意事项 中间件是指流程的中间处理环节 服务器收到请求后，可先调用中间件进行预处理 中间件是一个函数，包含 req, res, next 三个参数，next() 参数把流转关系交给下一个中间件或路由 在注册路由之前注册中间件（错误级别中间件除外） 中间件可连续调用多个 别忘记调用 next() 函数 next() 函数后别写代码 多个中间件共享 req、 res对象 全局作用域通过 app.use() 定义的中间件为全局中间件 // 定义第一个全局中间件 app.use((req, res, next) =&gt; { console.log('调用了第1个全局中间件') next() }) // 定义第二个全局中间件 app.use((req, res, next) =&gt; { console.log('调用了第2个全局中间件') next() }) 局部中间件不使用 app.use() 定义的中间件，叫做局部生效的中间件 // 定义中间件函数 const mw = (req,res,next)=&gt;{ console.log('局部中间件函数') next() } // 使用，只能在当前使用的路由生效，其他的路由无法使用 app.get('/',mw,(req,res)=&gt;{}) 中间件的类型应用级别的中间件路由级别的中间件错误级别的中间件Express 内置的中间件第三方的中间件通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件 // 应用级别的中间件(全局中间件) app.use((req,res,next)=&gt;{ next() }) // 应用级别的中间件(局部中间件) app.get('/',mw,(req,res)=&gt;{ next() })绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上 const app = express() const router = express.Router() // 路由级别的中间件 router.use(function (req, res, next) { console.log(1) next() }) app.use('/', router)错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题 格式：错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 (err, req, res, next) 错误级别的中间件必须注册在所有路由之后 const express = require('express') const app = express() app.get('/', (req, res) =&gt; { // 抛出错误 throw new Error('服务器内部发生了错误！') res.send('Home page.') }) // 定义错误级别的中间件， //捕获这个项目的异常错误，从而防止程序崩溃 app.use((err,res,req,next)=&gt;{ console('发生了错误！' + err.message) res.send('Error:' + err.message) }) 自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验 express.static 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性） express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用） express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用 非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置第三方中间件，从而提高项目的开发效率。 例如：在 express@4.16.0 之前的版本中，经常使用 body-parser 这个第三方中间件，来解析请求体数据。使用步骤如下： ① 运行 npm install body-parser 安装中间件 使用 require 导入中间件 调用 app.use() 注册并使用中间件 CORS 跨域资源共享使用： 安装中间件：npm install cors 导入中间件：const cors = require('cors') 配置中间件：app.use(cors()) 注意事项： CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。 CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。 CORS 响应头部 - Access-Control-Allow-Origin：响应头部中可以携带一个 Access-Control-Allow-Origin 字段 // 指定域名访问 res.setHeader('Access-Control-Allow-Origin', 'http://blog.luckjin.cool') // 任何域可访问 res.setHeader('Access-Control-Allow-Origin', '*') 默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一） 如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！ 默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。 如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法。 // 只允许 POST, GET, DELETE, HEAD 请求方式访问 res.setHeader('Access-Control-Allow-Methods', 'POST, GET, DELETE, HEAD') // 允许所有 http 的请求方式 res.setHEader('Access-Control-Allow-Methods', '*') CORS 请求分类简单请求 请求方式：GET、POST、HEAD 三者之一 HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application/x-www-formurlencoded、multipart/form-data、text/plain） 预检请求 请求方式为 GET、POST、HEAD 之外的请求 Method 类型 请求头中包含自定义头部字段 向服务器发送了 application/json 格式的数据 在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据 简单请求和预检请求的区别 简单请求的特点：客户端与服务器之间只会发生一次请求。 预检请求的特点：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。 使用 Express 写接口// app.js // 创建基本服务器 const express = require('express') // 创建服务器实例 const app = express() // 如果要获取 URL-encoded 格式的请求体数据， // 必须配置中间件 app.use(express.urlencoded({ extended: false })) app.use(express.urlencoded({ extended: false })) // 导入注册路由模块 const apiRouter = require('./apiRouter.js') app.use('/api',apiRouter) // 启动服务器 app.listen(80,function(){ console.log('express server running at http://127.0.0.1') }) // =======分割线======= // apiRouter.js 路由模块 const express = require('express') const apiRouter = express.Router() // 编写 GET 接口 apiRouter.get('/get',(req,res)=&gt;{ // 获取客户端通过查询字符串发送过来的数据 const query = req.query // 调用 res.send()方法，把数据响应给客户端 res.send({ // 状态 ，0成功 ，1失败 status:0, msg:'GET请求成功' // 数据响应给客户端 data:query }) }) // 编写 POST 接口 apiRouter.post('/get',(req,res)=&gt;{ // 获取客户端通过请求体，发送到服务器的 URL-encoded 数据 const body = req.body // 调用 res.send()方法，把数据响应给客户端 res.send({ // 状态 ，0成功 ，1失败 status:0, msg:'POST请求成功' // 数据响应给客户端 data:body }) }) // 导出 module.exports = apiRouter","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://blog.luckjin.cool/categories/Node-js/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"node.js","slug":"node-js","permalink":"https://blog.luckjin.cool/tags/node-js/"}]},{"title":"Node.js的入门学习","slug":"node-js的学习","date":"2022-08-09T02:31:30.000Z","updated":"2022-08-20T05:28:50.323Z","comments":true,"path":"posts/4c2cf4e9.html","link":"","permalink":"https://blog.luckjin.cool/posts/4c2cf4e9.html","excerpt":"","text":"Node.js 简介运行环境 浏览器是 Javascript 的前端运行环境 Node. js 的 Javascript 的后端运行环境 Node.js中无法调用 DOM 和 BOM 等浏览器内置的API 应用场景 基于 Express 框架,可以快速构建 Web 应用 http://www.expressjs.com.cn/ 基于 Electron 框架，可以构建跨平台的桌面应用 https://electronjs.org/ 基于 restify 框架，可以快速构建 API 接口项目 http://restify.com/ 读写和操作数据库、创建实用的命令行工具辅助前端开发、etc… fs 文件系统模块读写文件fs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求 如果要使用 fs 模块需要先导入 const fs=require('fs') 读取指定文件向指定文件写入内容使用 fs.readFile() 方法，可以读取指定文件中的内容 fs.readFile(path[,options],callback) path 必选参数，字符串格式，表示文件路径 options 可选参数，表示指定编码格式来读取文件。 callback 必选参数，读取文件后的回调函数，函数形参 (err,dataStr) err 读取失败的结果 dataStr 读取成功的文件内容 读取文件例子📄 const fs=require(fs) fs.readFlie('./files/test.txt','ut8f',function(err,dataStr){ // 失败的结果 console.log(err) // 读取成功的文件内容 console。log(dataStr) }) 使用 fs.writeFile() 方法，可以向指定的文件中写入内容 fs.writeFile(file,data[,options],callback) file 必选参数，字符串格式，表示存放文件路径 data 必选参数，表示写入的内容 options 可选参数，表示指定编码格式来写入文件，默认 utf8 。 callback 必选参数，写入文件后的回调函数，函数形参 (err) err 读取失败的结果 写入文件的例子📄 const fs=require('fs') fs.writeFile('./files/test2.txt','Hello world!',function(err){ // 可以通过判断 err 对象是否为null ，从而判断文件写入结果 if(err){ // 失败的结果 return console.log('文件写入失败'+err.message) } console.log('写入成功') }) 路径动态拼接在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。 解决方案：采用 __dirname 拼接 // --dirname 表示当前文件夹所处路径 fs.writeFile(__dirname + './files/test2.txt','Hello world!',function(err){ // 可以通过判断 err 对象是否为null ，从而判断文件写入结果 if(err){ // 失败的结果 return console.log('文件写入失败'+err.message) } console.log('写入成功') }) path 路径模块path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求 如果要使用 path 模块需要先导入 const path=require('path') path.join() 方法作用：把多个路径片段拼接为完整的路径字符串 path.join([...paths]) ...paths &lt;string&gt; 路径片段的序列 返回值：&lt;string&gt; 示例 const pathStr=path.join('/a','/b/c','../','./d','e') // 输出 \\a\\b\\d\\e console.log(pathStr) const pathStr2=path.join(__dirname,'./files/1.txt') // 输出 当前文件所处的文件目录\\files\\1.txt凡是涉及到路径拼接的操作，推荐使用 path.join() 方法进行处理。不要直接使用 + 进行字符串的拼接 path.basename() 方法作用：可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名 path.basename(path[,ext]) path 必选参数，表示一个路径的字符串 ext &lt;string&gt; 可选参数，表示文件拓展名 返回值：&lt;string&gt; 表示路径最后一部分 示例获取路径中的文件名 const fpath='/a/b/c/index.html' const fullName=path.basename(fpath) // 返回值就是文件名 输出index.html console.log(fullName) const fullName2=path.basename(fpath,'.html') // 返回值就是文件名去掉 .html 输出index console.log(fullName1) path.extname() 方法作用：可以获取路径中的扩展名部分 path.extname(path) path &lt;string&gt;必选参数，表示一个路径的字符串 返回： &lt;string&gt; 返回得到的扩展名字符串 示例获取路径中的文件的扩展名 const fpath='/a/b/c/index.html const fext =path.extname(fpath) // 输出后缀名 .html console.log(fext) http 模块http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块 如果要使用 http 模块需要先导入 const http=require('http') 创建基本的服务器基本服务器简陋路由功能的服务器// 导入http模块 const http=require('http') //调用 http.createServer() 方法，创建一个 web 服务器实例 const server=http.creatServer() // 用服务器实例的 .on 绑定为服务器 request 事件 // 即可监听客户端发送过来的网络请求 server.on('request',(req,res)=&gt;{ // 只要有客户端请求我们的服务器，就触发 requset 事件 // 就会执行这个回调函数 console.log('hello world') // req 是请求对象，包含客户端的数据和属性 // 例如 req.url 是客户端的请求 url 地址 // req.mothod 是客户端的请求类型 // res 是响应对象 ，包含服务器的数据和属性 // res.send() 给客户端发送指定内容 结束请求 res.send('hello world') // 给客户端发送 hello.. 并且结束请求 // res.end() 方法，向客户端发送中文时， // 会出现乱码问题，设置内容的编码格式 // 设置响应头 Content——Type 的值为 // text/html; charset=utf-8 res.setHeader('Content——Type','text/html; charset=utf-8') }) // 调用服务器实例的 .listen(端口号，回调函数) 方法，启动当前的服务器实例 sever.listen(80,()=&gt;{ console.log('sever running at http://127.0.0.1:80') })根据不同的 url 响应不同的 html 内容 实现步骤 获取请求的 url 地址 设置默认的响应内容为 404 Not found 判断用户请求的是否为 / 或 /index.html 首页 判断用户请求的是否为 /about.html 关于页面 设置 Content-Type 响应头，防止中文乱码 使用 res.end() 把内容响应给客户端 // 导入http模块 const http=require('http') //调用 http.createServer() 方法，创建一个 web 服务器实例 const server=http.creatServer() // 用服务器实例的 .on 绑定为服务器 request 事件 // 即可监听客户端发送过来的网络请求 server.on('request',(req,res)=&gt;{ // 获取请求的 url 地址 const url = req.url // 设置默认的响应内容为 404 Not found let content='404 not found!' // 判断 if(url === '/' || url ==='/index.html'){ // 用户请求是首页 content = '首页' }else if(url === '/about.html'){ // 用户请求是关于页 content = '关于页面' } // 设置响应头防止中文乱码 res.setHeader('Content——Type','text/html; charset=utf-8') // 发送内容给客户端 res.send(content) }) // 调用服务器实例的 .listen(端口号，回调函数) 方法，启动当前的服务器实例 sever.listen(80,()=&gt;{ console.log('sever running at http://127.0.0.1:80') }) 模块化概念 模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。 模块化可提高代码的复用性和可维护性，实现按需加载。 模块化规范是对代码进行模块化拆分和组合时需要遵守的规则，如使用何种语法格式引用模块和向外暴露成员。 分类Node.js 中模块的分类 内置模块 自定义模块 第三方模块 模块作用域 和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域 防止全局变量污染 模块作用域的成员 自定义模块中都有一个 module 对象，存储了和当前模块有关的信息 在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。导入自定义模块时，得到的就是 module.exports 指向的对象。 默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，以 module.exports 指向的对象为准 CommonJS 模块化规范 每个模块内部，module 变量代表当前模块。 module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。 加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块。 模块加载机制模块第一次加载后会被缓存，即多次调用 require() 不会导致模块的代码被执行多次，提高模块加载效率。 内置模块加载优先级最高 自定义模块加载自定义模块时，路径以 ./ 或 ../ 开头，否则会作为内置模块或第三方模块加载。 导入自定义模块时，可以省略文件拓展名，Node.js 会按顺序加载文件 按确切的文件名加载 补全 .js 加载 补全 .json 加载 补全 .node 加载 报错 第三方模块 若导入第三方模块， Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块。 如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录 例如，假设在 C:\\Users\\fantasy\\project\\foo.js 文件里调用了 require('tools')，则 Node.js 会按以下顺序查找： C:\\Users\\fantasy\\project\\node_modules\\tools C:\\Users\\fantasy\\node_modules\\tools C:\\Users\\node_modules\\tools C:\\node_modules\\tools ​ 目录作为模块加载 ​ 当把目录作为模块标识符进行加载的时候，有三种加载方式： 在被加载的目录下查找 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口 如果没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。 若失败则报错","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://blog.luckjin.cool/categories/Node-js/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"node.js","slug":"node-js","permalink":"https://blog.luckjin.cool/tags/node-js/"}]},{"title":"javascript 进阶","slug":"Javscipt ","date":"2022-07-26T08:42:00.000Z","updated":"2022-08-21T09:14:27.032Z","comments":true,"path":"posts/d15997ef.html","link":"","permalink":"https://blog.luckjin.cool/posts/d15997ef.html","excerpt":"","text":"作用域 作用域规定了变量能够被访问的范围，离开这个范围变量就不能被访问 作用域分为： 局部作用域局部作用域分为函数作用域和块作用域。 函数作用域： 在函数内部声明的变量只能在函数内部被访问，外部无法访问 总结： 函数内部声明的变量，在函数外部无法被访问 函数的参数也是函数内部的局部的变量 不同函数内部声明的变量无法相互访问 函数执行完毕后，函数的变量实际被清空了 块作用域： 在JavaScript中使用 {} 包裹的代码块内部声明的变量外部将有可能无法被访问 for(let i=0;i&lt;10;i++){ // i 只能的该代码块中被访问 console.log(i) } // 超出了t的作用域 ，报错 console.log(i) 总结： let 声明的变量，const 声明的常量，都会产生块级作用域 var 声明的变量不会产生块级作用域 不同代码块之间的变量无法相互访问 推荐使用 let 和 const 全局作用域 在 &lt;script&gt; 标签 和 .js 文件的最外层就是全局作用域，在此声明的变量在函数内部也可以访问，全局作用域下声明的变量，任何其他作用域都可以被访问 //全局作用域，下声明变量num const num=10 function fn(){ //函数内部可以使用 console.log(num) } 注意： 为 window 对象动态添加的属性默认也是全局的，不推荐 函数未使用任何关键字声明的变量为全局变量，不推荐 尽可能少的声明全局变量，防止全局变量被污染 作用域链 作用域链本质是底层的变量查找机制 函数在被执行时，会优先找当前函数作用域中查找变量 如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域 //全局作用域 let a = 1 let b = 2 //局部作用域 function f() { let a = 1 function g() { a = 2 console.log(a) // 2 } g() } f() 总结： 嵌套更新的作用域串联起来形成了作用域链 相同作用域链中按着从小到大的规则查找变量 子作用域能够访问父级作用域，父级作用域无法访问子级作用域 JS 的垃圾回收机制 垃圾回收机制 (Garbage Collection) 简称 GC JS 中的内存的分配和回收都是自动完成的，，内存在不使用的时候会被垃圾回收器自动回收。 但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况 不再用到的内存，没有及时释放，就叫做内存泄漏 内存的生命周期 ： 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用：即读写内存，也就是使用变量、函数等 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 全局变量一般不会回收(关闭页面回收)； 一般情况下局部变量的值, 不用了, 会被自动回收掉 垃圾回收算法说明 所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉下面介绍两种常见的浏览器垃圾回收算法: 引用计数法 和 标记清除法 引用计数IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。算法： 跟踪记录每个值被引用的次数。 如果这个值的被引用了一次，那么就记录次数1 多次引用会累加。 如果减少一个引用就减1。 如果引用次数是0 ，则释放内存。 引用计数算法是个简单有效的算法。但它却存在一个致命的问题：嵌套引用。如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。 标记清除法现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。核心： 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进 行回收。 闭包 概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域简单理解：闭包 = 内层函数 + 外层函数的变量 function outer() { const a = 1 function f(){ console.log(a) } f() } outer // 内层函数调用外层函数的变量，就是闭包 作用： 封闭数据，提供操作，外部也可以访问函数内部的变量 基本格式： 闭包应用：实现数据的私有比如，我们要做个统计函数调用次数，函数调用一次，就++ 普通写法 let count = 1 function fn() { count++ console.log(count) } fn() //2 fn() //3 这个count 是个全局变量，很容易被修改 闭包写法： function fn() { let count = 1 return function fun() { count++ console.log(count) } } const result =fn() result() //2 result() //3 实现了数据私有，无法直接修改count 闭包可能引起的问题：内存泄漏 变量提升 变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问（仅存在于var声明变量） console.log(str) //不报错 控制台显示undefined var str = 'hello' 注意： 变量在未声明即被访问时会报语法错误 变量在var声明之前即被访问，变量的值为 undefined let / const 声明的变量不存在变量提升 变量提升出现在相同作用域当中 实际开发中推荐先声明再访问变量 函数进阶函数提升函数提升与变量提升比较类似，是指函数在声明之前即可被调用。 函数参数 动态参数 arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参 //求和函数 不管用户传入几个实参，都要把和求出来 function sum() { let s = 0 for(let i = 0;i &lt; arguments.length;i++){ s += arguments[i] } return s } sum(5,10) //15 sum(1,2,3) //6 剩余参数 剩余参数允许我们将一个不定数量的参数表示为一个数组 ... 是语法符号，置于最末函数形参之前，用于获取多余的实参 借助 ... 获取的剩余实参，是个真数组 function sum(...other) { let s = 0 for(let i = 0;i &lt; other.length;i++){ s += other[i] } return s } sum(5,10) //15 sum(1,2,3) //6 区别： … 是语法符号，置于最末函数形参之前，用于获取多余的实参 借助 … 获取的剩余实参，是个真数组 展开运算符：... 展开运算符 (…)， 将一个数组进行展开，不会修改原数组 const arr=[1,2,3,4,5] console.log(...arr) //1 2 3 4 5 典型运用场景： 求数组最大值(最小值)、合并数组等 const arr=[1,2,3,6,4,5] const arr2=[7,8,9] //最大值 const max=Math.max(...arr) //合拼 const arr3=[...arr,...arr2] 展开运算符 or 剩余参数剩余参数：函数参数使用，得到真数组展开运算符：数组中使用，数组展开 箭头函数语法： //普通函数 const fn = function (){ ... } fn() //1.箭头 无参数 const fn = () =&gt;{ ... } //2.只有一个参数 const fn = x=&gt; { return x } //3.函数体只有一行代码，可以写一行上，无需写 return 直接返回值 const fn = (x,y) =&gt; x + y //返回 x + y 的值 //加括号的函数体返回对象字面量表达式 const fn1 = uname =&gt;({uname : uname}) console.log(fn1('叶湘伦')) //控制台：{uname:\"叶湘伦\"} 箭头函数属于表达式函数，因此不存在函数提升 箭头函数只有一个参数时可以省略圆括号 () 箭头函数函数体只有一行代码时可以省略花括号 {}，并自动做为返回值被返回 加括号的函数体返回对象字面量表达式 箭头函数参数： 普通函数有 arguments 动态参数 箭头函数没有 arguments 动态参数，但是有 剩余参数 ..args 箭头函数 this：在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值箭头函数不会创建自己的 this ,它只会从自己的作用域链的上一层沿用 this 。 在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此，DOM事件回调函数为了简便，还是不太推荐使用箭头函数 数组解构 数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法。 // 普通的数组 let arr = [1, 2, 3]; // 批量声明变量 a b c // 同时将数组单元值 1 2 3 依次赋值给变量 a b c let [a, b, c] = arr; console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 基本语法： 赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量 变量的顺序对应数组单元值的位置依次进行赋值操作 变量的数量大于单元值数量时，多余的变量将被赋值为 undefined 变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位 允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效 对象解构 // 普通对象 const user = { name: '小明', age: 18 }; // 批量声明变量 name age // 同时将数组单元值 小明 18 依次赋值给变量 name age const {name, age} = user console.log(name) // 小明 console.log(age) // 18 总结： 赋值运算符 = 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量 对象属性的值将被赋值给与属性名相同的变量 对象中找不到与变量名一致的属性时变量值为 undefined 允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效 遍历数组 forEach 方法 forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数 遍历数组.forEach(function (当前数组元素,索引号){ //函数体 }) 注意： forEach 主要是遍历数组 参数当前数组元素是必须要写的， 索引号可选。 筛选数组 filter 方法 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素 主要使用场景： 筛选数组符合条件的元素，并返回筛选之后元素的新数组 遍历数组.filter(function (当前数组元素,索引号){ return 筛选条件 }) //筛选数组大于30的元素 const arr=[10,26,62,61,56,12,36] const re = arr.filter(function(item){ return item &gt; 30 }) console.log(re) //[62,61,56,36] 返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组参数：currentValue 必须写， index 可选因为返回新数组，所以不会影响原数组 对象创建方法 利用字面量创建 const obj = { name:'叶湘伦', age:18 } 利用 new Object 创建对象 const obj = new Object({ name:'叶湘伦', age:18 }) 利用构造函数创建 // 构造函数 function Obj(name,age){ this.name = name this.age = age } //创建一个对象 const Stu = new Obj('叶湘伦'，18) 注意： 语法：大写字母开头的函数 约定：它们的命名以大写字母开头。只能由 “new” 操作符来执行。 说明： 使用 new 关键字调用函数的行为被称为实例化 实例化构造函数时没有参数可以省略（） 构造函数内部不用写 return ，返回值即为新建的对象 new Object（） new Date（） 也是实例化构造函数 实列化执行过程： 创建一个新空对象 构造函数 this 指向新对象 执行构造函数代码，修改 this ，添加新的属性 返回新的对象 实例对象 通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员 // 构造函数 function Obj(name,age){ //构造函数内部的 this 就是实例对象 //实例对象中动态添加属性 this.name = name this.age = age //实例对象中动态添加方法 this.sayHi = function () { console.log('hi') } } //实例化 ，Stu 是实列对象 // Stu 实际就是构造函数内部的 this const Stu = new Obj('叶湘伦'，18) //访问实例属性 console.log(Stu.name) //调用实列方法 Stu.sayHi() 说明： 实例对象的属性和方法即为实例成员 为构造函数传入参数，动态创建结构相同但值不同的对象 构造函数创建的实例对象彼此独立互不影响。 静态成员： 在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。 // 构造函数 function Obj(name,age){ //实例成员 } //静态属性 Obj.eyes = 2 Obj.arms = 2 //静态方法 Obj.walk = funtion () { console.log('走路中') //this 指向 person console.log(this.eyes) } 总结： 静态成员指的是添加到构造函数本身的属性和方法 一般公共特征的属性或方法静态成员设置为静态成员 静态成员方法中的 this 指向构造函数本身 内置构造函数 在 JavaScript 中最主要的数据类型有 6 种，分别是字符串、数值、布尔、undefined、null 和 对象，常见的对象类型数据包括数组和普通对象。其中字符串、数值、布尔、undefined、null 也被称为简单类型或基础类型，对象也被称为引用类型。 在 JavaScript 内置了一些构造函数，绝大部的数据处理都是基于这些构造函数实现的，JavaScript 基础阶段学习的 Date 就是内置的构造函数。 引用类型： Object : 三个常用静态方法（静态方法就是只有构造函数Object可以调用的） Object.keys 静态方法获取对象中所有属性（键） Object.values 静态方法获取对象中所有属性值 Object.assign 静态方法常用于对象拷贝 //Object.keys const obj = {name:'叶湘伦',age:18} const arr = Object.key(obj) console.log(arr) // ['name','age'] 返回是一个数组 //Object.values const arr2 =Object.values(obj) console.log(arr2) // ['叶湘伦',18] 返回是一个数组 //Object.assign const obj2 = {} Object.assign(obj2,obj) console.log(obj2) // {name:'叶湘伦',age:18} //使用：经常使用的场景给对象添加属性 Object.assign(obj,{sex:'男'}) console.log(arr) // {name:'叶湘伦',age:18,sex:'男'} Array : 数组常见实例方法-核心方法 方法 作用 说明 forEach 遍历数组 不返回值，用于不改变值，经常用于查找打印输出值 filter 过滤数组 筛选数组元素，并生成新数组 map 迭代数组 返回新数组，新数组里面的元素是处理之后的值，经常用于处理数据 reduce 累积器 返回函数累计处理的结果，经常用于求和等 总结： 推荐使用字面量方式声明数组，而不是 Array 构造函数 实例方法 forEach 用于遍历数组，替代 for 循环 (重点) 实例方法 filter 过滤数组单元值，生成新数组(重点) 实例方法 map 迭代原数组，生成新数组(重点) 实例方法 join 数组元素拼接为字符串，返回字符串(重点) 实例方法 find 查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点) 实例方法every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回 true，否则返回 false(重点) 实例方法some 检测数组中的元素是否满足指定条件 如果数组中有元素满足条件返回 true，否则返回 false 实例方法 concat 合并两个数组，返回生成新数组 实例方法 sort 对原数组单元值排序 实例方法 splice 删除或替换原数组单元 实例方法 reverse 反转数组 实例方法 findIndex 查找元素的索引值 String： 总结： 实例属性 length 用来获取字符串的度长(重点) 实例方法 split('分隔符') 用来将字符串拆分成数组(重点) 实例方法 substring（需要截取的第一个字符的索引[,结束的索引号]） 用于字符串截取(重点) 实例方法 startsWith(检测字符串[, 检测位置索引号]) 检测是否以某字符开头(重点) 实例方法 includes(搜索的字符串[, 检测位置索引号]) 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点) 实例方法 toUpperCase 用于将字母转换成大写 实例方法 toLowerCase 用于将就转换成小写 实例方法 indexOf 检测是否包含某字符 实例方法 endsWith 检测是否以某字符结尾 实例方法 replace 用于替换字符串，支持正则匹配 实例方法 match 用于查找字符串，支持正则匹配 注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。 原型 JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象 作用： 共享方法 可以把那些不变的方法，直接定义在 prototype 对象上 constructor 属性： 指向该原型对象的构造函数 对象原型：对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在 总结： prototype是什么？哪里来的？ 原型（原型对象） 构造函数都自动有原型 constructor属性在哪里？作用干啥的？ prototype原型和对象原型__proto__里面都有 都指向创建实例对象/原型的构造函数 __proto__属性在哪里？指向谁？ 在实例对象里面 指向原型 prototype 原型继承 继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。 封装-抽取公共部分 把男人和女人公共的部分抽取出来放到人类里面 继承-让男人和女人都能继承人类的一些属性和方法 把男人女人公共的属性和方法抽取出来 People 然后赋值给Man的原型对象，可以共享这些属性和方法 注意让constructor指回Man这个构造函数 //人类 const People = { head:1, eyes:2, leys:2, say:function () {} } //男人 function Man(){ } //公共属性和方法给原型 Man.prototype = People //如果我们给男人添加了一个吸烟的方法，发现女人自动也添加这个方法 //男人和女人都同时使用了同一个对象，根据引用类型的特点，他们指向同一个对象，修改一个就会都影响 Man.prototype.smoking = function () {} //女人 function Woamn() { //独有方法 this.body =function () {} } // 继承写法完善 ,解决上面问题 //男人和女人不要使用同一个对象，但是不同对象里面包含相同的属性和方法 //答案：构造函数 //new 每次都会创建一个新的对象 function People() = { head:1, eyes:2, leys:2, say:function () {} } //男人 function Man(){ } //公共属性和方法 Man.prototype =new People() 原型链： 基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为原型链 原型链-查找规则： 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象） 如果还没有就查找原型对象的原型（Object 的原型对象） 依此类推一直找到 Object 为止（null） __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线 深浅拷贝浅拷贝拷贝的是地址常见方法： 拷贝对象：Object.assgin() 展开运算符 {...obj} 拷贝对象 拷贝数组：Array.prototype.concat() 或者 [...arr] 总结： 直接赋值和浅拷贝有什么区别？ 直接赋值的方法，只要是对象，都会相互影响，因为是直接拷贝对象栈里面的地址 浅拷贝如果是一层对象，不相互影响，如果出现多层对象拷贝还会相互影响 浅拷贝怎么理解？ 拷贝对象之后，里面的属性值是简单数据类型直接拷贝值 如果属性值是引用数据类型则拷贝的是地址 深拷贝拷贝的是对象，不是地址 常见方法： 通过递归实现深拷贝 lodash/cloneDeep 通过JSON.stringify()实现 异常处理throw 抛异常总结： throw 抛出异常信息，程序也会终止执行 throw 后面跟的是错误提示信息 Error 对象配合 throw 使用，能够设置更详细的错误信息 try/catch总结： try...catch 用于捕获错误信息 将预估可能发生错误的代码写在 try 代码段中 如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息 finally 不管是否有错误，都会执行 debugger ：类似浏览器调试打断点 处理thisthis指向-普通函数 普通函数的调用方式决定了 this 的值，即【谁调用 this 的值指向谁】 普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined this指向-箭头函数箭头函数中的 this 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 this ！ 箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的 箭头函数中的this引用的就是最近作用域中的this 向外层作用域中，一层一层查找this，直到有this的定义 改变thiscall() 方法调用函数，同时指定被调用函数中 this 的值 fn.call(thisArg,arg1,arg2,...) 说明： thisArg：在 fn 函数运行时指定的 this 值 arg1，arg2：传递的其他参数 返回值就是函数的返回值，因为它就是调用函数 apply() 调用函数，同时指定被调用函数中 this 的值 fn.apply(thisArg,[argArray]) 说明： thisArg：在fn函数运行时指定的 this 值 argsArray：传递的值，必须包含在数组里面 返回值就是函数的返回值，因为它就是调用函数 因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值 bind() 不会调用函数。但是能改变函数内部this 指向 fn.bind(thisArg,arg1,arg2,...) 说明： thisArg：在 fn 函数运行时指定的 this 值 arg1，arg2：传递的其他参数 返回由指定的 this 值和初始化参数改造的 原函数拷贝 （新函数） 因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind，比如改变定时器内部的 this 指向. 总结： 区别 call 和 apply 会调用函数, 并且改变函数内部 this 指向 call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2.. 形式 apply 必须数组形式[arg] bind 不会调用函数, 可以改变函数内部 this 指向 主要应用场景 call 调用函数并且可以传递参数 apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值 bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向. 节流和防抖 节流： 就是指连续触发事件但是在 n 秒中只执行一次函数，比如可以利用节流实现 1s之内 只能触发一次鼠标移动事件 防抖： 指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间 使用场景 节流： 鼠标移动，页面尺寸发生变化，滚动条滚动等开销比较大的情况下 防抖： 搜索框输入，设定每次输入完毕n秒后发送请求，如果期间还有输入，则从新计算时间","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.luckjin.cool/categories/JavaScript/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"基础","permalink":"https://blog.luckjin.cool/tags/%E5%9F%BA%E7%A1%80/"}],"author":"Fantasy"},{"title":"WebAPI的基本学习","slug":"webapi","date":"2022-07-17T06:34:02.000Z","updated":"2022-08-21T09:09:36.083Z","comments":true,"path":"posts/6ec968d6.html","link":"","permalink":"https://blog.luckjin.cool/posts/6ec968d6.html","excerpt":"","text":"webAPI的基本学习 作用：使用JS操作html和浏览器 分类：DOM（文档对象模型）、BOM（浏览器对象模型） DOM的内容 DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API 简单来说：DOM是浏览器提供的一套专门用来 操作网页内容 的功能 作用：开发网页内容特效和实现用户交互 DOM树 内容：将HTML以树状的内容直观显示出来，也称文档树 作用：直观体现出标签与标签的关系 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 文本 &lt;a href=\"\"&gt;链接&lt;/a&gt; &lt;h1 class=\"\" id=\"\"&gt;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 获取DOM元素 CSS选择器 匹配到第一个元素，返回一个HTMLElement对象 //语法 document.querySelector('CSS选择器') 匹配多个选择器，返回NodeList对象集合，得到是一个伪数组 document.querySelectorAll('CSS选择器') 其他方法 document.getElementByid('id名') document.getElementByTagName('标签名') document.getElementByClassName('类名') 设置和修改DOM元素 修改标签文本内容 //语法： 元素.innerText='' //只能识别内容，不能解释标签 //可以解析标签 即： 元素.innerHTML='&lt;h3&gt;会对html标签进行解析&lt;/h3&gt;' 设置与修改DOM元素的属性 语法：对象.属性=值，最常见的属性比如： href、title、src 等 //例子 let pic =document.querySelector('img') pic.src='./images/pic2.jpg' 通过style修改CSS属性 let box =document.querySelector('div') box.style.width='300px' box.style.paddingLeft ='300px' //注：有链接-符号的需要转换为小驼峰命名法 //即：padding-left--&gt;paddingLeft 修改标签类名 元素.clssName='新类名' //注：直接使用 className 赋值会覆盖以前的类名 //保留可写 元素.clssName='旧类名 新类名' 通过clssList操作css类名 //增加一个类名 元素.classList.add('类名') //删除一个类 元素.classList.remove('类名') //切换一个类,存在就删除,不存在就增加 元素.classList.toggle('类名') 修改表单属性 作用：表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框 获取：DOM对象.属性名；设置：DOM对象.属性名=新值 表单.value='用户名' 表单.type='password' 表单属性中添加就有效果,移除就没有效果,一律使用布尔值表示 如果为true 代表添加了该属性 如果是false 代表移除了该属性比如： disabled、checked、selected 定时器-setInterval() 间歇函数 开启定时器 setInterval(函数，间隔时间) //时间也毫秒为单位，1秒==1000ms 关闭定时器 let timer =setInterval(函数，间隔时间) clearInterval(timer) 事件 事件是在编程时系统内发生的动作或者发生的事情，比如用户在网页上单击一个按钮 事件监听 让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为 注册事件 语法：元素.addEventListener('事件',要执行的函数) //获取元素 let btn=document.querySelector('button') //事件监听 btn.addEventListener('click',function(){ alert('被点击了') }) 事件监听三要素： 事件源：那个dom元素被事件触发了，要获取dom元素 事件：有什么方式触发，比如鼠标点击click 事件触发时调用的函数 版本 DOM L0 语法：事件源.on事件=function(){} btn.onclick=function(){ alert('点击') } DOM L2 ⭐ 语法：事件源.addEventlistener(事件，事件处理函数) btn.addEventListener('click',function(){ alert('点击') }) 事件类型 高阶函数 高阶函数可以被简单理解为函数的高级应用，JavaScript 中函数可以被当成【值】来对待，基于这个特性实现函数的高级应用 函数表达式let counter=function(x,y){ return x+y } //调用 let result=counter(1,2) 回调函数 如果将函数A当作参数传递给函数B时，我们称函数A为回调函数 回调函数本质还是函数，只不过把它当成参数使用 使用场景 定时器setInterval() 间歇函数 function fn(){ alert('我是回调函数') } //fn传递了给setInterval ，fn就是回调函数 setInterval(fn,1000) 事件监听 btn.addEventListener('click',function(){ alert('我是回调函数') }) 环境变量 环境对象指的是函数内部特殊的变量 this ，它代表着当前函数运行时所处的环境作用：弄清楚this的指向，可以让我们代码更简洁 函数的调用方式不同，this 指代的对象也不同 【谁调用， this 就是谁】 是判断 this 指向的粗略规则 直接调用函数，其实相当于是 window.函数，所以 this 指代 window 编程思想排他思想当前元素为A状态,其他元素为B状态 使用： 干掉所有人使用for循环 复活他自己通过this或者下标找到自己或者对应的元素 //给点击的li加上pink类 &lt;li class='pink'&gt;第一个&lt;/li&gt; &lt;li&gt;第二个&lt;/li&gt; &lt;li&gt;第三个&lt;/li&gt; let lis = document.querySelectorAll('li') for (let i = 0; i &lt; lis.length; i++) { lis[i].addEventListener('click', function () { // 干掉所有人 for (let j = 0; j &lt; btns.length; j++) { btns[j].classList.remove('pink') } //复活自己 this.classList.add('pink') //==================分割线=========================== //高级做法 // 我只需要找出那个唯一的 pink类，删除 document.querySelector('.pink').classList.remove('pink') // 我的 this.classList.add('pink') }) } DOM结点 DOM树里每一个内容都称之为节点 结点类型 元素结点 ⭐ 所有的标签：比如 body div，html是根节点 属性结点 所有的属性，比如 herf 文本结点 所有的文本 结点的查找结点的关系：父节点，子节点，兄弟节点 父节点的查找 使用parentNode属性，返回最近一级的父节点，找不到返回null 语法：子元素.parentNode 子结点的查找 childNodes - 获得所有的子节点，包括文本节点（空格、换行）、注释节点等 chilrden ⭐ -获得所有元素节点，返回的还是一个伪数组 兄弟结点的查找 nextElementSibling 查找下一个兄弟结点 previousElementSibling 查找上一个兄弟节点 结点的增加 一般情况下，我们新增节点，按照如下操作 1创建一个新的节点 2把创建的新的节点放入到指定的元素内部 创建结点 documnet.createElement('标签名') 追加结点 //插入父元素的最后 父元素.appendChild(要插入的元素) //插到某个子元素的前面 父元素.insertBefore(要插入的元素,在哪个元素的前面) 结点的克隆 cloneNode会克隆出一个跟原标签一样的元素，括号内传入布尔值若为true，则代表克隆时会包含后代节点一起克隆若为false，则代表克隆时不包含后代节点默认为false 语法：元素.cloneNode(布尔值) 结点的删除 删除节点和隐藏节点（display:none） 有区别的： 隐藏节点还是存在的，但是删除，则从html中删除节点在 JavaScript 原生DOM操作中，要删除元素必须通过父元素删除 语法：父元素.removeChild(要删除的元素) 重绘和回流浏览器进行界面渲染 解析（Parser）HTML，生成DOM树(DOM Tree) 同时解析（Parser） CSS，生成样式规则 (Style Rules) 根据DOM树和样式规则，生成渲染树(Render Tree) 进行布局 Layout(回流/重排):根据生成的渲染树，得到节点的几何信息（位置，大小） 进行绘制 Painting(重绘): 根据计算和获取的信息进行整个页面的绘制 Display: 展示在页面上 回流(重排) 当 Render Tree 中部分或者全部元素的尺寸、结构、布局等发生改变时，浏览器就会重新渲染部分或全部文档的过程称为回流，简单理解影响到布局了，就会有回流 会导致回流的操作 页面的首次刷新 浏览器的窗口大小发生改变 元素的大小或位置发生改变 改变字体的大小 内容的变化（如：input框的输入，图片的大小） 激活css伪类 （如：:hover） 脚本操作DOM（添加或者删除可见的DOM元素） 重绘 由于节点(元素)的样式的改变并不影响它在文档流中的位置和文档布局时(比如：color、background-color、outline等), 称为重绘 注：重绘不一定引起回流，而回流一定会引起重绘。 练习： let s = document.body.stlye s.padding = '2px' //重排 + 重绘 s.border = '1px solid red' // 重排 + 重绘 s.color = 'red'//重绘 s.backgroundColor = '#666' //重绘 s.fontSize= \"14px\" // 重排 + 重绘 事件高级事件对象 内容：事件对象是个对象，这个对象里有事件触发时的相关信息 例如：鼠标点击事件中，事件对象就存了鼠标点在哪个位置等信息 获取方法： 在事件绑定的回调函数的第一个参数就是事件对象 一般命名为 even 、ev 、e 元素.addEventListener('click',function(e){ //e就是事件对象 }) 常用事件对象的属性 type ：获取当前事件类型 clientX / clientY ：获得光标相对于浏览器可见窗口左上角的位置 offsetX / offsetY : 获取光标相对于当前DOM元素左上角的位置 key ：用户按下的键盘的值，现在不提倡用 keyCode 事件流 事件流指的是事件完整执行过程的流动路径，两个阶段：事件捕获和事件冒泡 说明：假设页面里有个div，当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段 简单来说：捕获阶段是 从父到子 冒泡阶段是从子到父 事件冒泡 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发 简单理解：当一个元素触发事件后，会依次向上调用所有父级元素的同名事件 事件冒泡是默认存在的 事件捕获 从DOM的根元素开始去执行对应的事件 (从外到里) 说明： addEventListener第三个参数传入true代表是捕获阶段触发（很少使用） 若传入false代表冒泡阶段触发，默认就是false 若是用 L0 事件监听，则只有冒泡阶段，没有捕获 阻止事件流动 因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素 若想把事件就限制在当前元素内，就需要阻止事件流动 阻止事件流动需要拿到事件对象 语法：事件对象.stopProagation() 此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效 鼠标经过事件： mouseover 和 mouseout 会有冒泡效果 mouseenter 和 mouseleave 没有冒泡效果(推荐) 两种注册事件的区别： 传统on注册（L0） 同一个对象,后面注册的事件会覆盖前面注册(同一个事件) 直接使用null覆盖偶就可以实现事件的解绑 都是冒泡阶段执行的 事件监听注册（L2） 语法: addEventListener(事件类型, 事件处理函数, 是否使用捕获) 后面注册的事件不会覆盖前面注册的事件(同一个事件) 可以通过第三个参数去确定是在冒泡或者捕获阶段执行 必须使用removeEventListener(事件类型, 事件处理函数, 获取捕获或者冒泡阶段) 匿名函数无法被解绑 事件委托 事件委托其实是利用事件冒泡的特点， 给父元素添加事件，子元素可以触发 优点：给父级元素加事件（可以提高性能） 实现：事件对象.target 可以获得真正触发事件的元素 滚动事件 作用：很多网页需要检测用户把页面滚动到某个区域后做一些处理， 比如固定导航栏，比如返回顶部 事件名 scroll //可以给window或document添加滚动事件来监听整个页面 window.addEventListener('scroll',function(){ //要执行的操作 }) 加载事件load 事件 加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件 为什么要学？ 有些时候需要等页面资源全部处理完了做一些事情 老代码喜欢把 script 写在 head 中，这时候直接找 dom 元素找不到 事件名：load 监听页面所有资源加载完毕： 给 window 添加 load 事件 window.addEventListener('load',function(){ //要执行的操作 }) 注意：不光可以监听整个页面资源加载完毕，也可以针对某个资源绑定load事件 DOMContentLoaded 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表全加载 事件名：DOMContentLoaded 监听页面DOM加载完毕： 给 document 添加 DOMContentLoaded 事件 document.addEventListener('DOMContentLoaded',function(){ //要执行的操作 }) 元素大小和位置三大家族 scroll家族 offest家族 client家族 scroll家族 作用：检测页面滚动的距离 获取宽高 获取元素的内容总宽高（不包含滚动条）返回值不带单位 scrollWidth 和 scrollHeight 获取位置（属性可修改） 获取元素内容往左、往上滚出去看不到的距离 scrollLeft和scrollTop div.addEventListener('scroll',function(){ console.log(this.scrollTop) }) 注：document.documentElement ：HTML 文档返回对象为HTML元素 offest家族 获取宽高 获取元素的自身宽高、包含元素自身设置的宽高、padding、border offsetWidth 和 offsetHeight 获取位置（只读，不可修改） 获取元素距离自己定位父级元素的左、上距离 client家族 获取宽高 获取元素的可见部分宽高（不包含边框，滚动条等） clientWidth和clientHeight 位置 clientLeft和clientTop 注意是只读属性 resize事件 改变窗口大小的时候触发的事件，类似css3媒体查询 Window对象BOM 浏览器对象模型 window 是浏览器内置的全局对象，我们所学习的 web apis 的知识内容都是基于 window 对象实现的 window 对象下包含了 navigator 、location 、doucment history 、 srceen 5个属性，即 BOM document 是实现 DOM 的基础，它其实是依附于 window 的属性 依附于 window 对象的所有属性和方法，使用时可以省略 window 定时器-延时函数 JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout 语法：setTimeout(回调函数,等待的毫秒数) setTimeout 仅执行一次，简单来说把一段代码延迟执行 清除延时函数语法 ：clearTimeout(延时函数的id) 结合函数的递归可以实现 setInterval 间歇函数 一样的功能 function myInterval(){ let d=new date(); //写入页面 clock.innertext=d.toLocaleString(); //调用自己 一直循环，倒计时效果 setTimeout(myInterval,1000); } myInterval(); JS执行机制 （面试）⭐ JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。。这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 同步和异步 为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步。 同步 前一个任务执行完才执行后一个任务，程序执行的顺序和代码排列顺序一样 异步 执行一个某个任务费很长时间，在做这个任务的同时，还可以去处理其他的任务 比如：做饭时，等水开的期间可以去其他事，比如切菜 他们的本质区别： 这条流水线上各个流程的执行顺序不同。 同步任务 同步任务都在主线程上执行，形成一个执行栈。 异步任务 JS 的异步是通过回调函数实现的 一般来说异步任务有以下三种类型 1、普通事件，如 click、resize 等2、资源加载，如 load、error 等3、定时器，包括 setInterval、setTimeout 等 异步任务相关会添加的任务队列（消息队列）中 执行机制 先执行执行栈里面的同步任务 异步任务放在消息队列中 一旦执行栈的执行任务完毕，系统会依次读取消息队列里的异步任务，被读取的异步任务结束等待状态，进入执行栈，开始执行 事件循环（event loop） 由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop） location对象 location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分 常用属性和方法： href 属性获取完整的 URL 地址，对其赋值时用于地址的跳转 search 属性获取地址中携带的参数，符号 ？后面部分 hash 属性获取地址中的啥希值，符号 # 后面部分 reload 方法用来刷新当前页面，传入参数 true 时表示强制刷新 语法：loaction.属性 loactiom.方法() navigator对象 navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息 常用属性和方法： 通过 userAgent 检测浏览器的版本及平台 // 检测 userAgent（浏览器信息） !(function () { const userAgent = navigator.userAgent // 验证是否为Android或iPhone const android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/) const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/) // 如果是Android或iPhone，则跳转至移动站点 if (android || iphone) { location.href = 'http://m.itcast.cn' } })() histroy对象 history 的数据类型是对象，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等 history对象和方法 作用 back() 可以后退功能 forward() 可以前进功能 go(参数) 前进，后退功能，参数决定，-1后退，1前进 本地存储 随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案 数据存储在用户浏览器中 设置、读取方便、甚至页面刷新不丢失数据 容量较大，sessionStorage和localStorage约 5M 左右 localStorage 生命周期永久生效，除非手动删除 否则关闭页面也会存在 可以多窗口（页面）共享（同一浏览器可以共享） 以键值对的形式存储使用 语法 存储数据：localStorage.setItem(key, value) 获取数据：localStorage.getItem(key) 删除数据：localStorage.removeItem(key) 存储复杂数据类型存储： 本地只能存储字符串,无法存储复杂数据类型.需要将复杂数据类型转换成JSON字符串,在存储到本地 JSON.stringify(复杂数据类型) ： 将复杂数据转换成JSON字符串 存储 本地存储中 JSON.parse(JSON字符串)： 将JSON字符串转换成对象 取出 时候使用 sessionStorage（了解） 1. 生命周期为关闭浏览器窗口 2. 在同一个窗口(页面)下数据可以共享 3. 以键值对的形式存储使用 4. 用法跟localStorage 基本相同 自定义属性固有属性： 标签天生自带的属性 比如class id title等, 可以直接使用点语法操作 自定义属性: 由程序员自己添加的属性,在DOM对象中找不到, 无法使用点语法操作,必须使用专门的API 获取自定义属性 ：getAttribute('属性名') 设置自定义属性：setAttribute('属性名', '属性值') 删除自定义属性：removeAttribute('属性名') data-自定义属性： 传统的自定义属性没有专门的定义规则,开发者随意定值,不够规范,所以在html5中推出来了专门的data-自定义属性 在标签上一律以data-开头 在DOM对象上一律以dataset对象方式获取 正则表达式 正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象 正则表达式在 JavaScript中的使用场景： 例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配) 比如用户名: /^[a-z0-9_-]{3,16}$/ 过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。 语法使用： 定义规则 查找 语法：let 变量名=/表达式/ / / 是正则表达式字面量，比如 ：let reg=/abc/ 判断： test() 方法 用来查看正则表达式与指定的字符串是否匹配 ，返回 false 或 true let str = 'hello ,world' let reg = /hello/ console.log(reg.test(str)) //true exec() 方法 在一个指定字符串中执行一个搜索匹配 如果匹配成功，exec() 方法返回一个数组，否则返回null 元字符 是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。 比如，规定用户只能输入英文26个英文字母，普通字符的话 abcdefghijklm….. 但是换成元字符写法： [a-z] 方便记忆和学习，众多的元字符进行了分类： 边界符（表示位置，开头和结尾，必须用什么开头，用什么结尾） 正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符 注意：如果 ^ 和 $在一起，表示必须是精确匹配。 量词 （表示重复次数） 量词用来 设定某个模式出现的次数 注意： 逗号左右两侧千万不要出现空格 字符类 （比如 \\d 表示 0~9） - 连字符 使用连字符 - 表示一个范围 比如： [a-z] 表示 a 到 z 26个英文字母都可以 [a-zA-Z] 表示大小写都可以 [0-9] 表示 0~9 的数字都可以 [ ] 里面加上 ^ 取反符号比如：[^a-z] 匹配除了小写字母以外的字符 注意要写到中括号里面 . 匹配除换行符之外的任何单个字符 预定义：指的是某些常见模式的简写方式 修饰符 修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等 语法： /表达式/修饰符 i 是单词 ignore 的缩写，正则匹配时字母不区分大小写g 是单词 global 的缩写，匹配所有满足正则表达式的结果 console.log(/a/i.test('a')) //true console.log(/a/i.test('A')) //true 替换 replace 替换：（过滤敏感词） 字符串.replace(/正则表达式/，'替换的文本') ​","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.luckjin.cool/categories/JavaScript/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Fantasy"},{"title":"html and css","slug":"html-and-css","date":"2022-05-04T04:31:45.000Z","updated":"2022-11-01T02:47:08.738Z","comments":true,"path":"posts/28784acc.html","link":"","permalink":"https://blog.luckjin.cool/posts/28784acc.html","excerpt":"","text":"整体结构&lt;html&gt; &lt;!--开始标签--&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;!--字符编码避免网页文字乱码--&gt; &lt;title&gt;网页的标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--网页的基本内容--&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--结束标签--&gt; 初级标签 标题标签 H1，H2，….，H6。（1–&gt;6）大标题–&gt;小标题，成对出现，开始标签 &lt;H1&gt; ，一个结束标签 &lt;/H1&gt; 。 段落标题 段落是通过 &lt;p&gt; 标签进行定义的，成对出现，开始标签 &lt;p&gt; ，一个结束标签 &lt;/p&gt; 。 文字标签 &lt;strong&gt;&lt;/strong&gt;，加粗文字标签；&lt;em&gt;&lt;/em&gt; 斜体文字标签，可嵌套 符号标签 &lt;del&gt;&lt;/del&gt;，在文字上添加删除线，如：文字 高级标签 块状标签 &lt;div&gt;&lt;/div&gt; ,每一个div占满一整行。 &lt;span&gt;&lt;/span&gt;，文本信息在一行展示 空格和换行，尖括号 &lt;br&gt; 换行标签，&amp;nbsp; 空格符号，&amp;lt 左尖括号，&amp;gt; 右尖括号 有序列表标签 &lt;ol&gt; &lt;!--网页显示--&gt; &lt;li&gt;第一条&lt;/li&gt; &lt;!--1.第一--&gt; &lt;li&gt;第二条&lt;/li&gt; &lt;!--2.第二--&gt; &lt;li&gt;第三条&lt;/li&gt; &lt;!--3.第三--&gt; &lt;/ol&gt; &lt;ol&gt; 可以增加属性，type，换排序符号； 如 &lt;ol type=\"A\"&gt; ，就从A，B顺序排列；符号可以换 A,a,1,i I ，不填默认数值1； 倒叙 &lt;ol reversed=\"reversed\"&gt; ； &lt;ol start=\"数值\"&gt;，更换开始符号的数值； 无序列表标签 &lt;ul&gt; &lt;li&gt;第一条&lt;/li&gt; &lt;li&gt;第二条&lt;/li&gt; &lt;li&gt;第三条&lt;/li&gt; &lt;/ul&gt; 默认每一段文本前面显示小圆点 属性：&lt;ul type=disc&gt; 默认值实心小圆点，circle 空心小圆点，square 小方块 图片插入 &lt;img src=\"图片路径\"&gt; 包括： 1，网上url； 2，本地的绝对路径(同一个文件夹下，直接写图片文件名)； 3，本地的相对路径(不同一个文件夹下，写完整图片路径)； 属性： 1，&lt;img src=\"图片路径\" alt=\"图片占位符\"&gt;，即图没有加载出来时显示 2，&lt;img src=\"图片路径\" title=”图片提示符“&gt;，即鼠标移到图时显示 链接标签a 超链接：&lt;a href=\"网址\"&gt;网站名&lt;/a&gt; 锚点：&lt;a href=\"#id\"&gt;文字&lt;/a&gt;；id指某个标签的id名字，运用于：页面目录，回到顶部 打电话或发邮件：&lt;a href=\"tel:电话号码\"&gt;文字&lt;/a&gt;；&lt;a href=\"mailto:邮箱地址\"&gt;文字&lt;/a&gt; 协议限定符：使用js 属性：target=_blank 点击链接在新页面弹出 表单 信息输入框 &lt;form method=\"get\" action=\"\" &gt; &lt;!--action：发送出去的地址--&gt; name: &lt;input type=\"text\" name=\"name\" /&gt; &lt;!--文本输入框，name：数值内容--&gt; password: &lt;input type=\"password\" name=\"password\" /&gt; &lt;!--密码输入框，name：数值内容--&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;!--提交按键，value：数据值--&gt; &lt;/form&gt; 单选框 &lt;form method=\"get\" action=\"\" &gt; &lt;!--action：发送出去的地址--&gt; &lt;p&gt; 选择其中一个 &lt;/p&gt; 1.第一个&lt;input type=\"radio\" name=\"name\" value:\"one\"&gt; &lt;!--name相同表示同个选择问题--&gt; 1.第二个&lt;input type=\"radio\" name=\"name\" value:\"two\"&gt; 1.第三个&lt;input type=\"radio\" name=\"name\" value:\"three\"&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;!--提交按键， value：数据值--&gt; &lt;/form&gt; 副选框 &lt;input type=\"checkobx\" name=\"题目\" value:\"提交的数值\"&gt; &lt;!--大致与上面相同--&gt; 选项下拉菜单 &lt;select name=\"\"&gt; &lt;option&gt;选项一&lt;/option&gt; &lt;option&gt;选项二&lt;/option&gt; &lt;/select&gt; 表单添加默认选项：标签后加入 checked=\"checked\" 引入CSS 行间样式 &lt;div style=\"css定义内容\"&gt; &lt;/div&gt; 页面级CSS 在头部标签 &lt;head&gt; 下加入 &lt;style type=\"text/css\"&gt; &lt;!--css定义内容--&gt; &lt;/style&gt; 外部CSS文件新加一个文件后缀为.CSS在头部标签 &lt;head&gt; 下加入&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"CSS文件位置\"/&gt;\\ CSS选择器 id，在div标签加入id名 &lt;!--id创建--&gt; &lt;div id=\"填id名\"&gt;&lt;/div&gt; &lt;!--下面css定义,引入css页面填写--&gt; #id名{ \"css定义内容\" } class，在div标签加入class名 &lt;!--class创建--&gt; &lt;div class=\"填calss名\"&gt;&lt;/div&gt; &lt;!--下面css定义,引入css页面填写--&gt; #id名{ \"css定义内容\" } 标签选择 &lt;!--下面css定义,引入css页面填写--&gt; 标签名{ \"css定义内容\" } 属性，如[id]，[class]，[id=”123”]… &lt;!--下面css定义,引入css页面填写--&gt; [属性]{ \"css定义内容\" } 通配符，对所以标签都生效 &lt;!--css定义,引入css页面填写--&gt; *{ \"css定义内容\" } 父子选择器/派生选择器 &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;!--对 1 进行css定义--&gt; &lt;/div&gt; &lt;!--下面css定义,引入css页面填写--&gt; div span{ \"css定义内容\" } 直接子元素选择器 &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;!--对 1 进行css定义--&gt; &lt;span&gt;2&lt;/span&gt; &lt;/div&gt; &lt;!--下面css定义,引入css页面填写--&gt; div &gt; span{ \"css定义内容\" } 并列选择器 &lt;div&gt; 1 &lt;/div&gt; &lt;div calss=\"demo\"&gt; 2 &lt;/div&gt; &lt;!--对 2 进行css定义--&gt; &lt;p calss=\"demo\"&gt; 3 &lt;/p&gt; &lt;!--下面css定义,引入css页面填写--&gt; div.demo{ \"css定义内容\" } 分组选择器 &lt;!--对 1,2,3 进行css定义--&gt; &lt;em&gt; 1 &lt;/em&gt; &lt;strong&gt; 2 &lt;/strong&gt; &lt;span&gt; 3 &lt;/span&gt; &lt;!--下面css定义,引入css页面填写--&gt; em,strong,span{ \"css定义内容\" } 伪类选择器 &lt;!--将鼠标悬浮在改标签时的变化，css定义--&gt; &lt;a href=\"链接地址\"&gt;链接文本&lt;/a&gt; &lt;!--下面css定义,引入css页面填写--&gt; a:hover{ \"css定义内容\" } CSS选择器的优先级!import &gt; 行间样式 &gt; id &gt; class =属性 &gt; 标签选择 &gt; 通配符 !import 在CSS定义内容后可加上 优先级是根据各个选择器的权重大小比较的 选择器 权重 !import Infinity (无穷大) 行间样式 1000 id 100 class 属性 伪类 10 标签 伪元素 1 通配符 0 注：权重之间是256进制 CSS语法 基本样式 选择器{ 属性名1：属性值1; 属性名2：属性值2; 属性名3：属性值3; } /*例如定义一个div*/ div{ width:100px; height:100px; background:red; } 文字定义 font-size:16px; /* 调整文字大小 */ font-weight:bold; /* 调整文字粗细 可选属性，默认是 \"normal\"，\"bold\" 是加粗，可直接写数值: \"100-900\" 之间。*/ font-style:normal; /* 属性值：\"italic\" 斜体的字体样式, \"oblique\" 倾斜的字体样式*/ font-family:字体名称; /* 可以修改显示的字体 */ /*字体颜色定义，三种方法*/ color:rgb(0,0,0); /* 红，绿，蓝 三个颜色的值 0-255*/ color:#000000; /* 可以分开00-00-00，代表红，绿，蓝的值，用16进制数表示 */ color:red; /*直接所以英文颜色名字*/ 段落文字定义 /* 段落文字水平居中 */ text-align:center; /* 可以选属性，靠左 \"left\"，靠右：\"right\" */ line-height:10px; /* 行高，行间距 */ text-indent:2em; /* 首行缩进两个字符大小；1 em= 1 font-size */ text-decoration:line-through; /* 删除线 */ text-decoration:underline; /* 下划线 */ text-decoration:overline; /* 上划线 */ 边框 borde(边框) /* 边框宽度 | 边框样式 | 边框颜色 */ border:1px dashed green; /* \"dashed\" 虚线；\"solid\" 实线 */ /*可以分开4个边角定义*/ /* 例如左边left,可选 tiop，right，bottom */ border-left:1px dashed green; margin(外边距) padding（填充） margin/padding:1px ，margin/padding:30%； 对应四个上，下，左，右位置大小的值 可拆开， margin/padding-top，依此类推 元素的类型 每一个元素都有默认的 display 属性值； 行类元素 特点：内容决定元素所占位置，不可以通过css改变宽高 行内元素标签：span strong a em del CSS默认：display: inline; 凡是带有 inline 的元素，都有文字特征 块类元素 特点：独占一行，可以通过css改变宽高 块内元素标签：div p ul li ol form address CSS默认：disply: block; 行级块元素 特点：内容决定改变大小，可以通过css改变宽高 行级块元素标签：img CSS默认：disply: inline-block; 盒子模型 内容 CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin），边框（border），填充（padding），和实际内容（content）。 盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。 结构图 说明 Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像 宽度和高度的计算 总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距; 总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距 定位absolute 定位 脱离原来位置进行定位 位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;； absolute 定位使元素的位置与文档流无关，因此不占据空间 relative 定位 保留原来的位置进行定位 相对自己原来的位置进行定位 元素虽然偏移某个距离，但仍然占据原来的空间 fixed 定位 元素的位置相对于浏览器窗口是固定位置。 即使窗口是滚动的它也不会移动 CSS定位属性 top bottom left right 分别对应上，下，左，右位置的值，可用数值 与百分比 top:1px ，top:30%； .social-share { font-size: 0.85em !important; } 利用绝对定位居中.conter{ with:100px; higth:200px; /* 方法一 */ position:absolute; left:50%; top:50%; margin-top: -100px; /* ⾼度的⼀半 */ margin-left: -50px; /* 宽度的⼀半 * /* 方法二 */ position:absolute; left:0; top:0; right:0; bottom:0; margin:auto; /*实现绝对定位元素的居中(上下左右均0位置定位；margin: auto)*/ /* 子绝父相的居中*/ left:50%; top:50%; transform：translate(-50%，-50%); /* 让子盒子往左+往上走自己的一半 */ } 伪元素 伪元素：不存在文档中，是虚拟的元素，是创建新元素。代表某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中 ::after和::beore /*标签前面*/ .item::before { content: ''; /* 内容 ，不需要可以空，但是必定写上*/ color: red /* 和其他正常元素一样都可以定义其他属性*/ } /*标签后面*/ .item::after { content: ''; color: red } margin塌陷，合并BFC 块级格式化上下文，它是一个独立的渲染区域，让处于BFC内外的元素相互隔离，使内外元素的布局不会相互影响。 触发方法：1. position:absolute; 2. disply:inline-block; 3. float:left/right; 4. overflow:hidden; 注意： position:absolute; float:left/right; 把内部元素转换成inline-block margin塌陷 父子关系的子元素里，让子元素距离父元素的顶部50px,如果直接只给子元素margin-top：50px;子元素并没有距离父元素顶部50px，而是让父元素距离顶部有了50px的距离，也就是父元素的顶棚对子元素来说没有作用，相当于塌陷下来了，这就是所谓的margin塌陷。 解决方式 方案1： 子元素的margin-top改为padding-top方案2：给父元素添加样式触发BFC margin合并 两个兄弟元素，一个设置下边距为50px,一个设置上边距为30px； 结果：两个元素之间的间距是50px,也就是它们的margin-top和margin-bottom合并了，显示的是较大值。 解决方案 方案1：给其中一个兄弟元素套一个父元素，并且设置为overflow:hidden 方案2：只给其中一个元素margin-top或margin-bottom设置想要的间距 CSS float 属性float属性指定一个盒子（元素）是否应该浮动。 注意： 绝对定位的元素忽略float属性; div{ float:right; /* 向右浮动 */ } div{ float:left; /* 向左浮动 */ } 浮动元素会产生浮动流 浮动流元素，块级元素（block）看不见，会覆盖浮动流元素 产生BFC的元素和文本类属性（inline）的元素看得到浮动元素，不会覆盖 解决方法 方法一 给浮动的父级元素设置高度来占位，这样后面的元素就不会向上补齐。 方法二在浮动元素的后面添加一个元素，并添加一个clear:both 的属性来清除浮动 方法三 利用 overflow: hidden/auto清除浮动。子元素可以撑开父级的高度 方法四 利用伪元素清除浮动，给父级添加伪元素 .item::after { content: ''; display: block; clear:both; } CSS补充 单行文本超出容器截断文字用...省略 white-space: nowrap; /* 文本强制在一行上显示 */ overflow: hidden; /*对超出内容进行裁减 */ text-overflow:ellipsis; /* 显示省略符号...来代表被修剪的文本*/ 背景图片 div{ background-image:url(图片路径); /* 插入背景图片 */ background-repeat:no-repeat; /* 如果图片小，默认下，铺满容器，no-repeat取消重复 */ background-position:center; /* 图片位置 */ /* 图片位置可用值： left top left top .... ===== x% y% 水平垂直位置 */ } 嵌套问题 行级元素只能嵌套行级元素 块级元素可以嵌套任何元素 特殊注意： p标签不能嵌套div标签 a标签不能嵌套a标签 仿写淘宝静态网页笔记代码： 参考链接https://gitee.com/fantasy06/practiceCase/tree/master/html%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/taobao 重置样式 写网页时，新建一个reset.css，用来重置HTML页面的样式，因为许多标签默认有padding和margin CSS@用法/* @charset 设置样式表的编码 @import 引入其他样式文件 @media 媒体查询 @font-face 自定义字体 */ 设置网页图标&lt;link rel=\"icon\" href=\"favicon.ico\"&gt; /* ico的图标的格式 其他格式需要转换成ico格式才可设置网页图标篇 */ 效果图 网页的logo图片通常用H标签 base标签的作用一个单标签，位于网页头部文件的head标签内，一个页面最多只能使用一个base元素，用来提供一个指定的默认目标，也算是一种表达路径和连接网址的标记 base target属性/* 例如 */ &lt;base target=\"_blank\"&gt; target属性是网页窗口的打开方式，在base标签中设置该属性，那么页面中所有的链接都将遵循这个方式来打开网页，分别有如下几种选择： _blank ：在新窗口打开链接页面 _parent：在上一级窗口中打开链接。 _self ： 在当前窗口打开链接,此为默认值，可以省略。 _top： 在浏览器的整个窗口打开链接，忽略任何框架 引入字体图标阿里巴巴矢量图标库 选择想要的图标加入购物车 然后进入购物车点击下载代码，解压 项目目录下新建了个fonts目录来放iconfont.ttf文件 在index.css通过@引入字体和css 怪异盒模型盒模型： 1）标准盒模型 总宽度 = border(左右) + width + padding(左右) 总高度 = border(上下) + height + padding(上下) 2）IE混杂模型（怪异盒模型 --&gt; box-sizing: border-box） 总宽度 = width 总高度 = height 以图换字网速不够的时，浏览器就会采用默认的加载策略，也就是去掉网页的css和javaScript.但这时仍需保证网站的可用性，所以采用以图换字方法 文字隐藏 /* 文字放span标签 设置display隐藏 */ h1 { width: 66px; height: 66px; background: url(...); font-size: 12px; } span { display: none; } 负缩进 h1 { width: 66px; height: 66px; background: url(...); font-size: 12px; text-indent:-9999px; } 字体大小 h1 { width: 66px; height: 66px; background: url(...); font-size: 0; } 渐变颜色线性渐变 语法 background-image: linear-gradient(direction, color-stop1, color-stop2, ...); /* 方向(可省略，默认：to bottom), 起始颜色, 结束颜色*/ 从上到下（默认情况下） background-image: linear-gradient(#e66465, #9198e5); 效果图 角度渐变 语法 background-image: linear-gradient(angle, color-stop1, color-stop2); /* 与上类似*/ 实例 background-image: linear-gradient(-90deg, red, yellow); 效果图 使 ul 列表元素居中对齐 当ul列表中的所有li元素需要在父级盒子内部居中显示时，不能用 float: left; 直接在ul中设置”text-align: center;”, 再将li元素的display设置为inline-block，就可以实现居中显示。 表格布局 table标签 /* 表头为th；普通单元格为td；行为tr */ &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;February&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;/tr&gt; 效果图： 淘宝实用 /* 边框模式---合并的模式：即两个单元格之间的的边框只需要显示一个就行 */ table { border-collapse: collapse; } th,td { padding: 0; } .webp（图片格式） .webp 是谷歌开发的一种图片格式，只能用于在网站中显示，其体积相较于普通的图片格式小得多，且图片的清晰度不变，目前 IE不支持、火狐在65以上的版本支持，谷歌支持。 词强制换行/* 在空格的地方强制换行 */ word-break: keep-all; HTML5 CSS3","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"基础","permalink":"https://blog.luckjin.cool/tags/%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"vue","slug":"vue","permalink":"https://blog.luckjin.cool/categories/vue/"},{"name":"vscode","slug":"vscode","permalink":"https://blog.luckjin.cool/categories/vscode/"},{"name":"使用技巧","slug":"使用技巧","permalink":"https://blog.luckjin.cool/categories/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://blog.luckjin.cool/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.luckjin.cool/categories/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.luckjin.cool/categories/Node-js/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"vue","slug":"vue","permalink":"https://blog.luckjin.cool/tags/vue/"},{"name":"Ajax","slug":"Ajax","permalink":"https://blog.luckjin.cool/tags/Ajax/"},{"name":"vscode","slug":"vscode","permalink":"https://blog.luckjin.cool/tags/vscode/"},{"name":"工具","slug":"工具","permalink":"https://blog.luckjin.cool/tags/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"https://blog.luckjin.cool/tags/git/"},{"name":"小技巧","slug":"小技巧","permalink":"https://blog.luckjin.cool/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"node.js","slug":"node-js","permalink":"https://blog.luckjin.cool/tags/node-js/"},{"name":"基础","slug":"基础","permalink":"https://blog.luckjin.cool/tags/%E5%9F%BA%E7%A1%80/"}]}