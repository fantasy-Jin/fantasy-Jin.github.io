{"meta":{"title":"LuckJinのBlog","subtitle":"Fantasyの博客","description":"努力成为一名程序员","author":"Fantasy","url":"https://blog.luckjin.cool","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"404.html","permalink":"https://blog.luckjin.cool/404.html","excerpt":"","text":""},{"title":"404","date":"2022-08-05T06:26:30.000Z","updated":"2022-08-05T10:29:58.810Z","comments":true,"path":"404/index.html","permalink":"https://blog.luckjin.cool/404/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"https://blog.luckjin.cool/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-08-07T03:31:43.299Z","comments":false,"path":"about/index.html","permalink":"https://blog.luckjin.cool/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-08-07T06:32:12.012Z","comments":false,"path":"archives/index.html","permalink":"https://blog.luckjin.cool/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-08-07T05:18:48.404Z","comments":true,"path":"categories/index.html","permalink":"https://blog.luckjin.cool/categories/index.html","excerpt":"","text":""},{"title":"日常生活记录","date":"2022-08-08T10:07:59.000Z","updated":"2022-08-13T03:09:18.934Z","comments":true,"path":"bber/index.html","permalink":"https://blog.luckjin.cool/bber/index.html","excerpt":"","text":"window.TWIKOO_MAGIC_PATH=\"自言自语\" 说说内容来自 @Fantasy 的日常分享。🤪🤪 #article-container img { margin: 0 auto 0 !important; } ispeakBber.init({ el: '#speak', // 容器选择器 name: 'Fantasy', // 显示的昵称 envId: 'bber-8gg105ylae9c64be', // 环境id region: 'ap-guangzhou', // 腾讯云地址，默认为上海 limit: 7, // 每次加载的条数，默认为5 avatar: '/img/avatar.jpg', // 头像地址 fromColor:'rgb(245, 150, 170)', // 下方标签背景颜色 默认 rgb(245, 150, 170) loadingImg: 'https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg', // 自定义loading的图片，示例值为默认值 dbName:'talks' // 数据的名称，默认talks，避免有人的命名不是这个，所以加入此配置字段。 }) .then(function() { // 哔哔加载完成后的回调函数，你可以写你自己的功能 console.log('哔哔 加载完成') })"},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-08-06T03:50:23.678Z","comments":true,"path":"contact/index.html","permalink":"https://blog.luckjin.cool/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Blogの友链信息 博客名称: FantasyのBlog 博客介绍: The harder you work, the luckier you will be"},{"title":"Friends","date":"2022-08-08T08:26:56.000Z","updated":"2022-08-13T10:26:30.047Z","comments":true,"path":"friends/index.html","permalink":"https://blog.luckjin.cool/friends/index.html","excerpt":"","text":"欢迎留言添加友链 ✌️✌️- name: LuckJin's Blog link: https://blog.luckjin.cool/ avatar: https://picgo-fantasy06.oss-cn-guangzhou.aliyuncs.com/img/fantasy.jpg descr: 记录努力成为 前端er 学习之路"},{"title":"相册","date":"2022-08-07T07:44:20.000Z","updated":"2022-08-08T08:38:36.754Z","comments":false,"path":"galleryGroup/index.html","permalink":"https://blog.luckjin.cool/galleryGroup/index.html","excerpt":"","text":"Jay 我们的青春 动漫人物 关于的动漫人物图片 城市风光 城市一些美景 二次元风 关于的二次元风图片 花店 关于的清新花卉图片 动漫插画 关于的动漫插画图片 动漫风景 关于的动漫风景图片 呆萌猫咪 关于的呆萌猫咪图片 乖巧小狗 关于的乖巧小狗图片"},{"title":"gallery/pic1","date":"2022-08-07T07:45:42.000Z","updated":"2022-08-07T08:34:28.895Z","comments":false,"path":"gallery/index.html","permalink":"https://blog.luckjin.cool/gallery/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-08-07T03:02:30.000Z","updated":"2022-08-10T06:31:51.415Z","comments":true,"path":"messageboard/index.html","permalink":"https://blog.luckjin.cool/messageboard/index.html","excerpt":"","text":"畅所欲言 🤗🤗在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"空调房","date":"2022-08-08T09:24:44.000Z","updated":"2022-08-08T09:47:18.990Z","comments":false,"path":"kongt/index.html","permalink":"https://blog.luckjin.cool/kongt/index.html","excerpt":"","text":"客官，进来凉快会儿吧～document.documentElement.setAttribute(\"data-theme\", \"dark\"); 记得要节约用电哦"},{"title":"标签","date":"2019-07-19T08:40:27.000Z","updated":"2022-08-07T05:19:56.611Z","comments":false,"path":"tags/index.html","permalink":"https://blog.luckjin.cool/tags/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-08-07T04:20:54.260Z","comments":false,"path":"List/movies/index.html","permalink":"https://blog.luckjin.cool/List/movies/index.html","excerpt":"","text":"@media only screen and (max-width: 601px) { .movies-w { width: 90%; margin: 0 auto; } .movies-h { height: 90%; padding-top: 5%; padding-bottom: 5%; } } /*中等屏幕下(平板类)的样式*/ @media only screen and (min-width: 600px) and (max-width: 992px) { .movies-w { width: 95%; margin: 0 auto; } .movies-h { height: 95%; padding-top: 5%; padding-bottom: 5%; } } @media only screen and (min-width: 993px) { .movies-w { width: 80%; margin: 0 auto; } .movies-h { height: 80%; padding-top: 5%; padding-bottom: 5%; } } 📺 励 志 短 片 &lt;/div&gt;"},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-08-09T14:08:29.413Z","comments":true,"path":"List/music/index.html","permalink":"https://blog.luckjin.cool/List/music/index.html","excerpt":"","text":"欢迎，一起欣赏美妙的音乐吧！ / don’t remove. / .container { height: 70vh; } 周董现场大合集Taylor Swift纯音乐“时代的狂，音乐的王，万物臣服在我乐章！”"},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"https://blog.luckjin.cool/List/tools/index.html","excerpt":"","text":""},{"title":"Jay Chou 青春的模样","date":"2022-08-08T09:22:20.678Z","updated":"2022-08-08T09:22:20.678Z","comments":false,"path":"gallery/Jay/index.html","permalink":"https://blog.luckjin.cool/gallery/Jay/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-08-07T08:34:45.095Z","updated":"2022-08-07T08:34:45.095Z","comments":false,"path":"gallery/乖巧小狗/index.html","permalink":"https://blog.luckjin.cool/gallery/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-08-07T08:34:54.418Z","updated":"2022-08-07T08:34:54.418Z","comments":false,"path":"gallery/动漫人物/index.html","permalink":"https://blog.luckjin.cool/gallery/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-08-07T08:43:50.819Z","updated":"2022-08-07T08:43:50.819Z","comments":false,"path":"gallery/动漫风景/index.html","permalink":"https://blog.luckjin.cool/gallery/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-08-07T08:34:49.225Z","updated":"2022-08-07T08:34:49.225Z","comments":false,"path":"gallery/二次元风/index.html","permalink":"https://blog.luckjin.cool/gallery/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-08-07T08:35:12.798Z","updated":"2022-08-07T08:35:12.798Z","comments":false,"path":"gallery/城市风光/index.html","permalink":"https://blog.luckjin.cool/gallery/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-08-07T08:35:03.565Z","updated":"2022-08-07T08:35:03.565Z","comments":false,"path":"gallery/动漫插画/index.html","permalink":"https://blog.luckjin.cool/gallery/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-08-07T08:34:39.584Z","updated":"2022-08-07T08:34:39.584Z","comments":false,"path":"gallery/清新花卉/index.html","permalink":"https://blog.luckjin.cool/gallery/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-08-07T08:35:08.111Z","updated":"2022-08-07T08:35:08.111Z","comments":false,"path":"gallery/呆萌猫咪/index.html","permalink":"https://blog.luckjin.cool/gallery/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-08-07T08:34:35.820Z","updated":"2022-08-07T08:34:35.820Z","comments":false,"path":"gallery/自然风景/index.html","permalink":"https://blog.luckjin.cool/gallery/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"ES6模块化和异步编程的学习","slug":"ES6模块化和异步编程的学习","date":"2022-08-12T14:34:52.000Z","updated":"2022-08-13T04:22:35.845Z","comments":true,"path":"posts/b08fe5f9.html","link":"","permalink":"https://blog.luckjin.cool/posts/b08fe5f9.html","excerpt":"","text":"ES6 模块化ES6 模块化规范是浏览器端与服务器端通用的模块化开发规范。它的出现极大的降低了前端开发者的模块化学习成本，开发者不需再额外学习 AMD、CMD 或 CommonJS 等模块化规范。 ES6 模块化规范中定义： 每个 js 文件都是一个独立的模块 导入其它模块成员使用 import 关键字 向外共享模块成员使用 export 关键字 ES6 的模块化3种用法默认导出与默认导入按需导入与导出直接导入默认导出的语法： export default 默认导出的成员 //01_test.js // 定义成员和方法 let n1 = 10 let n2 = 20 function show(){} // 默认导出 export default{ n1, n2, show } 默认导入的语法：import 接收名称 from '模块标志符' 默认导入时的接收名称可以任意名称，只要是合法的成员名称即可 // 从 01_test.js 模块导入共享的成员 import test from './01_test.js' // 输出 { n1:10,n2:20,show:[funtion:show] } console.log(test) 每个模块中，只允许使用唯一的一次 export default，否则会报错！ 按需导出的语法：export 按需导出的成员 // 02_test.js // 向外按需导出变量 s1 export let s1 = 'abc' // 向外按需导出变量 s2 export let s1 = 123 // 向外按需导出方法 say export function say() {} 按需导入的语法： import { s1 } from '模块标识符' // 导入 02_test.js 模块成员 import {s1,s2,say} from './02test.js' // 输出 abc console.log(s1) // 输出 123 console.log(s2) // 输出 [funtion:say] console.log(say) 按需导出与按需导入的注意事项 每个模块中可以使用多次按需导出 按需导入的成员名称必须和按需导出的名称保持一致 按需导入时，可以使用 as 关键字进行重命名 按需导入可以和默认导入一起使用 如果只想单纯地执行某个模块中的代码，并不需要得到模块中向外共享的成员。此时，可以直接导入并执行模块代码 // 03_test.js // 执行一个循环 for(let i = 0;i&lt;3;i++){ console.log(i) } // 导入 import './03_test.js' // 直接运行此文件 // 输出 0，1，2，3，....10 Promise回调地狱多层回调函数的相互嵌套，就形成了回调地狱 setTimeout(() =&gt; { console.log(\"延迟1秒\"); setTimeout(() =&gt; { console.log(\"延迟2秒\"); setTimeout(() =&gt; { console.log(\"延迟2秒\"); }, 3000); }, 2000); }, 1000); 回调地狱的缺点： 代码耦合性太强，牵一发而动全身，难以维护 大量冗余的代码相互嵌套，代码的可读性变差 为了解决回调地狱的问题，ES6（ECMAScript 2015）中新增了 Promise 的概念。 Promise 的基本概念 Promise 是一个构造函数 我们可以创建 Promise的实例 const p = ne w Promise() new 出来的 Promise 实例对象，代表一个异步操作 Promise.prototype 上包含一个 .then() 方法 每一次 new Promise()构造函数得到的实例对象， 都可以通过原型链的方式访问到 .then() 方法，例如 p.then() .then() 方法用来预先指定成功和失败的回调函数 p.then(成功的回调函数，失败的回调函数) p.then(result =&gt; { }, error =&gt; { }) 调用 .then() 方法时，成功的回调函数是必选的、失败的回调函数是可选的 基于回调函数按顺序读取文件内容基于 then-fs 读取文件内容import fs from \"fs\"; // 读文件 1.txt fs.readFile(\"./files/1.txt\", \"utf8\", (err, r1) =&gt; { if (err) return console.log(err.message); console.log(r1); // 读文件 2.txt fs.readFile(\"./files/2.txt\", \"utf8\", (err, r2) =&gt; { if (err) return console.log(err.message); console.log(r2); // 读文件 3.txt fs.readFile(\"./files/3.txt\", \"utf8\", (err, r3) =&gt; { if (err) return console.log(err.message); console.log(r3); }); }); }); 调用 then-fs 提供的 readFile() 方法，可以异步地读取文件的内容，它的返回值是 Promise 的实例对象。因此可以调用 .then() 方法为每个 Promise 异步操作指定成功和失败之后的回调函数 Promise 支持链式调用，从而来解决回调地狱的问题 import thenFs from 'then-fs' // Promise 支持链式调用，从而来解决回调地狱的问题 thenFs // 返回值是 promise 的实列对象 .readFile(\"./files/1.txt\", \"utf8\") // 通过 .then 为第一个 promise 实例对象指定成功后的回调函数 .then((r1) =&gt; { console.log(r1); // 在第一个 .then 中返回一个新的 promise 对象 return thenFs.readFile(\"./files/2.txt\", \"utf8\"); }) // 继续调用 .then ，为上一个 .then 的返回值 (新的实例对象) // 指定成功后的回调函数 .then((r2) =&gt; { console.log(r2); return thenFs.readFile(\"./files/3.txt\", \"utf8\"); }) // 同理 继续调用 .then ，为上一个 .then 的返回值 (新的实例对象) .then((r3) =&gt; { console.log(r3); }) // 通过 .catch 捕获错误 // 前面的错误导致后续的 .then 无法正常执行 // 可以将.catch 的调用提前 .catch((err) =&gt; { console.log(err.message); }); Promise.all() 与 Promise.race() 方法Promise.all() 方法Promise.race() 方法Promise.all() 方法会发起并行的 Promise 异步操作，等所有的异步操作全部结束后才会执行下一步的.then操作（等待机制） import thenFs from \"then-fs\"; // 定义一个数组 存放异步读文件操作 const promiseArr = [ thenFs.readFile(\"./files/1.txt\", \"utf8\"), thenFs.readFile(\"./files/2.txt\", \"utf8\"), thenFs.readFile(\"./files/3.txt\", \"utf8\"), ]; // 将数组 作为 promise.all() 参数 Promise.all(promiseArr) .then(([r1, r2, r3]) =&gt; { // 所有文件读取成功 （等待机制） // 输出 r1 ，r2 ，r3 文件的内容 console.log(r1, r2, r3); }) .catch((err) =&gt; { console.log(err.message); }); // 数组中 Promise 实例的顺序， // 就是最终结果的顺序！ Promise.race() 方法会发起并行的 Promise 异步操作，只要任何一个异步操作完成，就立即执行下一步的.then操作（赛跑机制） import thenFs from \"then-fs\"; // 定义一个数组 存放异步读文件操作 const promiseArr = [ thenFs.readFile(\"./files/1.txt\", \"utf8\"), thenFs.readFile(\"./files/2.txt\", \"utf8\"), thenFs.readFile(\"./files/3.txt\", \"utf8\"), ]; // 将数组 作为 promise.race() 参数 Promise.race(promiseArr) .then((results) =&gt; { // 只要任何一个异步操作完成 就执行回调函数（赛跑机制） // 例如：文件2.txt 先读取完 // 就输出 2.txt 的文件内容 结束 console.log(results); }) .catch((err) =&gt; { console.log(err.message); }); async/awaitasync/await 是 ES8（ECMAScript 2017）引入的新语法，用来简化 Promise 异步操作 .then 链式调用的优点：解决了回调地狱的问题 .then 链式调用的缺点：代码冗余、阅读性差、不易理解 async/await 简化 Promise 异步操作的使用 import thenFs from \"then-fs\"; // 按顺序读取文件 1，2，3 的内容 async function getAllFile() { const r1 = await thenFs.readFile(\"./files/1.txt\", \"utf8\"); console.log(r1); const r2 = await thenFs.readFile(\"./files/2.txt\", \"utf8\"); console.log(r2); const r3 = await thenFs.readFile(\"./files/3.txt\", \"utf8\"); console.log(r3); } getAllFile(); async/await 的使用注意事项 如果在 function 中使用了 await，则 function 必须被 async 修饰 在 async 方法中，第一个 await 之前的代码会同步执行，await 之后的代码会异步执行 EventLoop（事件循环）JavaScript 主线程从“任务队列”中读取异步任务的回调函数，放到执行栈中依次执行。这个过程是循环不断的，所以整个的这种运行机制又称为 EventLoop（事件循环）。 Eventloop 例子 结合 EventLoop 分析输出的顺序import thenFs from \"then-fs\"; console.log('A'); thenFs.readFile(\"./files/3.txt\", \"utf8\").then(dataStr=&gt;{ console.log('B'); }) setTimeout(()=&gt;{ console.log('C'); },0) console.log('D');正确的输出结果：查看答案 ADCBA 和 D 属于同步任务。会根据代码的先后顺序依次被执行C 和 B 属于异步任务。它们的回调函数会被加入到任务队列中，等待主线程空闲时再执行 宏任务和微任务JavaScript 把异步任务又做了进一步的划分，异步任务又分为两类，分别是： 宏任务（macrotask） 异步 Ajax 请求、 setTimeout、setInterval、 文件操作 其它宏任务 微任务（microtask） Promise.then、.catch 和 .finally process.nextTick 其它微任务 宏任务和微任务的执行顺序 每一个宏任务执行完之后，都会检查是否存在待执行的微任务，如果有，则执行完所有微任务之后，再继续执行下一个宏任务。 宏任务和微任务日常例子 去银行办业务的场景小云和小腾去银行办业务。首先，需要取号之后进行排队宏任务队列假设当前银行网点只有一个柜员，小云在办理存款业务时，小腾只能等待单线程，宏任务按次序执行小云办完存款业务后，柜员询问他是否还想办理其它业务？当前宏任务执行完，检查是否有微任务小云告诉柜员：想要买理财产品、再办个信用卡、最后再兑换点马年纪念币？执行微任务，后续宏任务被推迟小云离开柜台后，柜员开始为小腾办理业务所有微任务执行完毕，开始执行下一个宏任务 宏任务和微任务练习例子 setTimeout(function () { console.log(1); }); new Promise(function (resolve) { console.log(2); resolve(); }).then(function () { console.log(3); }); console.log(4);查看答案 2431分析：先执行所有的同步任务第 6 行 ，第 12 行注：promise 是同步 ，promise.then 回调才是异步在执行所有的微任务第9行再执行下一个宏任务第2行","categories":[{"name":"前端篇","slug":"前端篇","permalink":"https://blog.luckjin.cool/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"MySql+Node.js","slug":"MySql-Node-js","date":"2022-08-11T13:23:50.000Z","updated":"2022-08-11T15:14:25.917Z","comments":true,"path":"posts/43bbf857.html","link":"","permalink":"https://blog.luckjin.cool/posts/43bbf857.html","excerpt":"","text":"数据库的数据组织结构数据的组织结构分为数据库(database)、数据表(table)、数据行(row)、字段(field)这 4 大部分组成。 实际开发中库、表、行、字段的关系 在实际项目开发中，一般情况下，每个项目都对应独立的数据库。 不同的数据，要存储到数据库的不同表中，例如：用户数据存储到 users 表中，图书数据存储到 books 表中。 每个表中具体存储哪些信息，由字段来决定，例如：我们可以为 users 表设计 id、username、password 这 3 个字段。 表中的行，代表每一条具体的数据 使用 SQL 管理数据库SQL（英文全称：Structured Query Language）是结构化查询语言，专门用来访问和处理数据库的编程语言。能够让我们以编程的形式，操作数据库里面的数据。 SQL 是一门数据库编程语言 使用 SQL 语言编写出来的代码，叫做 SQL 语句 SQL 语言只能在关系型数据库中使用（例如 MySQL、Oracle、SQL Server）。非关系型数据库（例如 Mongodb）不支持 SQL 语言 SQL 能做什么 从数据库中查询数据向数据库中插入新的数据更新数据库中的数据从数据库删除数据可以创建新数据库可在数据库中创建新表可在数据库中创建存储过程、视图etc 重点掌握使用 SQL 查询数据（select） 、插入数据（insert into） 、更新数据（update） 、删除数据（delete） 查询数据（select）插入数据（insert into）更新数据（update）删除数据（delete）SELECT 语句用于从表中查询数据。执行的结果被存储在一个结果表中（称为结果集 注意：SQL 语句中的关键字对大小写不敏感。SELECT 等效于 select，FROM 等效于 from -- 这是注释 -- 从 from 指定的 表中 ，查询所有的数据 * 表示所有列 select * from 表名称 -- 从 from 指定的表中，查询出指定 列名称（字段）的数据 select 列名称 from 表名称INSERT INTO 语句用于向数据表中插入新的数据行 -- 语法解读：向指定的表，插入如下几列的数据，列的值通过 values 指定 -- 列和值要一一对应，多个之间用逗号隔开 insert into table_name (列1，列2，...) values (值1，值2，...)Update 语句用于修改表中的数据 -- update 指定表 -- set 指定列对应的新值 -- where 指定更新的条件 update 表名称 set 列名称 = 新值 where 列名称 = 某值-- 从指定的表，根据 where 条件 ，删除对应数据行 delete from 表名称 where 列名称 = 值 SQL 的 WHERE 子句WHERE 子句用于限定选择的标准。在 SELECT、UPDATE、DELETE 语句中，皆可使用 WHERE 子句来限定选择的标准。 SQL 的 AND 和 OR 运算符 AND表示必须同时满足多个条件，相当于 JavaScript 中的 &amp;&amp; 运算符，例如 if (a !== 10 &amp;&amp; a !== 20) OR 表示只要满足任意一个条件即可，相当于 JavaScript 中的 || 运算符，例如 if(a !== 10 || a !== 20) SQL 的 ORDER BY 子句 ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 -- 对 users 表中的数据，按照 id 字段进行降序排序 select * from users order id desc -- 多重排序 -- 对 users 表中的数据，先按照 status 字段进行降序排序 -- 再按照 username 的字母顺序，进行升序排序 asc 表示升序 select * from users order by status desc, username asc SQL 的 COUNT(*) 函数COUNT(*) 函数用于返回查询结果的总数据条数 select count(*) from 表名称 -- 查询 users 表中 status 为 0 的总数据条数： select count(*) from where status=0 -- 使用 AS 为列设置别名 select count(*) AS total from where status=0 Node 操作 mysql配置 mysql 模块安装 mysql 模块 npm i mysql // 导入 const mysql =require('mysql') // 建立链接 const db =mysql.createPool({ // 数据库的 ip 地址 host:'127.0.0.1', // 用户名 user:'root', // 密码 password:'root', // 指定要操作的数据库 database:'tess', }) // 检测 mysql 模块是否正常工作 // 调用 db.query() 函数，指定要执行的 SQL 语句， // 通过回调函数拿到执行的结果 db.query('select 1', (err, results) =&gt; { if (err) return console.log(err.message) console.log(results) }) // 操作数据库 // 查询 db.query('select * from users', (err, results) =&gt; { ... }) // 插入 // ? 表示占位符 const sql = 'insert into users values(?, ?)' // 使用数组的形式为占位符指定具体的值 db.query(sql, [username, password], (err, results) =&gt; { if (err) return console.log(err.message) if (results.affectedRows === 1) console.log('插入成功') }) // 更新 const sql = 'update users set username=?, password=? where id=?' db.query(sql, [username, password, id], (err, results) =&gt; { ... }) // 快捷语法 const user = {id:7,username:'Bruce',password:'55520'} const sql = 'update users set ? where id=?' db.query(sql, [user, user.id], (err, results) =&gt; { ... }) // 删除 const sql = 'delete from users where id=?' db.query(sql, id, (err, results) =&gt; { ... }) //使用 delete 语句会真正删除数据， //保险起见，使用标记删除的形式，模拟删除的动作。 //即在表中设置状态字段，标记当前的数据是否被删除。 db.query('update users set status=1 where id=?', 7, (err, results) =&gt; { ... }) web开发模式服务端渲染 服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接动态生成的。因此客户端不需要使用 Ajax 额外请求页面的数据。 app.get('/index.html', (req, res) =&gt; { const user = { name: 'Bruce', age: 29 } const html = `&lt;h1&gt;username:${user.name}, age:${user.age}&lt;/h1&gt;` res.send(html) }) 优点： 前端耗时短。浏览器只需直接渲染页面，无需额外请求数据。 有利于 SEO。服务器响应的是完整的 HTML 页面内容，有利于爬虫爬取信息。 缺点： 占用服务器资源。服务器需要完成页面内容的拼接，若请求比较多，会对服务器造成一定访问压力。 不利于前后端分离，开发效率低。 前后端分离 前后端分离的开发模式，依赖于 Ajax 技术的广泛应用。后端只负责提供 API 接口，前端使用 Ajax 调用接口。 优点： 开发体验好。前端专业页面开发，后端专注接口开发。 用户体验好。页面局部刷新，无需重新请求页面。 减轻服务器的渲染压力。页面最终在浏览器里生成。 缺点： 不利于 SEO。完整的 HTML 页面在浏览器拼接完成，因此爬虫无法爬取页面的有效信息。Vue、React 等框架的 SSR（server side render）技术能解决 SEO 问题。 如何选择 企业级网站，主要功能是展示，没有复杂交互，且需要良好的 SEO，可考虑服务端渲染 后台管理项目，交互性强，无需考虑 SEO，可使用前后端分离 为同时兼顾首页渲染速度和前后端分离开发效率，可采用首屏服务器端渲染+其他页面前后端分离的开发模式 身份认证Session 认证机制服务端渲染推荐使用 Session 认证机制 Session 工作原理 Express 中使用 Session 认证 安装 npm install express-session 配置中间件 const session = require('express-session') app.use( session({ secret: 'fantsy06', // secret 的值为任意字符串 resave: false, saveUninitalized: true, }) ) 向 session 中存数据 // 中间件配置成功后，可通过 req.session 访问 session 对象，存储用户信息 app.post('/api/login', (req, res) =&gt; { req.session.user = req.body req.session.isLogin = true res.send({ status: 0, msg: 'login done' }) }) 从 session 取数据 app.get('/api/username', (req, res) =&gt; { if (!req.session.isLogin) { return res.send({ status: 1, msg: 'fail' }) } res.send({ status: 0, msg: 'success', username: req.session.user.username }) }) 清空 session app.post('/api/logout', (req, res) =&gt; { // 清空当前客户端的session信息 req.session.destroy() res.send({ status: 0, msg: 'logout done' }) }) JWT 认证机制前后端分离推荐使用 JWT（JSON Web Token）认证机制，是目前最流行的跨域认证解决方案 JWT 工作原理Session 认证的局限性： Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。 当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制 JWT 工作原理图： 用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。 JWT 组成部分： Header、Payload、Signature Payload 是真正的用户信息，加密后的字符串 Header 和 Signature 是安全性相关部分，保证 Token 安全性 三者使用 . 分隔 Header.Payload.Signature eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTcsInVzZXJuYW1lIjoiQnJ1Y2UiLCJwYXNzd29yZCI6IiIsIm5pY2tuYW1lIjoiaGVsbG8iLCJlbWFpbCI6InNjdXRAcXEuY29tIiwidXNlcl9waWMiOiIiLCJpYXQiOjE2NDE4NjU3MzEsImV4cCI6MTY0MTkwMTczMX0.bmqzAkNSZgD8IZxRGGyVlVwGl7EGMtWitvjGD-a5U5c JWT 使用方式： 客户端会把 JWT 存储在 localStorage 或 sessionStorage 中 此后客户端与服务端通信需要携带 JWT 进行身份认证，将 JWT 存在 HTTP 请求头 Authorization 字段中 加上 Bearer 前缀 Authorization: Bearer &lt;token&gt; Express 使用 JWT 安装 jsonwebtoken 用于生成 JWT 字符串 express-jwt 用于将 JWT 字符串解析还原成 JSON 对象 npm install jsonwebtoken express-jwt 定义 secret 密钥 为保证 JWT 字符串的安全性，防止其在网络传输过程中被破解，需定义用于加密和解密的 secret 密钥 生成 JWT 字符串时，使用密钥加密信息，得到加密好的 JWT 字符串 把 JWT 字符串解析还原成 JSON 对象时，使用密钥解密 const jwt = require('jsonwebtoken') const expressJWT = require('express-jwt') // 密钥为任意字符串 const secretKey = 'fantasy' 生成 JWT 字符串 app.post('/api/login', (req, res) =&gt; { ... res.send({ status: 200, message: '登录成功', // jwt.sign() 生成 JWT 字符串 // 参数：用户信息对象、加密密钥、配置对象-token有效期 // 尽量不保存敏感信息，因此只有用户名，没有密码 token: jwt.sign({username: userInfo.username}, secretKey, {expiresIn: '10h'}) }) }) JWT 字符串还原为 JSON 对象 客户端访问有权限的接口时，需通过请求头的 Authorization 字段，将 Token 字符串发送到服务器进行身份认证 服务器可以通过 express-jwt 中间件将客户端发送过来的 Token 解析还原成 JSON 对象 // unless({ path: [/^\\/api\\//] }) 指定哪些接口无需访问权限 app.use(expressJWT({ secret: secretKey }).unless({ path: [/^\\/api\\//] })) 获取用户信息 当 express-jwt 中间件配置成功后，即可在那些有权限的接口中，使用 req.user 对象，来访问从 JWT 字符串中解析出来的用户信息 app.get('/admin/getinfo', (req, res) =&gt; { console.log(req.user) res.send({ status: 200, message: '获取信息成功', data: req.user, }) }) 捕获解析 JWT 失败后产生的错误 当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行 通过 Express 的错误中间件，捕获这个错误并进行相关的处理 app.use((err, req, res, next) =&gt; { if (err.name === 'UnauthorizedError') { return res.send({ status: 401, message: 'Invalid token' }) } res.send({ status: 500, message: 'Unknown error' }) })","categories":[{"name":"前端篇","slug":"前端篇","permalink":"https://blog.luckjin.cool/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"node.js","slug":"node-js","permalink":"https://blog.luckjin.cool/tags/node-js/"}]},{"title":"Express+Node.js的学习","slug":"Express-Node-js的学习","date":"2022-08-11T08:29:04.000Z","updated":"2022-08-13T12:57:16.995Z","comments":true,"path":"posts/9c8c3744.html","link":"","permalink":"https://blog.luckjin.cool/posts/9c8c3744.html","excerpt":"","text":"Express 认识官网链接 ：https://www.expressjs.com.cn/ Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。 安装 Express nmp i express 创建基本服务器const express = require('express') // 创建 web 服务器 const app = express() // 监听客户端的 GET 和 POST 请求 // 并向客户端响应具体内容 //通过 app.get(’请求url‘，function(req,res)) 方法， //可以监听客户端的 GET 请求 app.get('/user',(req,res)=&gt;{ res.send({ name:'湘伦', age:'18' }) }) // post 请求 语法和 get 的差别不大 app.post('/user',(req,res)=&gt;{ res.send('ok') }) // 通过 req.query 可以获取到客户端发送过来的查询参数 app.get('/user',(req,res)=&gt;{ // req.query 默认是空对象 // 客户端使用 ?name=zs&amp;age20 查询字符串的形式，发送到服务器 // 可以通过req.query 对象访问 // 例如 输出 zs console.log(req.query.name) }) // 通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数 // 这里的 :id 是一个动态的参数 app.get('/user/:ids/:username', (req, res) =&gt; { // req.params 是动态匹配到的 URL 参数，默认是一个空对象 console.log(req.params) res.send(req.params) }) // 启动服务器 app.listen(80, () =&gt; { console.log('express server running at http://127.0.0.1') }) 托管静态资源 通过 express.static() 方法可创建静态资源服务器，向外开放访问静态资源。 Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，存放静态文件的目录名不会出现在 URL 中 访问静态资源时，会根据托管顺序查找文件 可为静态资源访问路径添加前缀 app.use(express.static('public')) app.use(express.static('files')) app.use('/bruce', express.static('bruce')) /* 可直接访问 public, files 目录下的静态资源 http://localhost:3000/images/bg.jpg http://localhost:3000/css/style.css http://localhost:3000/js/login.js 通过带有 /bruce 前缀的地址访问 bruce 目录下的文件 http://localhost:8080/bruce/images/logo.png */ Express 路由在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系 简单用法在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上 const express = require('express') // 创建 web 服务器，命名为 app const app = express() // 挂载路由 app.get('/',(req,res)=&gt;{ res.send('hello world') }) app.post('/',(req,res)=&gt;{ res.send('hello world') }) // 启动服务器 app.listen(80,()=&gt;{ console.log('express server running at http://127.0.0.1') }) 模块化路由为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。 将路由抽离为单独模块的步骤如下： 创建路由模块对应的 .js 文件 调用 express.Router() 函数创建路由对象 向路由对象上挂载具体的路由 使用 module.exports 向外共享路由对象 使用 app.use() 函数注册路由模块 创建路由模块// user.js const express = require('express') // 创建路由对象 const router = express.Router() // 挂载获取用户列表的路由 router.get('/user/list',(req,res)=&gt;{ res.send('Get user list') }) // 挂载添加用户列表的路由 router.post('/user/add',(req,res)=&gt;{ res.send('add new user ') }) // 向外共享 module.exports = router 注册使用路由模块// app.js const express = require('express') // 创建 web 服务器，命名为 app const app = express() // 导入路由模块 const userRouter = require('./router/user.js') // 使用 app.use() 注册路由模块，添加统一访问的前缀 api app.use('/api',userRouter) Express 中间件概念注意事项 中间件是指流程的中间处理环节 服务器收到请求后，可先调用中间件进行预处理 中间件是一个函数，包含 req, res, next 三个参数，next() 参数把流转关系交给下一个中间件或路由 在注册路由之前注册中间件（错误级别中间件除外） 中间件可连续调用多个 别忘记调用 next() 函数 next() 函数后别写代码 多个中间件共享 req、 res对象 全局作用域通过 app.use() 定义的中间件为全局中间件 // 定义第一个全局中间件 app.use((req, res, next) =&gt; { console.log('调用了第1个全局中间件') next() }) // 定义第二个全局中间件 app.use((req, res, next) =&gt; { console.log('调用了第2个全局中间件') next() }) 局部中间件不使用 app.use() 定义的中间件，叫做局部生效的中间件 // 定义中间件函数 const mw = (req,res,next)=&gt;{ console.log('局部中间件函数') next() } // 使用，只能在当前使用的路由生效，其他的路由无法使用 app.get('/',mw,(req,res)=&gt;{}) 中间件的类型应用级别的中间件路由级别的中间件错误级别的中间件Express 内置的中间件第三方的中间件通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件 // 应用级别的中间件(全局中间件) app.use((req,res,next)=&gt;{ next() }) // 应用级别的中间件(局部中间件) app.get('/',mw,(req,res)=&gt;{ next() })绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上 const app = express() const router = express.Router() // 路由级别的中间件 router.use(function (req, res, next) { console.log(1) next() }) app.use('/', router)错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题 格式：错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 (err, req, res, next) 错误级别的中间件必须注册在所有路由之后 const express = require('express') const app = express() app.get('/', (req, res) =&gt; { // 抛出错误 throw new Error('服务器内部发生了错误！') res.send('Home page.') }) // 定义错误级别的中间件， //捕获这个项目的异常错误，从而防止程序崩溃 app.use((err,res,req,next)=&gt;{ console('发生了错误！' + err.message) res.send('Error:' + err.message) }) 自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验 express.static 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性） express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用） express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用 非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置第三方中间件，从而提高项目的开发效率。 例如：在 express@4.16.0之前的版本中，经常使用 body-parser 这个第三方中间件，来解析请求体数据。使用步骤如下： ① 运行 npm install body-parser 安装中间件 使用 require 导入中间件 调用 app.use() 注册并使用中间件 CORS 跨域资源共享使用： 安装中间件：npm install cors 导入中间件：const cors = require('cors') 配置中间件：app.use(cors()) 注意事项： CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。 CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。 CORS 响应头部 - Access-Control-Allow-Origin：响应头部中可以携带一个 Access-Control-Allow-Origin 字段 // 指定域名访问 res.setHeader('Access-Control-Allow-Origin', 'http://blog.luckjin.cool') // 任何域可访问 res.setHeader('Access-Control-Allow-Origin', '*') 默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一） 如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！ 默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。 如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法。 // 只允许 POST, GET, DELETE, HEAD 请求方式访问 res.setHeader('Access-Control-Allow-Methods', 'POST, GET, DELETE, HEAD') // 允许所有 http 的请求方式 res.setHEader('Access-Control-Allow-Methods', '*') CORS 请求分类 简单请求 请求方式：GET、POST、HEAD 三者之一 HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application/x-www-formurlencoded、multipart/form-data、text/plain） 预检请求 请求方式为 GET、POST、HEAD 之外的请求 Method 类型 请求头中包含自定义头部字段 向服务器发送了 application/json 格式的数据 在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据 简单请求和预检请求的区别 简单请求的特点：客户端与服务器之间只会发生一次请求。 预检请求的特点：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。 使用 Express 写接口// app.js // 创建基本服务器 const express = require('express') // 创建服务器实例 const app = express() // 如果要获取 URL-encoded 格式的请求体数据， // 必须配置中间件 app.use(express.urlencoded({ extended: false })) app.use(express.urlencoded({ extended: false })) // 导入注册路由模块 const apiRouter = require('./apiRouter.js') app.use('/api',apiRouter) // 启动服务器 app.listen(80,function(){ console.log('express server running at http://127.0.0.1') }) // =======分割线======= // apiRouter.js 路由模块 const express = require('express') const apiRouter = express.Router() // 编写 GET 接口 apiRouter.get('/get',(req,res)=&gt;{ // 获取客户端通过查询字符串发送过来的数据 const query = req.query // 调用 res.send()方法，把数据响应给客户端 res.send({ // 状态 ，0成功 ，1失败 status:0, msg:'GET请求成功' // 数据响应给客户端 data:query }) }) // 编写 POST 接口 apiRouter.post('/get',(req,res)=&gt;{ // 获取客户端通过请求体，发送到服务器的 URL-encoded 数据 const body = req.body // 调用 res.send()方法，把数据响应给客户端 res.send({ // 状态 ，0成功 ，1失败 status:0, msg:'POST请求成功' // 数据响应给客户端 data:body }) }) // 导出 module.exports = apiRouter","categories":[{"name":"前端篇","slug":"前端篇","permalink":"https://blog.luckjin.cool/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"node.js","slug":"node-js","permalink":"https://blog.luckjin.cool/tags/node-js/"}]},{"title":"Node.js的入门学习","slug":"node-js的学习","date":"2022-08-09T02:31:30.000Z","updated":"2022-08-11T10:33:05.833Z","comments":true,"path":"posts/4c2cf4e9.html","link":"","permalink":"https://blog.luckjin.cool/posts/4c2cf4e9.html","excerpt":"","text":"Node.js 简介运行环境 浏览器是 Javascript 的前端运行环境 Node. js 的 Javascript 的后端运行环境 Node.js中无法调用 DOM 和 BOM 等浏览器内置的API 应用场景 基于 Express 框架,可以快速构建 Web 应用 http://www.expressjs.com.cn/ 基于 Electron 框架，可以构建跨平台的桌面应用 https://electronjs.org/ 基于 restify 框架，可以快速构建 API 接口项目 http://restify.com/ 读写和操作数据库、创建实用的命令行工具辅助前端开发、etc… fs 文件系统模块读写文件fs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求 如果要使用 fs 模块需要先导入 const fs=require('fs') 读取指定文件向指定文件写入内容使用 fs.readFile()方法，可以读取指定文件中的内容 fs.readFile(path[,options],callback) path 必选参数，字符串格式，表示文件路径 options 可选参数，表示指定编码格式来读取文件。 callback 必选参数，读取文件后的回调函数，函数形参 (err,dataStr) err 读取失败的结果 dataStr 读取成功的文件内容 读取文件例子📄 const fs=require(fs) fs.readFlie('./files/test.txt','ut8f',function(err,dataStr){ // 失败的结果 console.log(err) // 读取成功的文件内容 console。log(dataStr) }) 使用 fs.writeFile() 方法，可以向指定的文件中写入内容 fs.writeFile(file,data[,options],callback) file 必选参数，字符串格式，表示存放文件路径 data 必选参数，表示写入的内容 options 可选参数，表示指定编码格式来写入文件，默认 utf8 。 callback 必选参数，写入文件后的回调函数，函数形参 (err) err 读取失败的结果 写入文件的例子📄 const fs=require('fs') fs.writeFile('./files/test2.txt','Hello world!',function(err){ // 可以通过判断 err 对象是否为null ，从而判断文件写入结果 if(err){ // 失败的结果 return console.log('文件写入失败'+err.message) } console.log('写入成功') }) 路径动态拼接在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。 解决方案：采用 __dirname 拼接 // --dirname 表示当前文件夹所处路径 fs.writeFile(__dirname + './files/test2.txt','Hello world!',function(err){ // 可以通过判断 err 对象是否为null ，从而判断文件写入结果 if(err){ // 失败的结果 return console.log('文件写入失败'+err.message) } console.log('写入成功') }) path 路径模块path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求 如果要使用 path 模块需要先导入 const path=require('path') path.join() 方法作用：把多个路径片段拼接为完整的路径字符串 path.join([...paths]) ...paths &lt;string&gt; 路径片段的序列 返回值：&lt;string&gt; 示例 const pathStr=path.join('/a','/b/c','../','./d','e') // 输出 \\a\\b\\d\\e console.log(pathStr) const pathStr2=path.join(__dirname,'./files/1.txt') // 输出 当前文件所处的文件目录\\files\\1.txt凡是涉及到路径拼接的操作，推荐使用 path.join() 方法进行处理。不要直接使用 + 进行字符串的拼接 path.basename() 方法作用：可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名 path.basename(path[,ext]) path 必选参数，表示一个路径的字符串 ext &lt;string&gt; 可选参数，表示文件拓展名 返回值：&lt;string&gt; 表示路径最后一部分 示例获取路径中的文件名 const fpath='/a/b/c/index.html' const fullName=path.basename(fpath) // 返回值就是文件名 输出index.html console.log(fullName) const fullName2=path.basename(fpath,'.html') // 返回值就是文件名去掉 .html 输出index console.log(fullName1) path.extname() 方法作用：可以获取路径中的扩展名部分 path.extname(path) path &lt;string&gt;必选参数，表示一个路径的字符串 返回： &lt;string&gt; 返回得到的扩展名字符串 示例获取路径中的文件的扩展名 const fpath='/a/b/c/index.html const fext =path.extname(fpath) // 输出后缀名 .html console.log(fext) http 模块http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块 如果要使用 http 模块需要先导入 const http=require('http') 创建基本的服务器基本服务器简陋路由功能的服务器// 导入http模块 const http=require('http') //调用 http.createServer() 方法，创建一个 web 服务器实例 const server=http.creatServer() // 用服务器实例的 .on 绑定为服务器 request 事件 // 即可监听客户端发送过来的网络请求 server.on('request',(req,res)=&gt;{ // 只要有客户端请求我们的服务器，就触发 requset 事件 // 就会执行这个回调函数 console.log('hello world') // req 是请求对象，包含客户端的数据和属性 // 例如 req.url 是客户端的请求 url 地址 // req.mothod 是客户端的请求类型 // res 是响应对象 ，包含服务器的数据和属性 // res.send() 给客户端发送指定内容 结束请求 res.send('hello world') // 给客户端发送 hello.. 并且结束请求 // res.end() 方法，向客户端发送中文时， // 会出现乱码问题，设置内容的编码格式 // 设置响应头 Content——Type 的值为 // text/html; charset=utf-8 res.setHeader('Content——Type','text/html; charset=utf-8') }) // 调用服务器实例的 .listen(端口号，回调函数) 方法，启动当前的服务器实例 sever.listen(80,()=&gt;{ console.log('sever running at http://127.0.0.1:80') })根据不同的 url 响应不同的 html 内容 实现步骤 获取请求的 url 地址 设置默认的响应内容为 404 Not found 判断用户请求的是否为 / 或 /index.html 首页 判断用户请求的是否为 /about.html 关于页面 设置 Content-Type 响应头，防止中文乱码 使用 res.end() 把内容响应给客户端 // 导入http模块 const http=require('http') //调用 http.createServer() 方法，创建一个 web 服务器实例 const server=http.creatServer() // 用服务器实例的 .on 绑定为服务器 request 事件 // 即可监听客户端发送过来的网络请求 server.on('request',(req,res)=&gt;{ // 获取请求的 url 地址 const url = req.url // 设置默认的响应内容为 404 Not found let content='404 not found!' // 判断 if(url === '/' || url ==='/index.html'){ // 用户请求是首页 content = '首页' }else if(url === '/about.html'){ // 用户请求是关于页 content = '关于页面' } // 设置响应头防止中文乱码 res.setHeader('Content——Type','text/html; charset=utf-8') // 发送内容给客户端 res.send(content) }) // 调用服务器实例的 .listen(端口号，回调函数) 方法，启动当前的服务器实例 sever.listen(80,()=&gt;{ console.log('sever running at http://127.0.0.1:80') }) 模块化概念 模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。 模块化可提高代码的复用性和可维护性，实现按需加载。 模块化规范是对代码进行模块化拆分和组合时需要遵守的规则，如使用何种语法格式引用模块和向外暴露成员。 分类Node.js 中模块的分类 内置模块 自定义模块 第三方模块 模块作用域 和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域 防止全局变量污染 模块作用域的成员 自定义模块中都有一个 module 对象，存储了和当前模块有关的信息 在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。导入自定义模块时，得到的就是 module.exports 指向的对象。 默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，以 module.exports 指向的对象为准 CommonJS 模块化规范 每个模块内部，module 变量代表当前模块。 module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。 加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块。 模块加载机制模块第一次加载后会被缓存，即多次调用 require() 不会导致模块的代码被执行多次，提高模块加载效率。 内置模块加载优先级最高 自定义模块加载自定义模块时，路径以 ./ 或 ../ 开头，否则会作为内置模块或第三方模块加载。 导入自定义模块时，可以省略文件拓展名，Node.js 会按顺序加载文件 按确切的文件名加载 补全 .js 加载 补全 .json 加载 补全 .node 加载 报错 第三方模块 若导入第三方模块， Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块。 如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录 例如，假设在 C:\\Users\\fantasy\\project\\foo.js 文件里调用了 require('tools')，则 Node.js 会按以下顺序查找： C:\\Users\\fantasy\\project\\node_modules\\tools C:\\Users\\fantasy\\node_modules\\tools C:\\Users\\node_modules\\tools C:\\node_modules\\tools ​ 目录作为模块加载 ​ 当把目录作为模块标识符进行加载的时候，有三种加载方式： 在被加载的目录下查找 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口 如果没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。 若失败则报错","categories":[{"name":"前端篇","slug":"前端篇","permalink":"https://blog.luckjin.cool/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"node.js","slug":"node-js","permalink":"https://blog.luckjin.cool/tags/node-js/"}]},{"title":"javascript 进阶","slug":"Javscipt ","date":"2022-07-26T08:42:00.000Z","updated":"2022-08-11T12:23:35.925Z","comments":true,"path":"posts/d15997ef.html","link":"","permalink":"https://blog.luckjin.cool/posts/d15997ef.html","excerpt":"","text":"作用域 作用域规定了变量能够被访问的范围，离开这个范围变量就不能被访问 作用域分为： 局部作用域局部作用域分为函数作用域和块作用域。 函数作用域： 在函数内部声明的变量只能在函数内部被访问，外部无法访问 总结： 函数内部声明的变量，在函数外部无法被访问 函数的参数也是函数内部的局部的变量 不同函数内部声明的变量无法相互访问 函数执行完毕后，函数的变量实际被清空了 块作用域： 在JavaScript中使用 {} 包裹的代码块内部声明的变量外部将有可能无法被访问 for(let i=0;i&lt;10;i++){ // i 只能的该代码块中被访问 console.log(i) } // 超出了t的作用域 ，报错 console.log(i) 总结： let 声明的变量，const 声明的常量，都会产生块级作用域 var 声明的变量不会产生块级作用域 不同代码块之间的变量无法相互访问 推荐使用 let 和 const 全局作用域 在 &lt;script&gt; 标签 和 .js 文件的最外层就是全局作用域，在此声明的变量在函数内部也可以访问，全局作用域下声明的变量，任何其他作用域都可以被访问 //全局作用域，下声明变量num const num=10 function fn(){ //函数内部可以使用 console.log(num) } 注意： 为 window 对象动态添加的属性默认也是全局的，不推荐 函数未使用任何关键字声明的变量为全局变量，不推荐 尽可能少的声明全局变量，防止全局变量被污染 作用域链 作用域链本质是底层的变量查找机制 函数在被执行时，会优先找当前函数作用域中查找变量 如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域 //全局作用域 let a = 1 let b = 2 //局部作用域 function f() { let a = 1 function g() { a = 2 console.log(a) // 2 } g() } f() 总结： 嵌套更新的作用域串联起来形成了作用域链 相同作用域链中按着从小到大的规则查找变量 子作用域能够访问父级作用域，父级作用域无法访问子级作用域 JS 的垃圾回收机制 垃圾回收机制 (Garbage Collection) 简称 GC JS 中的内存的分配和回收都是自动完成的，，内存在不使用的时候会被垃圾回收器自动回收。 但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况 不再用到的内存，没有及时释放，就叫做内存泄漏 内存的生命周期 ： 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用：即读写内存，也就是使用变量、函数等 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 全局变量一般不会回收(关闭页面回收)； 一般情况下局部变量的值, 不用了, 会被自动回收掉 垃圾回收算法说明 所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉下面介绍两种常见的浏览器垃圾回收算法: 引用计数法 和 标记清除法 引用计数IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。算法： 跟踪记录每个值被引用的次数。 如果这个值的被引用了一次，那么就记录次数1 多次引用会累加。 如果减少一个引用就减1。 如果引用次数是0 ，则释放内存。 引用计数算法是个简单有效的算法。但它却存在一个致命的问题：嵌套引用。如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。 标记清除法现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。核心： 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进 行回收。 闭包 概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域简单理解：闭包 = 内层函数 + 外层函数的变量 function outer() { const a = 1 function f(){ console.log(a) } f() } outer // 内层函数调用外层函数的变量，就是闭包 作用： 封闭数据，提供操作，外部也可以访问函数内部的变量 基本格式： 闭包应用：实现数据的私有比如，我们要做个统计函数调用次数，函数调用一次，就++ 普通写法 let count = 1 function fn() { count++ console.log(count) } fn() //2 fn() //3 这个count 是个全局变量，很容易被修改 闭包写法： function fn() { let count = 1 return function fun() { count++ console.log(count) } } const result =fn() result() //2 result() //3 实现了数据私有，无法直接修改count 闭包可能引起的问题：内存泄漏 变量提升 变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问（仅存在于var声明变量） console.log(str) //不报错 控制台显示undefined var str = 'hello' 注意： 变量在未声明即被访问时会报语法错误 变量在var声明之前即被访问，变量的值为 undefined let / const 声明的变量不存在变量提升 变量提升出现在相同作用域当中 实际开发中推荐先声明再访问变量 函数进阶函数提升函数提升与变量提升比较类似，是指函数在声明之前即可被调用。 函数参数 动态参数 arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参 //求和函数 不管用户传入几个实参，都要把和求出来 function sum() { let s = 0 for(let i = 0;i &lt; arguments.length;i++){ s += arguments[i] } return s } sum(5,10) //15 sum(1,2,3) //6 剩余参数 剩余参数允许我们将一个不定数量的参数表示为一个数组 ... 是语法符号，置于最末函数形参之前，用于获取多余的实参 借助 ... 获取的剩余实参，是个真数组 function sum(...other) { let s = 0 for(let i = 0;i &lt; other.length;i++){ s += other[i] } return s } sum(5,10) //15 sum(1,2,3) //6 区别： … 是语法符号，置于最末函数形参之前，用于获取多余的实参 借助 … 获取的剩余实参，是个真数组 展开运算符：... 展开运算符 (…)， 将一个数组进行展开，不会修改原数组 const arr=[1,2,3,4,5] console.log(...arr) //1 2 3 4 5 典型运用场景： 求数组最大值(最小值)、合并数组等 const arr=[1,2,3,6,4,5] const arr2=[7,8,9] //最大值 const max=Math.max(...arr) //合拼 const arr3=[...arr,...arr2] 展开运算符 or 剩余参数剩余参数：函数参数使用，得到真数组展开运算符：数组中使用，数组展开 箭头函数语法： //普通函数 const fn = function (){ ... } fn() //1.箭头 无参数 const fn = () =&gt;{ ... } //2.只有一个参数 const fn = x=&gt; { return x } //3.函数体只有一行代码，可以写一行上，无需写 return 直接返回值 const fn = (x,y) =&gt; x + y //返回 x + y 的值 //加括号的函数体返回对象字面量表达式 const fn1 = uname =&gt;({uname : uname}) console.log(fn1('叶湘伦')) //控制台：{uname:\"叶湘伦\"} 箭头函数属于表达式函数，因此不存在函数提升 箭头函数只有一个参数时可以省略圆括号 () 箭头函数函数体只有一行代码时可以省略花括号 {}，并自动做为返回值被返回 加括号的函数体返回对象字面量表达式 箭头函数参数： 普通函数有 arguments 动态参数 箭头函数没有 arguments动态参数，但是有 剩余参数 ..args 箭头函数 this：在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值箭头函数不会创建自己的 this ,它只会从自己的作用域链的上一层沿用 this 。 在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此，DOM事件回调函数为了简便，还是不太推荐使用箭头函数 数组解构 数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法。 // 普通的数组 let arr = [1, 2, 3]; // 批量声明变量 a b c // 同时将数组单元值 1 2 3 依次赋值给变量 a b c let [a, b, c] = arr; console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 基本语法： 赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量 变量的顺序对应数组单元值的位置依次进行赋值操作 变量的数量大于单元值数量时，多余的变量将被赋值为 undefined 变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位 允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效 对象解构 // 普通对象 const user = { name: '小明', age: 18 }; // 批量声明变量 name age // 同时将数组单元值 小明 18 依次赋值给变量 name age const {name, age} = user console.log(name) // 小明 console.log(age) // 18 总结： 赋值运算符 = 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量 对象属性的值将被赋值给与属性名相同的变量 对象中找不到与变量名一致的属性时变量值为 undefined 允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效 遍历数组 forEach 方法 forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数 遍历数组.forEach(function (当前数组元素,索引号){ //函数体 }) 注意： forEach 主要是遍历数组 参数当前数组元素是必须要写的， 索引号可选。 筛选数组 filter 方法 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素 主要使用场景： 筛选数组符合条件的元素，并返回筛选之后元素的新数组 遍历数组.filter(function (当前数组元素,索引号){ return 筛选条件 }) //筛选数组大于30的元素 const arr=[10,26,62,61,56,12,36] const re = arr.filter(function(item){ return item &gt; 30 }) console.log(re) //[62,61,56,36] 返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组参数：currentValue 必须写， index 可选因为返回新数组，所以不会影响原数组 对象创建方法 利用字面量创建 const obj = { name:'叶湘伦', age:18 } 利用 new Object 创建对象 const obj = new Object({ name:'叶湘伦', age:18 }) 利用构造函数创建 // 构造函数 function Obj(name,age){ this.name = name this.age = age } //创建一个对象 const Stu = new Obj('叶湘伦'，18) 注意： 语法：大写字母开头的函数 约定：它们的命名以大写字母开头。只能由 “new” 操作符来执行。 说明： 使用 new 关键字调用函数的行为被称为实例化 实例化构造函数时没有参数可以省略（） 构造函数内部不用写 return ，返回值即为新建的对象 new Object（） new Date（） 也是实例化构造函数 实列化执行过程： 创建一个新空对象 构造函数 this 指向新对象 执行构造函数代码，修改 this ，添加新的属性 返回新的对象 实例对象 通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员 // 构造函数 function Obj(name,age){ //构造函数内部的 this 就是实例对象 //实例对象中动态添加属性 this.name = name this.age = age //实例对象中动态添加方法 this.sayHi = function () { console.log('hi') } } //实例化 ，Stu 是实列对象 // Stu 实际就是构造函数内部的 this const Stu = new Obj('叶湘伦'，18) //访问实例属性 console.log(Stu.name) //调用实列方法 Stu.sayHi() 说明： 实例对象的属性和方法即为实例成员 为构造函数传入参数，动态创建结构相同但值不同的对象 构造函数创建的实例对象彼此独立互不影响。 静态成员： 在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。 // 构造函数 function Obj(name,age){ //实例成员 } //静态属性 Obj.eyes = 2 Obj.arms = 2 //静态方法 Obj.walk = funtion () { console.log('走路中') //this 指向 person console.log(this.eyes) } 总结： 静态成员指的是添加到构造函数本身的属性和方法 一般公共特征的属性或方法静态成员设置为静态成员 静态成员方法中的 this 指向构造函数本身 内置构造函数 在 JavaScript 中最主要的数据类型有 6 种，分别是字符串、数值、布尔、undefined、null 和 对象，常见的对象类型数据包括数组和普通对象。其中字符串、数值、布尔、undefined、null 也被称为简单类型或基础类型，对象也被称为引用类型。 在 JavaScript 内置了一些构造函数，绝大部的数据处理都是基于这些构造函数实现的，JavaScript 基础阶段学习的 Date 就是内置的构造函数。 引用类型： Object : 三个常用静态方法（静态方法就是只有构造函数Object可以调用的） Object.keys 静态方法获取对象中所有属性（键） Object.values 静态方法获取对象中所有属性值 Object.assign 静态方法常用于对象拷贝 //Object.keys const obj = {name:'叶湘伦',age:18} const arr = Object.key(obj) console.log(arr) // ['name','age'] 返回是一个数组 //Object.values const arr2 =Object.values(obj) console.log(arr2) // ['叶湘伦',18] 返回是一个数组 //Object.assign const obj2 = {} Object.assign(obj2,obj) console.log(obj2) // {name:'叶湘伦',age:18} //使用：经常使用的场景给对象添加属性 Object.assign(obj,{sex:'男'}) console.log(arr) // {name:'叶湘伦',age:18,sex:'男'} Array : 数组常见实例方法-核心方法 方法 作用 说明 forEach 遍历数组 不返回值，用于不改变值，经常用于查找打印输出值 filter 过滤数组 筛选数组元素，并生成新数组 map 迭代数组 返回新数组，新数组里面的元素是处理之后的值，经常用于处理数据 reduce 累积器 返回函数累计处理的结果，经常用于求和等 总结： 推荐使用字面量方式声明数组，而不是 Array 构造函数 实例方法 forEach 用于遍历数组，替代 for 循环 (重点) 实例方法 filter 过滤数组单元值，生成新数组(重点) 实例方法 map 迭代原数组，生成新数组(重点) 实例方法 join 数组元素拼接为字符串，返回字符串(重点) 实例方法 find 查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点) 实例方法every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回 true，否则返回 false(重点) 实例方法some 检测数组中的元素是否满足指定条件 如果数组中有元素满足条件返回 true，否则返回 false 实例方法 concat 合并两个数组，返回生成新数组 实例方法 sort 对原数组单元值排序 实例方法 splice 删除或替换原数组单元 实例方法 reverse 反转数组 实例方法 findIndex 查找元素的索引值 String： 总结： 实例属性 length 用来获取字符串的度长(重点) 实例方法 split('分隔符') 用来将字符串拆分成数组(重点) 实例方法 substring（需要截取的第一个字符的索引[,结束的索引号]） 用于字符串截取(重点) 实例方法 startsWith(检测字符串[, 检测位置索引号]) 检测是否以某字符开头(重点) 实例方法 includes(搜索的字符串[, 检测位置索引号]) 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点) 实例方法 toUpperCase 用于将字母转换成大写 实例方法 toLowerCase 用于将就转换成小写 实例方法 indexOf 检测是否包含某字符 实例方法 endsWith 检测是否以某字符结尾 实例方法 replace 用于替换字符串，支持正则匹配 实例方法 match 用于查找字符串，支持正则匹配 注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。 原型 JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象 作用： 共享方法 可以把那些不变的方法，直接定义在 prototype 对象上 constructor 属性： 指向该原型对象的构造函数 对象原型：对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有__proto__ 原型的存在 总结： prototype是什么？哪里来的？ 原型（原型对象） 构造函数都自动有原型 constructor属性在哪里？作用干啥的？ prototype原型和对象原型__proto__里面都有 都指向创建实例对象/原型的构造函数 __proto__属性在哪里？指向谁？ 在实例对象里面 指向原型 prototype 原型继承 继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。 封装-抽取公共部分 把男人和女人公共的部分抽取出来放到人类里面 继承-让男人和女人都能继承人类的一些属性和方法 把男人女人公共的属性和方法抽取出来 People 然后赋值给Man的原型对象，可以共享这些属性和方法 注意让constructor指回Man这个构造函数 //人类 const People = { head:1, eyes:2, leys:2, say:function () {} } //男人 function Man(){ } //公共属性和方法给原型 Man.prototype = People //如果我们给男人添加了一个吸烟的方法，发现女人自动也添加这个方法 //男人和女人都同时使用了同一个对象，根据引用类型的特点，他们指向同一个对象，修改一个就会都影响 Man.prototype.smoking = function () {} //女人 function Woamn() { //独有方法 this.body =function () {} } // 继承写法完善 ,解决上面问题 //男人和女人不要使用同一个对象，但是不同对象里面包含相同的属性和方法 //答案：构造函数 //new 每次都会创建一个新的对象 function People() = { head:1, eyes:2, leys:2, say:function () {} } //男人 function Man(){ } //公共属性和方法 Man.prototype =new People() 原型链： 基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为原型链 原型链-查找规则： 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 如果没有就查找它的原型（也就是 __proto__指向的 prototype原型对象） 如果还没有就查找原型对象的原型（Object 的原型对象） 依此类推一直找到 Object为止（null） __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线 深浅拷贝浅拷贝拷贝的是地址常见方法： 拷贝对象：Object.assgin() 展开运算符 {...obj}拷贝对象 拷贝数组：Array.prototype.concat() 或者 [...arr] 总结： 直接赋值和浅拷贝有什么区别？ 直接赋值的方法，只要是对象，都会相互影响，因为是直接拷贝对象栈里面的地址 浅拷贝如果是一层对象，不相互影响，如果出现多层对象拷贝还会相互影响 浅拷贝怎么理解？ 拷贝对象之后，里面的属性值是简单数据类型直接拷贝值 如果属性值是引用数据类型则拷贝的是地址 深拷贝拷贝的是对象，不是地址 常见方法： 通过递归实现深拷贝 lodash/cloneDeep 通过JSON.stringify()实现 异常处理throw 抛异常总结： throw 抛出异常信息，程序也会终止执行 throw后面跟的是错误提示信息 Error 对象配合 throw 使用，能够设置更详细的错误信息 try/catch总结： try...catch 用于捕获错误信息 将预估可能发生错误的代码写在 try 代码段中 如果 try 代码段中出现错误后，会执行 catch代码段，并截获到错误信息 finally 不管是否有错误，都会执行 debugger ：类似浏览器调试打断点 处理thisthis指向-普通函数 普通函数的调用方式决定了 this 的值，即【谁调用 this 的值指向谁】 普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined this指向-箭头函数箭头函数中的 this 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 this ！ 箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的 箭头函数中的this引用的就是最近作用域中的this 向外层作用域中，一层一层查找this，直到有this的定义 改变thiscall() 方法调用函数，同时指定被调用函数中 this 的值 fn.call(thisArg,arg1,arg2,...) 说明： thisArg：在 fn 函数运行时指定的 this 值 arg1，arg2：传递的其他参数 返回值就是函数的返回值，因为它就是调用函数 apply() 调用函数，同时指定被调用函数中 this 的值 fn.apply(thisArg,[argArray]) 说明： thisArg：在fn函数运行时指定的 this 值 argsArray：传递的值，必须包含在数组里面 返回值就是函数的返回值，因为它就是调用函数 因此 apply 主要跟数组有关系，比如使用 Math.max()求数组的最大值 bind() 不会调用函数。但是能改变函数内部this 指向 fn.bind(thisArg,arg1,arg2,...) 说明： thisArg：在 fn 函数运行时指定的 this 值 arg1，arg2：传递的其他参数 返回由指定的 this 值和初始化参数改造的 原函数拷贝 （新函数） 因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind，比如改变定时器内部的 this 指向. 总结： 区别 call 和 apply 会调用函数, 并且改变函数内部 this 指向 call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2.. 形式 apply 必须数组形式[arg] bind 不会调用函数, 可以改变函数内部 this 指向 主要应用场景 call 调用函数并且可以传递参数 apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值 bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向. 节流和防抖 节流： 就是指连续触发事件但是在 n 秒中只执行一次函数，比如可以利用节流实现 1s之内 只能触发一次鼠标移动事件 防抖： 指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间 使用场景 节流： 鼠标移动，页面尺寸发生变化，滚动条滚动等开销比较大的情况下 防抖： 搜索框输入，设定每次输入完毕n秒后发送请求，如果期间还有输入，则从新计算时间","categories":[{"name":"前端篇","slug":"前端篇","permalink":"https://blog.luckjin.cool/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"基础","permalink":"https://blog.luckjin.cool/tags/%E5%9F%BA%E7%A1%80/"}],"author":"Fantasy"},{"title":"WebAPI的基本学习","slug":"webapi","date":"2022-07-17T06:34:02.000Z","updated":"2022-08-12T09:07:06.435Z","comments":true,"path":"posts/6ec968d6.html","link":"","permalink":"https://blog.luckjin.cool/posts/6ec968d6.html","excerpt":"学习 DOM 使用 JS 操作浏览器","text":"学习 DOM 使用 JS 操作浏览器 webAPI的基本学习 作用：使用JS操作html和浏览器 分类：DOM（文档对象模型）、BOM（浏览器对象模型） DOM的内容 DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API 简单来说：DOM是浏览器提供的一套专门用来 操作网页内容 的功能 作用：开发网页内容特效和实现用户交互 DOM树 内容：将HTML以树状的内容直观显示出来，也称文档树 作用：直观体现出标签与标签的关系 ```html&lt;!DOCTYPE html&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; 文本 &lt;a href=\"\"&gt;链接&lt;/a&gt; &lt;h1 class=\"\" id=\"\"&gt;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; &lt;img src=\"https://picgo-fantasy06.oss-cn-guangzhou.aliyuncs.com/img/0d429a429c4b10f6ba024de35a73da88b39e4b6e76b0f7bd95697db1ceaab0b5.gif\" alt=\"0d429a429c4b10f6ba024de35a73da88b39e4b6e76b0f7bd95697db1ceaab0b5\" style=\"zoom:200%;\" /&gt; ### 获取DOM元素 - CSS选择器 匹配到第一个元素，返回一个HTMLElement对象 ```javascript //语法 document.querySelector('CSS选择器') 匹配多个选择器，返回NodeList对象集合，得到是一个伪数组 document.querySelectorAll('CSS选择器') 其他方法 document.getElementByid('id名') document.getElementByTagName('标签名') document.getElementByClassName('类名') 设置和修改DOM元素 修改标签文本内容 //语法： 元素.innerText='' //只能识别内容，不能解释标签 //可以解析标签 即： 元素.innerHTML='&lt;h3&gt;会对html标签进行解析&lt;/h3&gt;' 设置与修改DOM元素的属性 语法：对象.属性=值，最常见的属性比如： href、title、src 等 //例子 let pic =document.querySelector('img') pic.src='./images/pic2.jpg' 通过style修改CSS属性 let box =document.querySelector('div') box.style.width='300px' box.style.paddingLeft ='300px' //注：有链接-符号的需要转换为小驼峰命名法 //即：padding-left--&gt;paddingLeft 修改标签类名 元素.clssName='新类名' //注：直接使用 className 赋值会覆盖以前的类名 //保留可写 元素.clssName='旧类名 新类名' 通过clssList操作css类名 //增加一个类名 元素.classList.add('类名') //删除一个类 元素.classList.remove('类名') //切换一个类,存在就删除,不存在就增加 元素.classList.toggle('类名') 修改表单属性 作用：表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框 获取：DOM对象.属性名；设置：DOM对象.属性名=新值 表单.value='用户名' 表单.type='password' 表单属性中添加就有效果,移除就没有效果,一律使用布尔值表示 如果为true 代表添加了该属性 如果是false 代表移除了该属性比如： disabled、checked、selected 定时器-setInterval() 间歇函数 开启定时器 setInterval(函数，间隔时间) //时间也毫秒为单位，1秒==1000ms 关闭定时器 let timer =setInterval(函数，间隔时间) clearInterval(timer) 事件 事件是在编程时系统内发生的动作或者发生的事情，比如用户在网页上单击一个按钮 事件监听 让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为 注册事件 语法：元素.addEventListener('事件',要执行的函数) //获取元素 let btn=document.querySelector('button') //事件监听 btn.addEventListener('click',function(){ alert('被点击了') }) 事件监听三要素： 事件源：那个dom元素被事件触发了，要获取dom元素 事件：有什么方式触发，比如鼠标点击click 事件触发时调用的函数 版本 DOM L0 语法：事件源.on事件=function(){} btn.onclick=function(){ alert('点击') } DOM L2 ⭐ 语法：事件源.addEventlistener(事件，事件处理函数) btn.addEventListener('click',function(){ alert('点击') }) 事件类型 高阶函数 高阶函数可以被简单理解为函数的高级应用，JavaScript 中函数可以被当成【值】来对待，基于这个特性实现函数的高级应用 函数表达式let counter=function(x,y){ return x+y } //调用 let result=counter(1,2) 回调函数 如果将函数A当作参数传递给函数B时，我们称函数A为回调函数 回调函数本质还是函数，只不过把它当成参数使用 使用场景 定时器setInterval() 间歇函数 function fn(){ alert('我是回调函数') } //fn传递了给setInterval ，fn就是回调函数 setInterval(fn,1000) 事件监听 btn.addEventListener('click',function(){ alert('我是回调函数') }) 环境变量 环境对象指的是函数内部特殊的变量 this ，它代表着当前函数运行时所处的环境作用：弄清楚this的指向，可以让我们代码更简洁 函数的调用方式不同，this 指代的对象也不同 【谁调用， this 就是谁】 是判断 this 指向的粗略规则 直接调用函数，其实相当于是 window.函数，所以 this 指代 window 编程思想排他思想当前元素为A状态,其他元素为B状态 使用： 干掉所有人使用for循环 复活他自己通过this或者下标找到自己或者对应的元素 //给点击的li加上pink类 &lt;li class='pink'&gt;第一个&lt;/li&gt; &lt;li&gt;第二个&lt;/li&gt; &lt;li&gt;第三个&lt;/li&gt; let lis = document.querySelectorAll('li') for (let i = 0; i &lt; lis.length; i++) { lis[i].addEventListener('click', function () { // 干掉所有人 for (let j = 0; j &lt; btns.length; j++) { btns[j].classList.remove('pink') } //复活自己 this.classList.add('pink') //==================分割线=========================== //高级做法 // 我只需要找出那个唯一的 pink类，删除 document.querySelector('.pink').classList.remove('pink') // 我的 this.classList.add('pink') }) } DOM结点 DOM树里每一个内容都称之为节点 结点类型 元素结点 ⭐ 所有的标签：比如 body div，html是根节点 属性结点 所有的属性，比如 herf 文本结点 所有的文本 结点的查找结点的关系：父节点，子节点，兄弟节点 父节点的查找 使用parentNode属性，返回最近一级的父节点，找不到返回null 语法：子元素.parentNode 子结点的查找 childNodes - 获得所有的子节点，包括文本节点（空格、换行）、注释节点等 chilrden ⭐ -获得所有元素节点，返回的还是一个伪数组 兄弟结点的查找 nextElementSibling 查找下一个兄弟结点 previousElementSibling 查找上一个兄弟节点 结点的增加 一般情况下，我们新增节点，按照如下操作 1创建一个新的节点 2把创建的新的节点放入到指定的元素内部 创建结点 documnet.createElement('标签名') 追加结点 //插入父元素的最后 父元素.appendChild(要插入的元素) //插到某个子元素的前面 父元素.insertBefore(要插入的元素,在哪个元素的前面) 结点的克隆 cloneNode会克隆出一个跟原标签一样的元素，括号内传入布尔值若为true，则代表克隆时会包含后代节点一起克隆若为false，则代表克隆时不包含后代节点默认为false 语法：元素.cloneNode(布尔值) 结点的删除 删除节点和隐藏节点（display:none） 有区别的： 隐藏节点还是存在的，但是删除，则从html中删除节点在 JavaScript 原生DOM操作中，要删除元素必须通过父元素删除 语法：父元素.removeChild(要删除的元素) 重绘和回流浏览器进行界面渲染 解析（Parser）HTML，生成DOM树(DOM Tree) 同时解析（Parser） CSS，生成样式规则 (Style Rules) 根据DOM树和样式规则，生成渲染树(Render Tree) 进行布局 Layout(回流/重排):根据生成的渲染树，得到节点的几何信息（位置，大小） 进行绘制 Painting(重绘): 根据计算和获取的信息进行整个页面的绘制 Display: 展示在页面上 回流(重排) 当 Render Tree 中部分或者全部元素的尺寸、结构、布局等发生改变时，浏览器就会重新渲染部分或全部文档的过程称为回流，简单理解影响到布局了，就会有回流 会导致回流的操作 页面的首次刷新 浏览器的窗口大小发生改变 元素的大小或位置发生改变 改变字体的大小 内容的变化（如：input框的输入，图片的大小） 激活css伪类 （如：:hover） 脚本操作DOM（添加或者删除可见的DOM元素） 重绘 由于节点(元素)的样式的改变并不影响它在文档流中的位置和文档布局时(比如：color、background-color、outline等), 称为重绘 注：重绘不一定引起回流，而回流一定会引起重绘。 练习： let s = document.body.stlye s.padding = '2px' //重排 + 重绘 s.border = '1px solid red' // 重排 + 重绘 s.color = 'red'//重绘 s.backgroundColor = '#666' //重绘 s.fontSize= \"14px\" // 重排 + 重绘 事件高级事件对象 内容：事件对象是个对象，这个对象里有事件触发时的相关信息 例如：鼠标点击事件中，事件对象就存了鼠标点在哪个位置等信息 获取方法： 在事件绑定的回调函数的第一个参数就是事件对象 一般命名为 even 、ev 、e 元素.addEventListener('click',function(e){ //e就是事件对象 }) 常用事件对象的属性 type ：获取当前事件类型 clientX / clientY ：获得光标相对于浏览器可见窗口左上角的位置 offsetX / offsetY : 获取光标相对于当前DOM元素左上角的位置 key ：用户按下的键盘的值，现在不提倡用 keyCode 事件流 事件流指的是事件完整执行过程的流动路径，两个阶段：事件捕获和事件冒泡 说明：假设页面里有个div，当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段 简单来说：捕获阶段是 从父到子 冒泡阶段是从子到父 事件冒泡 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发 简单理解：当一个元素触发事件后，会依次向上调用所有父级元素的同名事件 事件冒泡是默认存在的 事件捕获 从DOM的根元素开始去执行对应的事件 (从外到里) 说明： addEventListener第三个参数传入true代表是捕获阶段触发（很少使用） 若传入false代表冒泡阶段触发，默认就是false 若是用 L0 事件监听，则只有冒泡阶段，没有捕获 阻止事件流动 因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素 若想把事件就限制在当前元素内，就需要阻止事件流动 阻止事件流动需要拿到事件对象 语法：事件对象.stopProagation() 此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效 鼠标经过事件： mouseover和 mouseout 会有冒泡效果 mouseenter 和 mouseleave 没有冒泡效果(推荐) 两种注册事件的区别： 传统on注册（L0） 同一个对象,后面注册的事件会覆盖前面注册(同一个事件) 直接使用null覆盖偶就可以实现事件的解绑 都是冒泡阶段执行的 事件监听注册（L2） 语法: addEventListener(事件类型, 事件处理函数, 是否使用捕获) 后面注册的事件不会覆盖前面注册的事件(同一个事件) 可以通过第三个参数去确定是在冒泡或者捕获阶段执行 必须使用removeEventListener(事件类型, 事件处理函数, 获取捕获或者冒泡阶段) 匿名函数无法被解绑 事件委托 事件委托其实是利用事件冒泡的特点， 给父元素添加事件，子元素可以触发 优点：给父级元素加事件（可以提高性能） 实现：事件对象.target可以获得真正触发事件的元素 滚动事件 作用：很多网页需要检测用户把页面滚动到某个区域后做一些处理， 比如固定导航栏，比如返回顶部 事件名 scroll //可以给window或document添加滚动事件来监听整个页面 window.addEventListener('scroll',function(){ //要执行的操作 }) 加载事件load 事件 加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件 为什么要学？ 有些时候需要等页面资源全部处理完了做一些事情 老代码喜欢把 script 写在 head 中，这时候直接找 dom 元素找不到 事件名：load 监听页面所有资源加载完毕： 给 window 添加 load 事件 window.addEventListener('load',function(){ //要执行的操作 }) 注意：不光可以监听整个页面资源加载完毕，也可以针对某个资源绑定load事件 DOMContentLoaded 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表全加载 事件名：DOMContentLoaded 监听页面DOM加载完毕： 给 document 添加 DOMContentLoaded 事件 document.addEventListener('DOMContentLoaded',function(){ //要执行的操作 }) 元素大小和位置三大家族 scroll家族 offest家族 client家族 scroll家族 作用：检测页面滚动的距离 获取宽高 获取元素的内容总宽高（不包含滚动条）返回值不带单位 scrollWidth 和 scrollHeight 获取位置（属性可修改） 获取元素内容往左、往上滚出去看不到的距离 scrollLeft和scrollTop div.addEventListener('scroll',function(){ console.log(this.scrollTop) }) 注：document.documentElement ：HTML 文档返回对象为HTML元素 offest家族 获取宽高 获取元素的自身宽高、包含元素自身设置的宽高、padding、border offsetWidth 和 offsetHeight 获取位置（只读，不可修改） 获取元素距离自己定位父级元素的左、上距离 client家族 获取宽高 获取元素的可见部分宽高（不包含边框，滚动条等） clientWidth和clientHeight 位置 clientLeft和clientTop 注意是只读属性 resize事件 改变窗口大小的时候触发的事件，类似css3媒体查询 Window对象BOM 浏览器对象模型 window 是浏览器内置的全局对象，我们所学习的 web apis 的知识内容都是基于 window 对象实现的 window 对象下包含了 navigator 、location 、doucment history 、 srceen 5个属性，即 BOM document 是实现 DOM 的基础，它其实是依附于 window 的属性 依附于 window 对象的所有属性和方法，使用时可以省略 window 定时器-延时函数 JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout 语法：setTimeout(回调函数,等待的毫秒数) setTimeout 仅执行一次，简单来说把一段代码延迟执行 清除延时函数语法 ：clearTimeout(延时函数的id) 结合函数的递归可以实现 setInterval 间歇函数 一样的功能 function myInterval(){ let d=new date(); //写入页面 clock.innertext=d.toLocaleString(); //调用自己 一直循环，倒计时效果 setTimeout(myInterval,1000); } myInterval(); JS执行机制 （面试）⭐ JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。。这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 同步和异步 为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步。 同步 前一个任务执行完才执行后一个任务，程序执行的顺序和代码排列顺序一样 异步 执行一个某个任务费很长时间，在做这个任务的同时，还可以去处理其他的任务 比如：做饭时，等水开的期间可以去其他事，比如切菜 他们的本质区别： 这条流水线上各个流程的执行顺序不同。 同步任务 同步任务都在主线程上执行，形成一个执行栈。 异步任务 JS 的异步是通过回调函数实现的 一般来说异步任务有以下三种类型 1、普通事件，如 click、resize 等2、资源加载，如 load、error 等3、定时器，包括 setInterval、setTimeout 等 异步任务相关会添加的任务队列（消息队列）中 执行机制 先执行执行栈里面的同步任务 异步任务放在消息队列中 一旦执行栈的执行任务完毕，系统会依次读取消息队列里的异步任务，被读取的异步任务结束等待状态，进入执行栈，开始执行 事件循环（event loop） 由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop） location对象 location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分 常用属性和方法： href 属性获取完整的 URL 地址，对其赋值时用于地址的跳转 search 属性获取地址中携带的参数，符号 ？后面部分 hash 属性获取地址中的啥希值，符号 # 后面部分 reload 方法用来刷新当前页面，传入参数 true 时表示强制刷新 语法：loaction.属性 loactiom.方法() navigator对象 navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息 常用属性和方法： 通过 userAgent 检测浏览器的版本及平台 // 检测 userAgent（浏览器信息） !(function () { const userAgent = navigator.userAgent // 验证是否为Android或iPhone const android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/) const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/) // 如果是Android或iPhone，则跳转至移动站点 if (android || iphone) { location.href = 'http://m.itcast.cn' } })() histroy对象 history 的数据类型是对象，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等 history对象和方法 作用 back() 可以后退功能 forward() 可以前进功能 go(参数) 前进，后退功能，参数决定，-1后退，1前进 本地存储 随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案 数据存储在用户浏览器中 设置、读取方便、甚至页面刷新不丢失数据 容量较大，sessionStorage和localStorage约 5M 左右 localStorage 生命周期永久生效，除非手动删除 否则关闭页面也会存在 可以多窗口（页面）共享（同一浏览器可以共享） 以键值对的形式存储使用 语法 存储数据：localStorage.setItem(key, value) 获取数据：localStorage.getItem(key) 删除数据：localStorage.removeItem(key) 存储复杂数据类型存储： 本地只能存储字符串,无法存储复杂数据类型.需要将复杂数据类型转换成JSON字符串,在存储到本地 JSON.stringify(复杂数据类型) ： 将复杂数据转换成JSON字符串 存储 本地存储中 JSON.parse(JSON字符串)： 将JSON字符串转换成对象 取出 时候使用 sessionStorage（了解） 1. 生命周期为关闭浏览器窗口 2. 在同一个窗口(页面)下数据可以共享 3. 以键值对的形式存储使用 4. 用法跟localStorage 基本相同 自定义属性固有属性： 标签天生自带的属性 比如class id title等, 可以直接使用点语法操作 自定义属性: 由程序员自己添加的属性,在DOM对象中找不到, 无法使用点语法操作,必须使用专门的API 获取自定义属性 ：getAttribute('属性名') 设置自定义属性：setAttribute('属性名', '属性值') 删除自定义属性：removeAttribute('属性名') data-自定义属性： 传统的自定义属性没有专门的定义规则,开发者随意定值,不够规范,所以在html5中推出来了专门的data-自定义属性 在标签上一律以data-开头 在DOM对象上一律以dataset对象方式获取 正则表达式 正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象 正则表达式在 JavaScript中的使用场景： 例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配) 比如用户名: /^[a-z0-9_-]{3,16}$/ 过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。 语法使用： 定义规则 查找 语法：let 变量名=/表达式/ / / 是正则表达式字面量，比如 ：let reg=/abc/ 判断： test() 方法 用来查看正则表达式与指定的字符串是否匹配 ，返回 false 或 true let str = 'hello ,world' let reg = /hello/ console.log(reg.test(str)) //true exec() 方法 在一个指定字符串中执行一个搜索匹配 如果匹配成功，exec() 方法返回一个数组，否则返回null 元字符 是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。 比如，规定用户只能输入英文26个英文字母，普通字符的话 abcdefghijklm….. 但是换成元字符写法： [a-z] 方便记忆和学习，众多的元字符进行了分类： 边界符（表示位置，开头和结尾，必须用什么开头，用什么结尾） 正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符 注意：如果 ^ 和 $在一起，表示必须是精确匹配。 量词 （表示重复次数） 量词用来 设定某个模式出现的次数 注意： 逗号左右两侧千万不要出现空格 字符类 （比如 \\d 表示 0~9） [ ] - 连字符 使用连字符 - 表示一个范围 [ ] 比如： [a-z] 表示 a 到 z 26个英文字母都可以 [a-zA-Z] 表示大小写都可以 [0-9] 表示 0~9 的数字都可以 [ ] [ ] 里面加上 ^ 取反符号比如：[^a-z]匹配除了小写字母以外的字符 注意要写到中括号里面 [ ] . 匹配除换行符之外的任何单个字符 [ ] 预定义：指的是某些常见模式的简写方式 修饰符 修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等 语法： /表达式/修饰符 i 是单词 ignore 的缩写，正则匹配时字母不区分大小写g 是单词 global 的缩写，匹配所有满足正则表达式的结果 console.log(/a/i.test('a')) //true console.log(/a/i.test('A')) //true 替换 replace 替换：（过滤敏感词） 字符串.replace(/正则表达式/，'替换的文本') ​","categories":[{"name":"前端篇","slug":"前端篇","permalink":"https://blog.luckjin.cool/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Github","slug":"Github","permalink":"https://blog.luckjin.cool/tags/Github/"}],"author":"Fantasy"},{"title":"html and css","slug":"html-and-css","date":"2022-05-04T04:31:45.000Z","updated":"2022-08-11T04:24:53.919Z","comments":true,"path":"posts/28784acc.html","link":"","permalink":"https://blog.luckjin.cool/posts/28784acc.html","excerpt":"","text":"整体结构&lt;html&gt; &lt;!--开始标签--&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;!--字符编码避免网页文字乱码--&gt; &lt;title&gt;网页的标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--网页的基本内容--&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--结束标签--&gt; 初级标签 标题标签 H1，H2，….，H6。（1—&gt;6）大标题—&gt;小标题，成对出现，开始标签 &lt;H1&gt; ，一个结束标签 &lt;/H1&gt; 。 段落标题 段落是通过 &lt;p&gt; 标签进行定义的，成对出现，开始标签 &lt;p&gt; ，一个结束标签 &lt;/p&gt; 。 文字标签 &lt;strong&gt;&lt;/strong&gt;，加粗文字标签；&lt;em&gt;&lt;/em&gt; 斜体文字标签，可嵌套 符号标签 &lt;del&gt;&lt;/del&gt;，在文字上添加删除线，如：文字 高级标签 块状标签 &lt;div&gt;&lt;/div&gt; ,每一个div占满一整行。 &lt;span&gt;&lt;/span&gt;，文本信息在一行展示 空格和换行，尖括号 &lt;br&gt; 换行标签，&amp;nbsp; 空格符号，&amp;lt左尖括号，&amp;gt; 右尖括号 有序列表标签 &lt;ol&gt; &lt;!--网页显示--&gt; &lt;li&gt;第一条&lt;/li&gt; &lt;!--1.第一--&gt; &lt;li&gt;第二条&lt;/li&gt; &lt;!--2.第二--&gt; &lt;li&gt;第三条&lt;/li&gt; &lt;!--3.第三--&gt; &lt;/ol&gt; &lt;ol&gt; 可以增加属性，type，换排序符号； 如 &lt;ol type=\"A\"&gt; ，就从A，B顺序排列；符号可以换 A,a,1,i I ，不填默认数值1； 倒叙 &lt;ol reversed=\"reversed\"&gt; ； &lt;ol start=\"数值\"&gt;，更换开始符号的数值； 无序列表标签 &lt;ul&gt; &lt;li&gt;第一条&lt;/li&gt; &lt;li&gt;第二条&lt;/li&gt; &lt;li&gt;第三条&lt;/li&gt; &lt;/ul&gt; 默认每一段文本前面显示小圆点 属性：&lt;ul type=disc&gt; 默认值实心小圆点，circle 空心小圆点，square 小方块 图片插入 &lt;img src=\"图片路径\"&gt; 包括： 1，网上url； 2，本地的绝对路径(同一个文件夹下，直接写图片文件名)； 3，本地的相对路径(不同一个文件夹下，写完整图片路径)； 属性： 1，&lt;img src=\"图片路径\" alt=\"图片占位符\"&gt;，即图没有加载出来时显示 2，&lt;img src=\"图片路径\" title=”图片提示符“&gt;，即鼠标移到图时显示 链接标签a 超链接：&lt;a href=\"网址\"&gt;网站名&lt;/a&gt; 锚点：&lt;a href=\"#id\"&gt;文字&lt;/a&gt;；id指某个标签的id名字，运用于：页面目录，回到顶部 打电话或发邮件：&lt;a href=\"tel:电话号码\"&gt;文字&lt;/a&gt;；&lt;a href=\"mailto:邮箱地址\"&gt;文字&lt;/a&gt; 协议限定符：使用js 属性：target=_blank 点击链接在新页面弹出 表单 信息输入框 &lt;form method=\"get\" action=\"\" &gt; &lt;!--action：发送出去的地址--&gt; name: &lt;input type=\"text\" name=\"name\" /&gt; &lt;!--文本输入框，name：数值内容--&gt; password: &lt;input type=\"password\" name=\"password\" /&gt; &lt;!--密码输入框，name：数值内容--&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;!--提交按键，value：数据值--&gt; &lt;/form&gt; 单选框 &lt;form method=\"get\" action=\"\" &gt; &lt;!--action：发送出去的地址--&gt; &lt;p&gt; 选择其中一个 &lt;/p&gt; 1.第一个&lt;input type=\"radio\" name=\"name\" value:\"one\"&gt; &lt;!--name相同表示同个选择问题--&gt; 1.第二个&lt;input type=\"radio\" name=\"name\" value:\"two\"&gt; 1.第三个&lt;input type=\"radio\" name=\"name\" value:\"three\"&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;!--提交按键， value：数据值--&gt; &lt;/form&gt; 副选框 &lt;input type=\"checkobx\" name=\"题目\" value:\"提交的数值\"&gt; &lt;!--大致与上面相同--&gt; 选项下拉菜单 &lt;select name=\"\"&gt; &lt;option&gt;选项一&lt;/option&gt; &lt;option&gt;选项二&lt;/option&gt; &lt;/select&gt; 表单添加默认选项：标签后加入 checked=\"checked\" 引入CSS 行间样式 &lt;div style=\"css定义内容\"&gt; &lt;/div&gt; 页面级CSS 在头部标签 &lt;head&gt; 下加入 &lt;style type=\"text/css\"&gt; &lt;!--css定义内容--&gt; &lt;/style&gt; 外部CSS文件 新加一个文件后缀为.CSS 在头部标签 `&lt;head&gt;` 下加入 &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"CSS文件位置\"/&gt;\\ CSS选择器 id，在div标签加入id名 &lt;!--id创建--&gt; &lt;div id=\"填id名\"&gt;&lt;/div&gt; &lt;!--下面css定义,引入css页面填写--&gt; #id名{ \"css定义内容\" } class，在div标签加入class名 &lt;!--class创建--&gt; &lt;div class=\"填calss名\"&gt;&lt;/div&gt; &lt;!--下面css定义,引入css页面填写--&gt; #id名{ \"css定义内容\" } 标签选择 &lt;!--下面css定义,引入css页面填写--&gt; 标签名{ \"css定义内容\" } 属性，如[id]，[class]，[id=”123”]… &lt;!--下面css定义,引入css页面填写--&gt; [属性]{ \"css定义内容\" } 通配符，对所以标签都生效 &lt;!--css定义,引入css页面填写--&gt; *{ \"css定义内容\" } 父子选择器/派生选择器 &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;!--对 1 进行css定义--&gt; &lt;/div&gt; &lt;!--下面css定义,引入css页面填写--&gt; div span{ \"css定义内容\" } 直接子元素选择器 &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;!--对 1 进行css定义--&gt; &lt;span&gt;2&lt;/span&gt; &lt;/div&gt; &lt;!--下面css定义,引入css页面填写--&gt; div &gt; span{ \"css定义内容\" } 并列选择器 &lt;div&gt; 1 &lt;/div&gt; &lt;div calss=\"demo\"&gt; 2 &lt;/div&gt; &lt;!--对 2 进行css定义--&gt; &lt;p calss=\"demo\"&gt; 3 &lt;/p&gt; &lt;!--下面css定义,引入css页面填写--&gt; div.demo{ \"css定义内容\" } 分组选择器 &lt;!--对 1,2,3 进行css定义--&gt; &lt;em&gt; 1 &lt;/em&gt; &lt;strong&gt; 2 &lt;/strong&gt; &lt;span&gt; 3 &lt;/span&gt; &lt;!--下面css定义,引入css页面填写--&gt; em,strong,span{ \"css定义内容\" } 伪类选择器 &lt;!--将鼠标悬浮在改标签时的变化，css定义--&gt; &lt;a href=\"链接地址\"&gt;链接文本&lt;/a&gt; &lt;!--下面css定义,引入css页面填写--&gt; a:hover{ \"css定义内容\" } CSS选择器的优先级 !import&gt; 行间样式 &gt; id &gt; class =属性 &gt; 标签选择 &gt; 通配符 !import 在CSS定义内容后可加上 优先级是根据各个选择器的权重大小比较的 | 选择器 | 权重 || :—————————-: | :———————-: || !import | Infinity (无穷大) || 行间样式 | 1000 || id | 100 || class | 属性 | 伪类 | 10 || 标签 | 伪元素 | 1 || 通配符 | 0 | 注：权重之间是256进制 CSS语法 基本样式 选择器{ 属性名1：属性值1; 属性名2：属性值2; 属性名3：属性值3; } /*例如定义一个div*/ div{ width:100px; height:100px; background:red; } 文字定义 font-size:16px; /* 调整文字大小 */ font-weight:bold; /* 调整文字粗细 可选属性，默认是 \"normal\"，\"bold\" 是加粗，可直接写数值: \"100-900\" 之间。*/ font-style:normal; /* 属性值：\"italic\" 斜体的字体样式, \"oblique\" 倾斜的字体样式*/ font-family:字体名称; /* 可以修改显示的字体 */ /*字体颜色定义，三种方法*/ color:rgb(0,0,0); /* 红，绿，蓝 三个颜色的值 0-255*/ color:#000000; /* 可以分开00-00-00，代表红，绿，蓝的值，用16进制数表示 */ color:red; /*直接所以英文颜色名字*/ 段落文字定义 /* 段落文字水平居中 */ text-align:center; /* 可以选属性，靠左 \"left\"，靠右：\"right\" */ line-height:10px; /* 行高，行间距 */ text-indent:2em; /* 首行缩进两个字符大小；1 em= 1 font-size */ text-decoration:line-through; /* 删除线 */ text-decoration:underline; /* 下划线 */ text-decoration:overline; /* 上划线 */ 边框 borde(边框) /* 边框宽度 | 边框样式 | 边框颜色 */ border:1px dashed green; /* \"dashed\" 虚线；\"solid\" 实线 */ /*可以分开4个边角定义*/ /* 例如左边left,可选 tiop，right，bottom */ border-left:1px dashed green; margin(外边距) padding（填充） margin/padding:1px ，margin/padding:30%； 对应四个上，下，左，右位置大小的值 可拆开， margin/padding-top，依此类推 元素的类型 每一个元素都有默认的 display 属性值； 行类元素 特点：内容决定元素所占位置，不可以通过css改变宽高 行内元素标签：span strong a em del CSS默认：display: inline; 凡是带有 inline 的元素，都有文字特征 块类元素 特点：独占一行，可以通过css改变宽高 块内元素标签：div p ul li ol form address CSS默认：disply: block; 行级块元素 特点：内容决定改变大小，可以通过css改变宽高 行级块元素标签：img CSS默认：disply: inline-block; 盒子模型 内容 CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin），边框（border），填充（padding），和实际内容（content）。 盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。 结构图 说明 Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像 宽度和高度的计算 总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距; 总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距 定位absolute 定位 脱离原来位置进行定位 位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;； absolute 定位使元素的位置与文档流无关，因此不占据空间 relative 定位 保留原来的位置进行定位 相对自己原来的位置进行定位 元素虽然偏移某个距离，但仍然占据原来的空间 fixed 定位 元素的位置相对于浏览器窗口是固定位置。 即使窗口是滚动的它也不会移动 CSS定位属性 top bottom left right 分别对应上，下，左，右位置的值，可用数值 与百分比 top:1px ，top:30%； .social-share { font-size: 0.85em !important; }","categories":[{"name":"前端篇","slug":"前端篇","permalink":"https://blog.luckjin.cool/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"基础","slug":"基础","permalink":"https://blog.luckjin.cool/tags/%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"前端篇","slug":"前端篇","permalink":"https://blog.luckjin.cool/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.luckjin.cool/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.luckjin.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"node.js","slug":"node-js","permalink":"https://blog.luckjin.cool/tags/node-js/"},{"name":"基础","slug":"基础","permalink":"https://blog.luckjin.cool/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Github","slug":"Github","permalink":"https://blog.luckjin.cool/tags/Github/"}]}